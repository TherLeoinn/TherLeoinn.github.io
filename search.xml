<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023.12.30_学习日记</title>
    <url>/2023/12/30/2023.12.30_%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：阴<br>学习地点：宿舍<br>学习时长：4h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>图的算法<ol>
<li>图的遍历（BFS, DFS）</li>
<li>最小路径（Dijkstra）</li>
<li>最小生成树（Prim, K）</li>
</ol>
</li>
<li>神策面试题和美团面试题<ol>
<li><img src="/2023/12/30/2023.12.30_%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/a0c3a998fd4e6182648b3c4c61ba7d7.png" alt="Alt text"><br><em>这个题很简单，一个是下标一个是值，找到数学算法之后直接遍历一次就行，遍历的时候记录res。</em></li>
<li><img src="/2023/12/30/2023.12.30_%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3ba9852c15f8184e6cd1dd43d1f241b.png" alt="Alt text"><br><em>俩数组把值变得一样，这个原题比较简单，递归+动态规划就行，leetcode72编辑距离难一点，是字符串不是数组，边界问题要细心考虑。</em></li>
</ol>
</li>
</ol>
<h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>这几个面试题不太难，看一遍基本就会了，动态规划忘的有点多，今天做了一个热热手，碰到越界问题找错太麻烦了，还好有万能的GPT省了我很多时间。今天起的太晚了，明天早起，over。</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2023.12.31_学习日记</title>
    <url>/2023/12/31/2023-12-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：阴（重度污染）<br>学习地点：宿舍<br>学习时长：5h（2023的最后一天也要进步！）</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>美团面试题（leetcode1162）<br><img src="/2023/12/31/2023-12-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/a481855af7730251c3d3aaa276bb352.png" alt="Alt text"><br><em>这个题用广度优先搜索，找所有岛的周围海域，用到deque，每遍历一遍step+1。</em></li>
<li>微软面试题（leetcode2384）<br><img src="/2023/12/31/2023-12-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/1cda8574d743b7f29392f9f1106b47f.png" alt="Alt text"><br><em>这个题就是用Counter函数统计数字的个数，然后用切片方法把这个词生成出来就行,还有lstrip和rstrip函数，很好用！</em></li>
<li>微软面试题（leetcode2477）<br><img src="/2023/12/31/2023-12-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/7855d0df445fa39a7ec024f131e5c9a.png" alt="Alt text"><br><em>这个题用了图的dfs算法，题不难，但是对dfs的递归要彻底弄透</em></li>
<li>网易面试题<br><img src="/2023/12/31/2023-12-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/a9fdf6d39c625bac7b5109a6c9557f6.png" alt="Alt text"><br><em>这个题可以用动态规划，关键是找到暴力递归的解法，这个递归是范围上的尝试模型，修改i位置的值，可以改为red三个值，同时考虑前面两个值的情况。</em></li>
<li>弗吉尼亚理工大学算法考试题<br><img src="/2023/12/31/2023-12-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/44fb1a48dd31fd0a9b25ada7904830f.png" alt="Alt text"><br><em>暴力递归到动态规划，index选还是不选，分情况讨论，剩余值会变动，最后转化成三维数组动态规划。</em></li>
<li>弗吉尼亚理工大学算法考试题<br><img src="/2023/12/31/2023-12-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e69717d9b1a589d7221cc679155734a.png" alt="Alt text"><br><em>跟上面的题一样，但是可以重复用绳子，所以index递归的时候可以不加1</em></li>
<li>吉尼亚理工大学算法考试题<br><img src="/2023/12/31/2023-12-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9fecc57982124c6632fc6b78d3f199c.png" alt="Alt text"><br><em>一样是选和不选的情况，但是函数变量要用的是上一个选的index，选的时候要判断preindex的结尾值是不是要等于index的初始值，最后动态规划，还可以有更优解法，用hashmap记录（x，y）中y开头的区间，如果有，hashmap+1，从右往左遍历就可以实现。</em></li>
</ol>
<h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>今天coding花了太多时间，题没有做几个，效率不够高，有待加强，明天是2024年了，希望女朋友大人考研成功，也希望我们能好好走下去。</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.01_学习日记</title>
    <url>/2024/01/01/2024-01-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：宿舍<br>学习时长：2h（2024的第一天也在学习！）</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>今天没有学习算法，但是把hexo的动态背景、加载效果等等都设置了一下，吐槽一下，bug太多了，打赏界面图标部署以后一直加载不出来，心烦的嘞。</p>
<h2 id="酒精日记"><a href="#酒精日记" class="headerlink" title="酒精日记"></a>酒精日记</h2><p>下午健身，晚上和家人一起吃饭，喝了红酒、啤酒、白酒。。。又喝杂了。。和哥哥嫂子聊到了女朋友，嘿嘿，很是开心！！坐地铁回到寝室又饿了，现在准备加餐！<br>over</p>
]]></content>
      <categories>
        <category>酒精日记</category>
      </categories>
      <tags>
        <tag>酒精日记</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-01-02-学习日记</title>
    <url>/2024/01/02/2024-01-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：宿舍<br>学习时长：3h（醒酒日。。）</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>字节面试题（leetcode1574变式）<br><img src="/2024/01/02/2024-01-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/018869481261887ca2064d472a264b1.png" alt="Alt text"><br><em>这个题用二分搜索+双指针解，培养画图的能力，有些题把图画出来好解很多，别光靠脑子画图，左右指针分别代表前缀后缀的反向后前指针，然后找最小值即可。</em></li>
<li>京东面试题<br><img src="/2024/01/02/2024-01-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/eebc6b774477d6fb4470a56d5cf86a5.png" alt="Alt text"><br><em>这个题值得反复看，用一个区间套住target并且讨论多种情况下左右边界是否做变化，最核心的思想是这个题最多的操作数是2，如果相同返回0，如果两个小于n的值返回2，然后讨论1的情况，还要用cnt函数数字出现的次数，比较考验思路请不清晰。</em></li>
</ol>
<h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>今天精神状态不佳，不找理由了，明天多做几个题把今天的补上。</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.04_学习日记</title>
    <url>/2024/01/04/2024-01-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：宿舍<br>学习时长：6h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>小红书面试题<br><img src="/2024/01/04/2024-01-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/f806571b470cf54c73391b0a4db1f07.png" alt="Alt text"><br><em>这个题先排除掉奇数个的情况以及红蓝数量大于一半的情况。然后将数组按照先无色、红色、蓝色分别排序并且把无色按照cost排序，cost指红色-蓝色cost最大的情况，统计每个颜色的数量，先把所有的无色都变成红色，然后算出有多少个要变成蓝色，然后把无色的前n个变化即可。<a href="https://github.com/algorithmzuo/publicclass2020/blob/master/src/class059/Code01_MagicStone.java">题解链接</a></em></li>
<li>网易面试题（lc135）<br><img src="/2024/01/04/2024-01-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/24d68ed6e3003491d46d5cae0484312.png" alt="Alt text"><br><em>就是从左往右遍历用一个数组记录每个位置连续比左边大的次数，再从后往前遍历一次记录比右边大的次数，最后取最大值即可，比较简单。如果是环形的，那就取局部最小值为1，然后左右遍历，遍历的时候用一个数组即可，左右得分别是局部最小值夹着。</em></li>
<li>腾讯面试题（lc881）<br><img src="/2024/01/04/2024-01-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/86dbeecd667add524a2c17cbeb6e153.png" alt="Alt text"><br><em>直接贪心，先排序，左右两个指针，左右两个值相加小于目标值的时候，左边右移，右边左移count+1，否则，count+1同时右边左移但左边不右移，因为右边的大的数没有小的数可以匹配了，左边还可以继续用，但是右边必须让count更新。</em></li>
<li>京东面试题（lclcr010）<br><img src="/2024/01/04/2024-01-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e9ffc17c308c7a593afcffc4266286e.png" alt="Alt text"><br><em>前缀和加哈希，这个题就是遍历一次，以每个数结尾的和-k值有多少个，并且同时记录前缀和，把前缀和记录到哈希表里，最后遍历相加每一个前缀和的个数即可。这个题很经典，多看</em></li>
</ol>
<h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>今天几个面试题很经典，每天保持做5个题左右，坚持到1月底能做150个题了，加油！希望2月份能拿到好的实习机会。</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.03_学习日记</title>
    <url>/2024/01/03/2024-01-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：宿舍<br>学习时长：8h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>公司面试题<br><img src="/2024/01/03/2024-01-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/48f6153b8cc1ffb4dc9058f9a58d8da.png" alt="Alt text"><br><em>变量复用这个技巧很重要，如果需要之前的一个信息，直接用变量复用，每次遍历该数据即可，整体思路是首先生成rightup和rightdown函数判断右边是否波浪滚动，从右往左遍历生成每个位置右边是否是上下波浪，然后从左往右遍历，如果删掉该位置，那么要符合前后的一些关系才行，这里用到变量复用。记得单独算删掉最后一个位置的情况。</em></li>
<li>火柴拼正方形（leetcode473）<br><img src="/2024/01/03/2024-01-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/5d7c5931282568abefba41a94801321.png" alt="Alt text"><br><em>这个题下次再刷一次，好经典的题，总体来说是判断一堆数字能否拼凑成四个大小一样的值，暴力方法是判断当前位置选择后是否超出边长，如果不超过，那就递归，如果相等，edges就-1，当前长度归0，继续递归。最核心的是status这个值，表示了0-15根火柴是否可选，用二进制表达，选了那就|（1&lt;&lt;i），判断是否全选就是（1&lt;&lt;lenth）-1，然后动态规划，只用记忆化status即可，初始化为0，如果可拼凑就是1，不行就是-1。</em></li>
<li>好子集的个数（leetcode1994，困难题）<br><img src="/2024/01/03/2024-01-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/7648877c92613d9e3efcecbfd82e9bd.png" alt="Alt text"><br><img src="/2024/01/03/2024-01-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3dee3a4807b007200ef3402ff19ddf1.png" alt="Alt text"><br><em>炫耀一下，打败100%用户！！！这个题很难，把0-30的所有数是否有质数表达成0001001010的形式，每个0或1表示当前质数是否是其因数，所以每个数字依次可以用status来表示，对于每个数组，遍历每个数字的次数，集合里每个数的状态形式分别&amp;10位质数的状态形式，如果&amp;后的值为0，说明可以放进去当子集，并且可以放进去这个数字的次数个，而且10位质数状态可能不止一个，是status[number]个，最后把所有的状态相加，不要忽略掉1的情况，每一个1都要×2。</em></li>
</ol>
<h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>这几个题做了起码6h，太难了，今天学到了状态压缩，还有二进制的位运算。。要想好每个题递归的变量，哪些变量是必不可少的，明天继续加油。</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.05_学习日记</title>
    <url>/2024/01/05/2024-01-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：宿舍<br>学习时长：6h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>猿辅导面试题<br><img src="/2024/01/05/2024-01-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c7d4663df3d308218d7c6bbcebad4d5.png" alt="Alt text"><br><em>这个题核心是想到，如果有a个1，那必定有a个0是右括号，剩下n-2a&#x2F;2对括号可以随意更改颜色，k种颜色就是k的这么多次方，然后如果有s种左右括号的确定值存在，就乘以s，最后写递归，i表示位置，j表示左括号比右括号多的个数，有一个剪枝就是当n-i&lt;j时，就得跳出。最后是动态规划。</em></li>
<li>米哈游面试题<br><img src="/2024/01/05/2024-01-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/8294946bf3229d1fe5df4028c2b49a1.png" alt="Alt text"><br><em>这个题首先是要会图的构建，【0：【next】】，list里套list即可，然后想到dfs，题目的要求可以转化为，任意一个head的多条边，颜色至少两种，所以准备两种着色方式，123，132，head为1，另外两条边按照这两条边来着色，用index%3可以重复123这个过程，并且有个筛选过程就是对没着色的才着色，着色的是父节点。然后一直dfs，最后对其他边分别着色132即可，最后返回colors数组。还有如果没找到有多个子节点的head的话，就返回1，1就行。</em></li>
<li>逆波兰式（lc150）<br><img src="/2024/01/05/2024-01-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/bcd35c15e39d8142dac539760e3619e.png" alt="Alt text"><br><em>逆波兰式表达成算术表达式，就是用到两个栈，第一个栈放值，第二个栈放值得类型，分为数字，加减，乘除，如果是数字，直接加入栈，如果是加减，返回一个a + b，并且第二个栈入加减，如果是乘除，第二个栈入乘除，然后判断左边和右边的数得类型，如果是加减那就要加括号，再返回。</em></li>
<li>lc2360（想了很久很久）<br><img src="/2024/01/05/2024-01-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/37d6bd87c5e867b8ea56376dc94b2b3.png" alt="Alt text"><br><em>这个题就是用一个数组记录访问该点的时间，如果该点访问过，还要判断访问时间和当前时间的大小，区分是老环还是新环，这个题做了两三个小时，又想多做两个题，又饿，搞得后面很紧张，其实题目本身不难，但是太急了，什么都想不好。。。</em></li>
<li>打怪物<br><img src="/2024/01/05/2024-01-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/bfced3fc9aca69b23ba938f7d3e897f.png" alt="Alt text"><br><em>看血量，很大，所以放弃递归，然后想到二分法能不能做，看单调性。先找到中间值看能不能死，不可能死就在右边，能死就在左边，判断能不能死就看每次的攻击伤害谁更高。任何窗口和二分问题都要看单调性。</em></li>
<li>最大栈<br><img src="/2024/01/05/2024-01-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/0c093874f1d1776df76d31285fa02c9.png" alt="Alt text"><br><em>用加强堆来实现栈内的元素排序，保存的是节点的内存地址，栈内放的元素是双向链表。这样就能实现最大栈。</em></li>
</ol>
<h1 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h1><p>今天刷题数量达标，最大栈这个问题还要看看，加强堆的结构后面再去了解一下，加油！</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.06_学习日记</title>
    <url>/2024/01/06/2024-01-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：宿舍<br>学习时长：3h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>航班问题（lc1109）<br><img src="/2024/01/06/2024-01-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/69a278f5f666b0883c0e707171af482.png" alt="Alt text"><br><em>数组上累加数字并且数字相同的话，想到差分法，在i加上该数字，j+1减该数字，最后遍历一遍，后一个数&#x3D;前一个数加当前数字即可。学到新方法，差分法，类似于前缀和。</em></li>
<li>最小轮调（lc798）<br><img src="/2024/01/06/2024-01-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/53fa795034930c01a39093ac7473838.png" alt="Alt text"><br><em>看到这个题，想到用cnt记录移动0-k个单位的得分，因为是连续的一样的数字，所以想到用差分数组，然后分情况讨论值是否大于当前值的不同情况，最后遍历数组即可。</em></li>
<li>小红书笔试题<br><img src="/2024/01/06/2024-01-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/65938a7de1604b611556afae52a63fd.png" alt="Alt text"><br><em>这个题就是把想到0的个数-1的个数最多的时候，就翻转这个数组，这个时候把0变成1，1变成-1，就能找到0-1最多的区间了。</em></li>
</ol>
<h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>今天学到了差分法，第一个数字+1，最后一个数字下一位-1。还有把数字换成1，-1，求和就可以得到两个对象个数相减的个数。明天继续学习</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.07_学习日记</title>
    <url>/2024/01/07/2024-01-07-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：宿舍<br>学习时长：2h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>小红书笔试题<br><img src="/2024/01/07/2024-01-07-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2e0f4af4161e72112ca37eec5628c06.png" alt="Alt text"><br><em>找一个数组的任意范围内最大值，用NlogN实现，想到用RMQ方法实现，这个方法是指第i个数往后的2的j次方个数的最大值，跟动态规划一样，先把第一行填完，i行j列，第一行就是每个值填进去就行，然后下面每一行都依赖前一行的值，因为i行j列依赖i行j-1列和后面那一堆的最大值然后取最大值。填完以后想找某个区间最大值就是找这个区间有多少个数，然后2的多少次方能到这个数，最后前后两个区间取最大值，O1的操作。</em></li>
<li>腾讯音乐面试题<br><img src="/2024/01/07/2024-01-07-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9af13223e2ff237dc3fcaff3096aa62.png" alt="Alt text"><br><em>两种方法，1：其实就是统计连续0的方法然后相乘，每个连续零可以搞个动态规划表出来，长度表示最大值，宽度表示数组长度，dp【i，j】就是4个连续0填3个格子的大小，最后返回几个dp值得乘积。2：第二个方法是用数学方法，n个数字里取m个单调不减数列，就是C（n+m，m），然后找到连续0得个数，最后乘起来。</em></li>
</ol>
<h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>今天学习时间比较短，明天要出门旅游，寒假开始喽，每天也要坚持刷题。</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.08_学习日记</title>
    <url>/2024/01/08/2024-01-08-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：多云<br>学习地点：寝室<br>学习时长：3h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>这周要旅游，下周统一更新具体学习内容。</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.09_学习日记</title>
    <url>/2024/01/09/2024-01-09-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：无<br>学习时长：0h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>今天没有学习，下周统一更新学习内容。</p>
]]></content>
      <tags>
        <tag>学习日记</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.16_学习日记</title>
    <url>/2024/01/16/2024-01-16-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：家<br>学习时长：3h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>今天在火车上看了视频，把堆结构简单复习了一下，明天开始正式学习！</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.17_学习日记</title>
    <url>/2024/01/17/2024-01-17-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：小雨<br>学习地点：家<br>学习时长：7h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>配置新的hexo博客<br>昨天晚上和今天一直在重新配置hexo，之前的博客突然不能上传了，改了很久才弄好，错误来源主要是环境配置的问题，<a href="https://blog.csdn.net/good_good_xiu/article/details/118567249">解决链接</a>在这里。<br>还有hexo图片加载不出来的情况，安装插件，重新配置即可。</li>
<li>算法题<br><img src="/2024/01/17/2024-01-17-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/75d1120c9956b829a75dedbf784c353.png" alt="Alt text"><br><em>子序列：不连续；子串：连续。这个题就是从左到右的尝试模型，四种基本模型之一，n个数选2个数加起来为偶数，dp[n][2],这个值取决于当前数到底选不选，不选的话，就依赖dp[n-1][2],选的话，就要看当前数是奇数还是偶数，奇数的话，那就依赖另一个dp表，dp~[n-1][1],如果是偶数，就依赖dp[n-1][1]。两个dp表都要填数，最后选和不选的情况分别相加即可。</em></li>
<li>微众算法题<br><img src="/2024/01/17/2024-01-17-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/d78a9cdddbcb6ce80c1c4465b529792.png" alt="Alt text"><br><em>这个题思路很难，核心思路是abc取余等于0的个数等于a00取余+ab0取余等于0的个数相加再加上abc是否取余等于0，需要两个表，cur和next表，next用来迁移，之后再看一次这个题解。<a href="https://www.bilibili.com/video/BV1DT411s7hp?p=31&vd_source=d980f353cbdc64ff6011544e1f205261">链接点这里</a></em></li>
<li>lc1345（困难题）<br><img src="/2024/01/17/2024-01-17-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/f263b8dab0a331a376f26ed29a2821f.png" alt="Alt text"><br><em>这个题用到宽度优先遍历bfs。用列表表示队列的方法需要再巩固一下，关键思路是用defaultdict记录每个数字出现的位置，用另一个数组表示是否访问该位置，最后bfs遍历整个数组，左边右边以及重复的数字如果不越界或者没有访问过就放到queue里，最后对cur进行pop操作，这是一个大的优化，优化以后就不会出现重复的遍历了。queue【0】要先放数字，再往下遍历。每个细节都要注意。</em></li>
<li>微众人工智能面试题<br><img src="/2024/01/17/2024-01-17-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c1380476e9dbb17407b789eefad95f6.png" alt="Alt text"><br><em>首先，判断一个数是否为偶数用a&amp;1 &#x3D;&#x3D; 0就行，然后这个题正常方法是用递归，四个参数，rest，who’s turn, jia数量， yi数量，如果rest为0，返回jia是否为偶数，如果rest不为0，继续递归，如果现在是jia回合，那么for循环3次，注意这里的循环次数要看rest数量的最小值，循环后就是rest-i，1，jia+i，yi的递归如果equals（jia），那么返回jia，第二种情况也类似。最后的优化是打表找规律，看看有没有规律，有的话，直接返回规律就行。</em></li>
<li>做了明天汇报的ppt</li>
</ol>
<h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>今天大部分时间在搞hexo，明天上午和晚上多花时间在算法上，再接再厉！</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>hexo配置问题</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.18_学习日记</title>
    <url>/2024/01/18/2024-01-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：小雨<br>学习地点：家<br>学习时长：6h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>开组会<br>今天在组会上汇报了本学期工作，以及对2024春季学期的展望。</li>
<li>面试题<br><img src="/2024/01/18/2024-01-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2526e4ae6612cd6baec542ce033ac4c.png" alt="Alt text"><br><img src="/2024/01/18/2024-01-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/af916597493ea147b8a82b0c2220f61.png" alt="Alt text"><br><em>这个题有两问，第一问是有序，第二问无序。有序情况下，两种方法，哈希表和二分法，哈希表额外空间复杂度On，二分法O1，二分法就是先到中点，看这个值是不是等于n&#x2F;2，如果是的话，看下一位如果是n&#x2F;2+1，那么二分到后面半段，然后重复即可。第二问无序情况，就是追及问题，用快慢指针，快指针两步，慢指针一步，最后相遇以后快指针回到最初，然后快慢指针各走一步，最后相遇的点就是重复值。</em></li>
<li>蓝桥杯练习题<br><img src="/2024/01/18/2024-01-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/4b95e96607337e4c32ec60ddf6d4e2c.png" alt="Alt text"><br><em>这个题很难，是打表找规律的题，1到100的因子平方和再相加，其实是把1到100所有因子个数求出来，然后平方相加，首先用两个for循环找出有1-100有多少个因子，用一个数组表示出来，然后找规律，1到根号n的因子i可以找到规律，就是n&#x2F;i这么多次，所以先把这些平方和相加到ans上，然后找后面的规律，后面的规律就是如果是j这么多个，有一个范围的因子都能满足，就是用二分法，找到这个范围，二分法找一个边界即可，用一个函数，然后下边界就是参数+1的上边界-1，找这个边界用到二分法，k乘以中点如果大于n，那么肯定左边界在中点左边，然后重复就能找到边界，然后把每个因子对应的范围累加和到ans上，一个for循环就出来了，a方+b方+c方+d方等于1到d的平方和-1到a-1的平方和，1到n的平方和等于n乘以n-1乘以2n-1&#x2F;6.最后返回ans</em></li>
<li>optiver面试题（还有manacher算法没看）<br><img src="/2024/01/18/2024-01-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/f78342278e61528a7f52d3c7d6a17e9.png" alt="Alt text"><br><em>这个题就是贪心，从第一个找到最后一个，然后要用manacher算法，这个还没听过，等听完再回过来看这个题。<a href="https://www.bilibili.com/video/BV1Ef4y1T7Qi?p=36">manacher算法链接点这里</a></em></li>
<li>字节面试<br><img src="/2024/01/18/2024-01-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/660bf1c5ed5f6671b506725cd828292.png" alt="Alt text"><br><em>这个题看数据量就不能用动态规划，要用到RMQ，RMQ已经忘了，之后再看一下这个题。链接在这里。</em></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.19_学习日记</title>
    <url>/2024/01/19/2024-01-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：小雨<br>学习地点：家<br>学习时长：4h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>网易面试题（lc135进阶）<br><img src="/2024/01/19/2024-01-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/dd0235b4190353ab7c4c87134741706.png" alt="Alt text"><br><em>这个题原版是分发糖果的问题，首先一个小孩分发多少糖果，取决于左边有多少连续比他小的值，也取决于右边有多少连续比他小的值，所以设置两个额外的数组用来放左边和右边两边遍历情况下的当前数值，从1开始，如果右边比左边大，那么加1，如果小或者一样大，继续是1，遍历结束得到左数组，右边的数组也是一样，最后取两个数组的最大值即可。进阶版的就要考虑首尾相连的问题，这个时候就是考虑用局部最小值当作首尾两个值，然后数组按顺序构建新数组解耦掉原数组，然后再分别左右遍历，取最大值即可。</em></li>
<li>小红书笔试题<br><img src="/2024/01/19/2024-01-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b085c2a4b98ae4007068b4c7286f6ea.png" alt="Alt text"><br><em>这个题的思路很简单，就是首先按照红色-蓝色代价排序，然后统计0、红蓝各有多少个，剔除掉奇数、红蓝有大于n&#x2F;2的情况，然后再首先把蓝色需要多少个才能变成一半算出来，红色同样，先全部变成红色，然后数组遍历蓝色次数，把红变蓝需要的代价减掉就行了。<a href="https://github.com/algorithmzuo/publicclass2020/blob/master/src/class059/Code01_MagicStone.java">code在这里</a></em></li>
<li>腾讯笔试题<br><img src="/2024/01/19/2024-01-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/53b4088b7c1d3665b83a71574cad715.png" alt="Alt text"><br><em>这个题是进阶版，低阶版是没有偶数这个条件，低阶版首先是排序，然后左右指针，分别遍历，左指针+右指针如果大于limit，右指针左移，res+1，如果小于等于limit，右指针左移，左指针右移，一个while搞定，最后返回res。进阶版就是分成奇偶两个数组，然后按上述方法统计，最后相加即可。</em></li>
<li>题目<br><img src="/2024/01/19/2024-01-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/4093c6f32f345617de69b4128ab4f6d.png" alt="Alt text"><br><em>子数组是连续的，这个题想到统计以每个位置结尾得时候，有多少个子数组，最后累加。然后想到以i位置结尾的时候，需要找到前缀和为sum-arr【i】的个数，所以前缀和要用一个hashmap统计出来，hashmap里首先要加上一个0：1，因为如果当前数字&#x3D;sum，前缀和如果没有sum-sum这个0值的话，就会生成0，但其实是1，因为子数组就是i位置这一个数形成得数组。所以遍历一次，每次先看前缀和有几个，然后更新当前和到前缀和里，遍历一次累加ans即可。</em></li>
<li>京东笔试题<br><img src="/2024/01/19/2024-01-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3ba337dc2d1c48b847904699ad7b05e.png" alt="Alt text"><br><em>要求每一部分01比例一样，先把整体01比例求出来，分割后的肯定也是这个比例，所以用map记录每个位置的前面所有01比例，如果当前整个是该比例，那么看map里有多少个该比例的个数，如果没有，那就是1，如果有就是1+该map数字，同时如果该位置比例有效，那更新map+1，最后返回res数组。</em></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.20_学习日记</title>
    <url>/2024/01/20/2024-01-20-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：小雨<br>学习地点：家<br>学习时长：6h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>认识复杂度和简单排序 基础知识巩固<ol>
<li>一堆数有两个数出现奇数次，其余都是偶数次，怎么找到两个数？这个时候要用到异或，异或就是相同异或为0，不同异或为1，用一个eor把整个数组都异或，最后会得到a^b，这个值找到其中是1的位数，比如第二位是1，那么a和b第二位必然不同，所以用另一个eor去异或数组中第二位是1的数，最后能得到a或者b，然后用之前的eor异或第二个eor，就能得到另一个值。注意：eor &amp; （~eor + 1）就能取出最右侧的1。</li>
<li>O（N^2）的排序：选择、冒泡、插入。其中插入排序会和数据状况有关系，如果本身有序的时候，那就是O（N）的复杂度，但是排序以最差情况估计，所以还是O（N^2）。</li>
<li>二分法：找局部最小值、找有序数组某个数是否存在、找有序数组的大于某个数的最左侧值等等。</li>
<li>对数器：不依赖线上测试平台也能搞定是否正确。</li>
<li>递归的复杂度（master公式）T(N) &#x3D; aT(N&#x2F;b) + O(N^d)。b：子过程的样本。a：子过程的计算次数。O(N^d)：子结果合并的时间复杂度。满足如上公式的程序都可以根据master公式计算时间复杂度：log(b，a) &gt; d ：时间复杂度为O(N^log(b，a))。log(b，a) &#x3D; d ：时间复杂度为O(N^d * logN)。log(b，a) &lt; d ：时间复杂度为O(N^d)</li>
</ol>
</li>
<li>认识O（N*LogN）排序<ol>
<li>归并排序：方法是左边排序，右边排序，然后merge一下递归。小和问题也可以用归并排序，一个数组，每个位置左边有多少数比当前小，这个可以转化为，右边有多少比当前位置大，然后可以用归并部分找右边有多少比当前大。还有逆序对问题，逆序对就是左边比右边大有多少个对，<a href="https://github.com/algorithmzuo/algorithmbasic2020/blob/master/src/class04/Code03_ReversePair.java">其实也是归并来解决</a></li>
<li>荷兰国旗问题：数组小于等于大于分开，不要求有序。两个区域，一个左一个右，i从左往右，i和左区域边界中间就是等于区域，i位置如果小于5，i和小边界下一个位置交换，小边界往右阔，i往右，如果等于5，i继续往右，如果大于5，i位置和大边界左边交换，大边界左阔，i不动，因为交换后的i还没比较。</li>
<li><a href="https://www.bilibili.com/video/BV1Ef4y1T7Qi?p=26&vd_source=d980f353cbdc64ff6011544e1f205261">快速排序</a>：随机选一个数（很重要，将n^2降到n*logN），和最后一个值交换，然后以最后一个值做荷兰国旗问题，然后递归。partion返回的是一个数组，就是等于这个值的数组。</li>
<li>堆排序：heapinsert方法可以把值向上对比形成大根堆，如果一个数组值一开始就知道，变成大根堆结构可以从倒数第二行开始或者从最后一个数开始，往前依次做heapify，也可以形成大根堆（重点优化）。大根堆最大值跟最后一个值交换，然后heapsize-1，让新的堆重新变成大根堆，用heapify操作，就是从头节点跟子节点最大值比，小的话就交换，周而复始就形成大根堆，然后重复交换最大值和最后一个值，最终形成有序。</li>
<li><a href="https://blog.csdn.net/weixin_46178278/article/details/134703192">小根堆，大根堆</a>：python里堆结构的实现，import heapq，heappush、heappoll方法，适用于小根堆。</li>
<li>比较器：自定义比较，类似于运算符重载。</li>
</ol>
</li>
<li>不基于比较的排序（不是很好用，要根据数据状况来看）<ol>
<li>计数排序，统计每个数的词频，然后遍历输出。</li>
<li><a href="https://www.bilibili.com/video/BV1Ef4y1T7Qi?p=27&spm_id_from=pageDriver&vd_source=d980f353cbdc64ff6011544e1f205261">基数排序</a>：根据个位十位百位来排序，放到几个桶里。放到桶里的操作可以用前缀和来代替。这个比较难懂，可以再看看视频。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.21_学习日记</title>
    <url>/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：雨夹雪<br>学习地点：家<br>学习时长：7h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>排序算法稳定性<br><img src="/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/85a53b7edab80de5b143b316e97cd6d.png" alt="Alt text"></li>
<li>反转单链表、双链表<br>反转单链表：注意要用一个tmp防止cur.next丢失，最后返回的是pre不是cur。<br>反转双链表：跟反转单链表一样，用一个tmp防止cur.next走丢，然后cru.next&#x3D;pre,cur.last&#x3D;tmp。</li>
<li>判断链表有没有环<br>快慢指针，相遇以后快指针回到head，然后快指针变成慢指针走一步，最后相遇就是入环节点。</li>
<li>判断两个链表相交节点<br>首先算出两个节点长度，然后长度相减得到一个值，最后让长链表先走这么多步，然后再一起走，走到交点就返回即可。还有一种情况是两个有环链表相遇，入环节点不一样，这个时候cur到第一个节点开始走，如果cur回到cur遇到了第二个节点，那就是这种情况，否则返回0。</li>
<li>二叉树遍历<br>递归遍历（先中后）：如果head空，返回空，然后print，再递归左，再递归右。<br>迭代遍历（先）：准备一个栈，先把头放进去，然后弹出来，打印，如果有右孩子和左孩子，先把右孩子压入栈，再左孩子压入栈，最后重复。<br><img src="/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2cb6be26d75b7301f7f8395cf6f1294.png" alt="Alt text"><br>后序遍历（迭代）：准备两个栈，一个准备栈，一个收集栈。先把head放进准备栈，再弹出到收集栈，然后弹入左和右节点，再循环，最后打印收集栈即可。因为是按照头右左的方式弹出到收集栈，最后打印就是左右头。<br>中序遍历：如果头节点不为空，那就把头节点整个左边界压入栈，当左节点为空的时候，弹出节点，打印，然后head&#x3D;右节点，再重复循环。<br><img src="/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/8644de21dfe7d8300db85de5b8fce72.png" alt="Alt text"><br>BFS宽度优先遍历：用队列。压入头节点，然后弹出打印，压入左右节点，继续周而复始。<br>求二叉树最大宽度：用队列。有几个变量，一个curlevel，curlevelnode，max，hashmap。头节点进队列，同时哈希表记录头节点的层数1。然后弹出，并且判断当前节点跟curlevel是不是一样，一样的话，curlevelnode++，如果不一样，那么更新max，同时curlevelnode&#x3D;1.然后压入左孩子，右孩子以及对应的层数。<br><img src="/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/7e678a4ba6c92f79b990ffd924015ce.png" alt="Alt text"><br>搜索二叉树：左边都比head小，右边都大。其实就是中序遍历判断是否降序。<br><img src="/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/5f2aec4d6993110d1b0ceea74af68b4.png" alt="Alt text"><br><img src="/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/0b6ed1e9f0db0b023fac6e651725a0a.png" alt="Alt text"><br>完全二叉树：宽度优先遍历，如果cur有右无左，false，如果cur有左无右，leaf&#x3D;true，然后判断如果leaf and 有左或右，那么false。<br><img src="/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/af10ef6348b10477cfa2e183993f6f5.png" alt="Alt text"></li>
<li>二叉树的递归套路<br>左数信息、右数信息，然后再判断。<br>搜索二叉树：lc98<br>用左右两个信息，把最小值最大值放入递归函数里，最小值最大值换成相应节点值。<br><img src="/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c47fa7be686a4fe5fbc5f25cf995dba.png" alt="Alt text"><br>二叉树的最近公共祖先：lc236<br>也可以用递归，如果root是空，p，q之中的话，返回root，否则，返回两边递归值（除非两边递归值都存在，就是pq分别在左右两边，返回root）<br><img src="/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/72a3965ab13004c97336491dae43657.png" alt="Alt text"><br>返回二叉树的后继节点：<br>后继节点是中序遍历的后面的值，其实就是，如果cur有右孩子，那就返回右孩子里最左的孩子，如果没有，就往上看，如果cur是父节点的左孩子，就返回父节点，否则一直往上走<br><img src="/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/f6331620cc7f23b1b5c387fb421ff95.png" alt="Alt text"><br><a href="https://www.bilibili.com/video/BV1Ef4y1T7Qi?p=30&vd_source=d980f353cbdc64ff6011544e1f205261">二叉树的序列化和反序列化</a>：<br>序列化：如果是空，返回#-，首先生成头节点-，然后左边递归、右边递归。<br>反序列化：把序列-用逗号分割，然后放到queue里，然后如果是#，返回空，head创立出来，然后左右分别递归。<br>折痕问题：<br>二叉树可以解决，每个折痕折一次，两边都会生成一个凸一个凹。所以用二叉树中序遍历就能生成上下顺序。<br><img src="/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/1145f1cd1d83f14f46e1b34b4f2b012.png" alt="Alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.22_学习日记</title>
    <url>/2024/01/22/2024-01-22-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：雪<br>学习地点：家<br>学习时长：7h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>图的算法</p>
<ol>
<li>图的表示很多 邻接矩阵 邻接表<br><a href="https://blog.csdn.net/wd9ljs18/article/details/112191078">建立图</a></li>
<li>图的宽度优先遍历<br>用一个set记录走过的node，建立queue，先放入node，set也放入node，然后遍历queue，弹出来并且打印，然后遍历node的nexts，判断nextnode是否在set里，不在的话，加入queue和set。</li>
<li>图的深度优先遍历<br>用一个set记录走过的node，建立stack，先放入node进他们中，然后直接打印，而不是弹出再打印，随后弹出栈，遍历nexts，如果不在set中，栈中放入node，然后再放入nextnode，set放入nextnode，打印nextnode。然后break掉，继续执行while而不是for的内容，这样就可以让node的其他next不会立马入栈，就可以实现深度遍历。</li>
<li>拓扑排序<br><img src="/2024/01/22/2024-01-22-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/7e9f3af61e8ec6f28e371295d0eb62a.png" alt="Alt text"><br>首先生成一个hashmap，记录node和node剩余的入度。生成一个queue，然后遍历整个graph的node，放入hashmap中，如果入度为0，放入queue里。当queue不为空的时候，把queue弹出cur，放入res中，然后遍历next，把hashmap的next入度-1，如果入度为0，继续放入queue中。</li>
<li>最小生成树（K、P算法）<br>K算法：从最小的边开始遍历，如果不形成环，加上，形成环，不加。<br><img src="/2024/01/22/2024-01-22-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/27c07cfed8c4931bf5f188a66a91fe3.png" alt="Alt text"><br>P算法：生成一个小根堆，一个set，首先把node放入set里，遍历node所有边，把边放入小根堆里，然后如果小根堆里有数的话，弹出堆顶的最小边，然后生成最小边的tonode，tonode看在不在set里，如果不在，set加入它，res加入这条边，然后遍历tonode的所有边，把边放入小根堆里即可。</li>
<li><a href="https://www.bilibili.com/video/BV1Ef4y1T7Qi?p=31&vd_source=d980f353cbdc64ff6011544e1f205261">dijkstra算法（迪杰特斯拉算法）</a><br>思路是有一个距离map记录当前距离，有一个set记录锁定一条边，首先把头节点放进map中，然后遍历边，生成tonode，如果tonode不在map里，往map里加上这条边的值，然后更新这个新的值是否比原值大。然后锁定一开始的node，然后从map里选最小值作为下一个要放入的node循环下去。具体看看视频和网页。<br>暴力递归</li>
<li>前缀树<br>具体看视频。暴力递归这一节。建立过程就是如果是abc，头节点以a为路径生成新节点，头节点pass+1，新节点pass+1，直到c加入以后，末节点end+1.可以查询字符串加入过几次（返回end），或者有多少字符以某字符串为前缀（返回pass）。删除操作就是沿途pass-1，最后节点end-1。如果发现一个节点pass-1&#x3D;&#x3D;0了，直接删掉后面所有信息，node.next&#x3D;NONE。</li>
<li>贪心算法<br><img src="/2024/01/22/2024-01-22-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/80a245766834549ad74874bb1af4e87.png" alt="Alt text"><br><em>生成最多会议数量：这个题就是先按照结束时间排序，然后遍历如果上一个选择的结束时间小于遍历到的最新的开始时间，那就选当下的。</em></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.23_学习日记</title>
    <url>/2024/01/23/2024-01-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：雪<br>学习地点：家<br>学习时长：5h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>暴力递归、贪心</p>
<ol>
<li>贪心策略经常依据比较器实现堆或者排序。</li>
<li>返回最大钱数<br><img src="/2024/01/23/2024-01-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/5793f8ffd4d4fa6ae373dcb792bcc74.png" alt="Alt text"><br><img src="/2024/01/23/2024-01-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/5ef24095899d622bf1ef2411303852d.png" alt="Alt text"><br>一个小根堆用比较器进行排序，spend最小的在上面，一个大根堆用比较器排序，利润最大的再最上面。然后遍历小根堆，如果小根堆堆顶的花费小于我得钱，那么弹到大根堆里，如果大根堆空了，就返回money。然后更新money。</li>
<li>取得中位数<br>用两个堆，一个大根堆一个小根堆，先把第一个数字放入大根堆，接下来的数，如果小于大根堆的堆顶，如果是，放进大根堆，如果不是，放进小根堆，然后看size的差如果&#x3D;2，大size堆顶进小根堆。最终就是大根堆放小于中位数的数字，小根堆放大于中位数的数。最后看size，大的那个堆顶就是中位数，如果size相等，就是俩中位数。</li>
<li>N皇后（lc51）<br>版本1（打印出来）：思路就是用回溯算法，首先先生成全是.的n*n列表。主函数是当row走到n越界时，给res返回一种答案，这时候要用空格把每一行的列表变成字符串，然后return，找下一种方法。当到达i行的时候，要遍历每一列，看放到某个位置能不能行，如果能行，先把当前位置变成‘Q’那就继续往下dfs递归，当往下递归失败往上return以后，要把’Q’回复成.，最后bfs（0），然后返回res。判断是否有效就是看上方，左上方，右上方有没有Q，用到zip函数，可以把range的内容合在一起。<br>版本2（返回个数）：用一个record记录每一行放在第几列，然后当i来到n行，返回1，用res更新答案，来到第i行的时候对列遍历，如果有效，那么record记录上该位置j，然后res+dfs递归到下一行的结果，最后返回res，然后判断是否有效就是遍历之前的皇后，如果列数相等或者列数相减的绝对值等于行数相减，那就无效。</li>
<li>取出二进制中最右的1：pos&amp;（~pos+1）。可以用于遍历。</li>
<li>二叉树最大距离值<br><img src="/2024/01/23/2024-01-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/a40b3d58a2ba55a563de7f9aa3a1054.png" alt="Alt text"><br>这个题用到递归套路。第一种情况不要头节点，返回左右两边的最大值，第二种情况要头节点，返回头节点+左边（不为空情况）和头节点+右边（不为空）和头节点+左边+右边（都不为空）的最大值。</li>
<li>返回一个数组，java是返回node，python怎么搞明天搜一下。</li>
<li>数组的除以当前数字的乘积（facebook面试题）<br>要考虑0的个数，非零数乘起来，然后遍历的时候要看当前是不是0，以及0一共有多少个。1个和多个情况不一样。</li>
<li>k进制异或（找到一堆数里的不一样的一个数）<br><img src="/2024/01/23/2024-01-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9a9338190191fa55b078218949a0461.png" alt="Alt text"><br><img src="/2024/01/23/2024-01-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3c2b12f8ee34574de74c1f8c88cde74.png" alt="Alt text"><br>把数组所有数先生成k进制数，累加到一个数组里，然后对k取余，最后转化成10进制。</li>
<li>返回后序遍历数组是否生成最小搜索树<br>最小搜索树就是头节点左边小，右边大，所以后续遍历最后一个值是头节点，然后左边的值必然有个分界线，分界线左边的是头节点左边的值，右边是头节点右边的值，所以用二分法找这个分界线即可。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.24_学习日记</title>
    <url>/2024/01/24/2024-01-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：阴<br>学习地点：家<br>学习时长：4h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>哈希函数和哈希表</p>
<ol>
<li>实现常数复杂度级别的哈希表插入、删除、弹出随机key操作<br>弹出随机key：准备两个哈希表，然后分别插入值和index，index按顺序传，两个表相反。然后按照index随机数弹出。<br>删除：跟上面同样的数据结构，删除key用最后一个key来补之前被删的index的key。size-1。<br>插入：就是直接往后加，index++，然后要加两个哈希表。<br><img src="/2024/01/24/2024-01-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/439350ace3217433033119f517c74a3.png" alt="Alt text"></li>
<li>布隆过滤器（一个set，可以支持插入、查询，需要的内存小，会失误，把白名单认成黑名单url）<br>流程是把url网站通过k个哈希函数再%m，得到一个数，在长度为m的空间里，把这个位置描黑。查找的时候按照相同操作，看这些位置有没有描黑判断这个url在不在黑名单里。m和k都要控制，不然失误率会太大。根据n和m选择k，m相同，k越大，失误率按照先减少后增加的。<a href="https://www.bilibili.com/video/BV1Ef4y1T7Qi?p=34&vd_source=d980f353cbdc64ff6011544e1f205261">三个公式</a>：1小时50分</li>
<li>一致性哈希<br>看视频，听不太懂</li>
<li>网易面试题<br><img src="/2024/01/24/2024-01-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/27dc143da20a8bb212df3afddfbdeff.png" alt="Alt text"><br><img src="/2024/01/24/2024-01-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/77fba4892f1bfaa90341ffb3fd461f1.png" alt="Alt text"><br>这个题主要是考细心，一个数组可以变一个数，怎样才能变成x的倍数。先把整体和算出来，然后看当前数字变成另一个数字以后该数字取余+剩下数字取余是不是等于x或者当剩下取余是0那么取余是不是也等于0的所有情况。</li>
<li>N皇后2（lc52）<br><img src="/2024/01/24/2024-01-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/930147a97ab1b516932a65201f14c9c.png" alt="Alt text"><br>用位运算做的方法很好，取最右边的值，选可用的值等等方法还需要多看看。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.25_学习日记</title>
    <url>/2024/01/25/2024-01-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：阴<br>学习地点：家<br>学习时长：5h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>mysql的下载、安装、启动、数据模型<br>打开cmd，输入mysql -u root -p即可。</li>
<li>sql语言的分类<br>DDL：数据定义语言 DML：数据操作语言，增删改 DQL：数据查询语言，查 DCL：数据控制语言，控制权限，创建数据库</li>
<li>DDL<br><img src="/2024/01/25/2024-01-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/8b7c5f66dc489ae30588276f23042d8.png" alt="Alt text"><br><img src="/2024/01/25/2024-01-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/eb084dc2a05d597442a3b0be0a945f2.png" alt="Alt text"><br><img src="/2024/01/25/2024-01-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9ac94f892821c942bfbe54f509ffd98.png" alt="Alt text"><br><img src="/2024/01/25/2024-01-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e68ffbf44887945bd08fb31e1d7b3ac.png" alt="Alt text"><br><img src="/2024/01/25/2024-01-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9fc811f898b464175625cff82e544dd.png" alt="Alt text"><br>注册了7个月datagrip。datagrip操作更简单一些，可视化。</li>
<li>DML<br><img src="/2024/01/25/2024-01-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/02e2b69655f39d9144bbdd07f154be7.png" alt="Alt text"><br>学到15讲了。明天继续往后更新。</li>
<li>DQL（明天更新）</li>
<li>DCL（明天更新）</li>
<li>子集（lc78）<br><img src="/2024/01/25/2024-01-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b4a2af1cd3a20140cc98430545f7fbb.png" alt="Alt text"><br>所有子集，就是考虑当前数字选或者不选两种情况，所以考虑回溯函数，当index&#x3D;&#x3D;n越界时，返回一个sol，然后return。然后继续回溯，回溯两种情况，第一种要当前值，第二种不要当前值。然后主函数就从index&#x3D;0开始，sol为空数组开始。</li>
<li>全排列（lc46）<br><img src="/2024/01/25/2024-01-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/1d70ecec71c54d6b475f4dffb9eb6e1.png" alt="Alt text"><br>也是用回溯算法做，用check数组检查该位置有咩有选过，当sol长度&#x3D;&#x3D;nums长度，res就添加sol，然后如果选过了continue，没选过就选，check【i】记得在回溯以后要变成0，以免影响后续结果。</li>
<li>全排列2（lc47）<br><img src="/2024/01/25/2024-01-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/db8f6ccf7d033f3711c542857177054.png" alt="Alt text"><br>跟上个题一样，但是要考虑到剪枝，因为按照上面的122和122会出现两次，重复情况必须考虑清楚，所以剪枝条件就是先对nums排序后，如果当前值等于前面的值，并且前面的值没用过，那么下面递归的时候肯定要用到这个值，所以就continue。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.26_学习日记</title>
    <url>/2024/01/26/2024-01-26-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：阴<br>学习地点：家<br>学习时长：5h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>电脑主板烧了，直接没法开机，今天的内容1.30日更新。</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.29_学习日记</title>
    <url>/2024/01/29/2024-01-29-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：阴<br>学习地点：家<br>学习时长：3h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>今天换了新电脑，之前文件基本转移过来了，下各种软件，还有配置博客，这几天没学习，明天更新学习内容。</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.30_学习日记</title>
    <url>/2024/01/30/2024-01-30-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：阴<br>学习地点：家<br>学习时长：9h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>mysql 函数<br><img src="/2024/01/30/2024-01-30-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/d906bbc970b7fe53c7b8fe65b4ccec0.png" alt="Alt text"><br>几个用法用的时候看看就行，比较简单。</li>
<li>约束<br><img src="/2024/01/30/2024-01-30-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/388b5e6699d2505545a81f8ecfadf01.png" alt="Alt text"><br>同上，用的时候看看。</li>
<li>多表查询<br><img src="/2024/01/30/2024-01-30-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/d0acad4f6832e69191886019533d9ac.png" alt="Alt text"><br>看看案例就行，语法比较杂。明天看事务部分。</li>
<li>岛屿问题<br><img src="/2024/01/30/2024-01-30-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/5ece3f922c17a370dbea7e5f542556e.png" alt="Alt text"><br>遍历整个数组，如果值为1，就是岛屿，res+1，同时要对周围进行感染，把上下左右感染成2，然后就是这个感染函数，想清楚函数需要什么参数，i和j要变，grid也要变，然后考虑ij位置，越界了返回。然后把这个点变成2或者0，然后继续递归上下左右四个位置。</li>
<li>并查集<br>查询两个样本是不是在一个集合，两个集合合并都是O1的时间复杂度。<br>issameset：看两个是不是在一个集合，两个点往上找父节点，如果一样，就true。<br>union：看是不是issameset，如果不是，把短的点直接连给长的头节点。<br>准备三个map，elemap对应每个节点自身圈起来。fathermap对应每个节点的所有父节点。sizemap里面只放头节点，记录集合有几个点（包括自己）。<br>首先遍历list到三个表里，ele放自己，father放自己，size放1。<br><img src="/2024/01/30/2024-01-30-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3c4da56ae27f0f119877b02ce7e7183.png" alt="Alt text"><br>记得更新sizemap和fathermap。思路就是如果ele里有这两个点，返回findhead的头节点是否相等。以及如果有两个点，那么findhead分别求出来，长的big，短的small，然后维护size和father信息，sizemap里remove掉small。<br><img src="/2024/01/30/2024-01-30-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/78e6208d912df0ef323dda7314b85ce.png" alt="Alt text"><br>用一个path记录沿途所有father，如果当前的map父节点不等于自己，自己就变成父节点，父节点记录到path，找到后弹出，最后path栈弹出元素的fathermap全更新为找到的父节点。</li>
<li><a href="https://leetcode.cn/problems/number-of-islands/solutions/13103/dao-yu-shu-liang-by-leetcode/">岛屿问题并查集解法</a><br>着重看一下，还没完全掌握。自己写了一个优化版本，但是跑出来不理想。具体就是设置一个unionfind类，类里面有初始化，初始化设置count，parrent（m×n长度），size（m×n长度）。然后遍历整个列表，对于等于1的，把对应的父亲设置成自己的下标，并且count+1。然后设置findfather，如果parent不是自己的下标，那就递归自己的parent，递归前设置path放入当前下标。递归后弹出来path所有值，同时设置他们的父亲为头节点。然后是union函数，找到头节点，不相等的时候看size谁更大，然后把短的头设成长的，如果相等，那么size+1，然后count-1，因为union以后count-1。然后是getcount函数，就是返回本身的count。主函数的设置就是遍历整个数组，如果为1，更新成0，然后对周围四个点遍历，如果没有越界，或者为1，那么就union这个值跟原来的值。最后返回getcount。</li>
<li>最大人工岛问题（lc827困难）<br><img src="/2024/01/30/2024-01-30-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/efc85ed602162d706d3bf2b464be8dc.png" alt="Alt text"><br>这个题也是并查集的应用，着重看一下这个题，python版本怎么写并查集。定义find，union，不用定义类也行，然后想一下为什么不用self也行。设置parent数组n*n，size数组一样，遍历数组，如果为1，对周围四个点为1的union。然后岛屿出来了，size出来了，记录max为最大岛屿size，然后遍历数组，如果为0，建立一个visited集合用来看周围四个点的root，遍历周围四个点，如果为1，找到这个点的root，如果这个点不在visited里，加到visited里面，然后岛屿数t加上这个点的size，四个点遍历完以后更新max，最后返回max即可。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.31_学习日记</title>
    <url>/2024/01/31/2024-01-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：阴<br>学习地点：家<br>学习时长：8h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>mysql事务<br><img src="/2024/01/31/2024-01-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/f9cf044f1fd7cbc089480a90c67e06d.png" alt="Alt text"></li>
<li>进阶篇 存储引擎<br><img src="/2024/01/31/2024-01-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/68be66cf782f3226052708aaf9a8753.png" alt="Alt text"><br>简单看看，感觉不太重要</li>
<li>KMP算法（找子串）<br><img src="/2024/01/31/2024-01-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/1875f6b5ffeb2b49a72510ba75e79eb.png" alt="Alt text"><br><img src="/2024/01/31/2024-01-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/409c1dad985659ece2966d96f744d80.png" alt="Alt text"><br>KMP算法就是AB两个字符串，看A是不是包含B这个子串。整个方法就是首先边界条件设置好，然后生成一个next数组，统计B子串当前位置的开头前缀和结尾前缀相同的个数，然后就是循环，当两个字符串不越界的时候，如果当前位置相同，i，j都+1，如果不同并且next数组位置&#x3D;-1,那么i+1，跳到下一个位置去重新比对，next数组位置不等于-1的话，j位置就跳到next【j】上来，最后返回有两种情况，第一种是A不包含B，A越界，另一种是包含B，B到了终点位置，所以最后如果j到了终止位置，返回i-j，否则返回-1。<br>KMP算法逻辑就是两个字符串，如果对比到i位置不相同，前面都相同，那么B串有两个相同的前缀，然后A串的后前缀跟A的后前缀相同，所以也就跟A的前前缀相同，然后把B子串往后推到该位置来对比就行了，如果相同就继续都+1，不同并且next不为-1，就继续推，推的过程可以用i位置跟next【j】位置来对比就行了。<br>关键是求next数组，0位置-1，1位置0，然后后续就是看n-1位置跟cn位置是不是一样，cn位置就是next【n-1】这个位置，如果相同，那么next【n】&#x3D;next【n-1】+1&#x3D;cn+1，然后n++，同时cn++，如果不相等并且cn&gt;0，那么cn&#x3D;next【cn】，如果cn&#x3D;0，那么next【n】&#x3D;0，并且n++。</li>
<li>重复子串（lc459）<br><img src="/2024/01/31/2024-01-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/0d0287cd916db14e5c34335c63a8dc2.png" alt="Alt text"><br>kmp算法，这个要看包含自身的这个最长子串，所以初始化的时候把s后面加一个空格，然后在算最后一个的next值，这个next值剩下的部分就是重复子串，所以最后返回len能不能整除这个重复字串的长度。把创建next数组的流程记住了，-1，0，然后往后看cn跟i前一个数是不是相等，不相等cn大于0就往前继续找。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.01_学习日记</title>
    <url>/2024/02/01/2024-02-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：阴<br>学习地点：家<br>学习时长：5h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>mysql索引<br><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68&spm_id_from=pageDriver&vd_source=d980f353cbdc64ff6011544e1f205261">B树</a>，有一个degree值，当前节点数满了就取中间元素向上溢出，从下往上。具体看视频。<br>B+树，跟b树一样，但是向上溢出要的时候元素要保留，并且生成一个指针，从左指向右。所有数据都会出现在叶节点。<br>hash存储，容易引发hash碰撞，因为经过哈希函数计算后，可能算出来的值一样，这个时候往后面加链表就行。<br>聚集索引和二级索引：聚集索引放id，挂全部信息，二级索引放后面的信息，挂id，如果找一个名字的所有信息，就先在二级索引里找名字，名字下面挂了id，然后回表查询id对应的全部信息。<br>索引设计原则：<br><img src="/2024/02/01/2024-02-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/f6087281c5a7fa7545b50609d43a77e.png" alt="Alt text"><br><img src="/2024/02/01/2024-02-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/fcc119d25e09a62fdbbcab5c6c85928.png" alt="Alt text"><br><img src="/2024/02/01/2024-02-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b8860a078c7042e534249bf5bebf843.png" alt="Alt text"></li>
<li>manacher算法<br>暴力解法：从左往右遍历每个位置，看左右两边是不是相等，然后统计最大回文子串长度，但是会有奇偶情况，所以把每个字符两边都加一个#sharpe，然后再遍历，最后结果除以2即可。<br>manacher解法：<br>回文直径、回文半径：回文的长度、长度&#x2F;2<br>R：从左往右遍历的时候，每个位置回文直径的右边界位置，只增不减，一直更新。<br>C：遍历的时候最右边界位置的那个中心位置。<br><img src="/2024/02/01/2024-02-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/11c58242eab92c311b9712363d7ba61.png" alt="Alt text"><br><img src="/2024/02/01/2024-02-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/8a443712261e3c6a0ec39b4740d5417.png" alt="Alt text"><br><img src="/2024/02/01/2024-02-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/4498ae69f121305bc9fdf580cfc4a73.png" alt="Alt text"><br>这个题核心是，首先把字符串中间两边加上#，然后生成一个数组，数组内容是当前位置的最大回文半径，同时有R和C两个值需要更新，初始值为-1。一共有四种情况，第一种i位置在R范围外面，这时候只能暴力寻找回文半径，然后是在R范围内，首先找到2C-i位置，就是相对于中心点的对称位置i1，这个位置三种情况，第一，i1左回文位置半径在L右边，这时候i的回文半径&#x3D;i1回文半径，第二，i1左回文位置半径在L左边，这时候i半径就是R-i，第三，回文半径跟L重合，这时候i半径需要暴力尝试从R位置开始，R位置内的一定重合。一共四种情况，代码首先看边界条件，空就返回0。然后求出i最少的回文半径先给到当前位置，当R &lt; i的时候，等于1，&gt;i的时候，就等于R-i和carr【i1】这个半径的最小值。然后再对其依次遍历，当i位置+最小半径和-最小半径不越界的时候，如果这两个位置相等，carr【i】+1，否则break，然后更新一下R和C，更新max（整个数组最大回文子串长度），最后返回max-1，因为半径大小-1才是最后的最大回文长度。</li>
<li><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">最长回文子串（lc5）</a><br><img src="/2024/02/01/2024-02-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e5db18d926613e14c3a024269cf2495.png" alt="Alt text"><br>这个题就是用manacher算法写，生成数组可以用“#”+’#’.join(s)+’#’,用列表也可以，最后记得join，这个题要想清楚最后生成字符串时候的开始位置和结尾位置。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.02_学习日记</title>
    <url>/2024/02/02/2024-02-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：家<br>学习时长：4h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>滑动窗口（lc239困难）<br><img src="/2024/02/02/2024-02-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/6c76fe7712ad0b68d628d10ee7e3e8f.png" alt="Alt text"><br><img src="/2024/02/02/2024-02-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/6cf1e1516ba18a4319b553e7aea6d8e.png" alt="Alt text"><br>这个题是滑动窗口问题，如何用On的复杂度返回窗口的最大值最小值，这里用最大值举例。首先生成一个双端队列，双端队列左大右小，每进一个数，跟最右边的数比，如果小，就放右边，如果大，那队列弹出末尾元素，然后继续比较，然后需要删除过期元素以及返回最大值给数组，最后返回res数组即可，双端队列维护的这个区间就是最左边的数是最大值，L往右动一次那么最大值更新一次。最小值的话就是队列从小到大排列。<a href="https://leetcode.cn/problems/sliding-window-maximum/description/">记得看一下python版本。</a></li>
<li>各种数据结构python如何引用<br><a href="https://www.jianshu.com/p/9b94651534c3">引用链接</a></li>
<li>最小覆盖子串（lc76）<br><img src="/2024/02/02/2024-02-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/8b75d7db9d3c44c9567214d85b36c4d.png" alt="Alt text"><br>这个题就是用一个字典记录窗口内还需要多少个target的字符数量，分三步，第一步从0开始往右走，直到cnt&#x3D;0位置，窗口左边界往右动，动到need【c】&#x3D;0的时候停止，遇到t的元素，然后更新最小值最大值，第三步就是i往下动，need【c】+1，cnt+1，然后右边界继续往右动，最后返回i到j的索引切片，如果j一直没更新还是最大值，那就返回空，没有更新。</li>
<li>单调栈<br>单调栈就是一个栈结构，下面大上面小，遍历一个数组，可以把数组左右边离你最近的更大的数字生成。具体就是如果当前位置比栈顶小就进栈，大的话就弹出栈顶元素，此时栈顶元素下面的位置就是左边最近的，当前位置是右边最近的，然后继续对比，如果小的话就进栈。但是遇到重复值的时候要把下标重叠起来，变成一个集合。</li>
<li>接雨水（lc42）<br><img src="/2024/02/02/2024-02-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/eb42ff632c07c87ab49cf7874a6af5a.png" alt="Alt text"><br>这个题就是用单调栈，当前如果大于单调栈顶，栈顶弹出后左边的值是left，当前值是right，然后左右最小值-栈顶元素高度就是雨水高度，right-left-1就是雨水长度，累加乘起来就行。while中间加了等号，可以排除掉重复元素。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.03_学习日记</title>
    <url>/2024/02/03/2024-02-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：阴<br>学习地点：家<br>学习时长：4h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>SQL优化<br><img src="/2024/02/03/2024-02-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/76f1db048bc01a918e4ccd50580dead.png" alt="alt text"><br>到时候再看看</li>
<li>二叉树的直径<br><img src="/2024/02/03/2024-02-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e339200c7f0eb0befeb538e78f5e4be.png" alt="alt text"><br>这种题要从左右两边要信息，所以用一个init函数初始化我们需要的结果，然后dfs返回我们需要的信息，比如高度，然后ans就在dfs里更新生成，最后主函数返回ans就行。</li>
<li>树形dp<br><img src="/2024/02/03/2024-02-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c7dfe84fdff6ea4134a8c2f59032b04.png" alt="alt text"><br>遇到这种题就是想好从左右两边要什么信息，还有头节点参不参与，如果头节点参与，那么返回子节点不参与的最大快乐值相加，如果头节点不参与，那就返回子节点参与或者不参与的最大快乐值，然后相加，最后更新最大值。</li>
<li>morris遍历<br><img src="/2024/02/03/2024-02-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/a21835f68d8104417616b2008b5b26d.png" alt="alt text"><br><img src="/2024/02/03/2024-02-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/027df02d70226ae2898cc9f8cd06fcb.png" alt="alt text"><br><img src="/2024/02/03/2024-02-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/f35bcb4bae2f3bc01a6ee180dafcddd.png" alt="alt text"><br>先序遍历：如果只出现一次，直接打印，如果出现两次，第一次的时候打印。<br><img src="/2024/02/03/2024-02-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c95dab6c2ab8fb2acf6b5d0ead52198.png" alt="alt text"><br>中序遍历：如果只出现一次，直接打印，如果出现两次，第二次的时候打印，所以直接在没有左树的情况下打印即可。<br><img src="/2024/02/03/2024-02-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/bd0ea3cb8e72e0136d444f37138cb2f.png" alt="alt text"><br><img src="/2024/02/03/2024-02-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/d745f187c42c4d17c234215401f8a94.png" alt="alt text"><br>后序遍历：如果出现两次，第二次来到自己的时候逆序打印所有右边界，最后再逆序打印整个二叉树的右边界。逆序操作就是反转单链表。</li>
<li>验证搜索二叉树（lc98）<br><img src="/2024/02/03/2024-02-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/94e7a950f82d3aaaa714af00ce98577.png" alt="alt text"><br>就是中序遍历的情况下，看当前值小于等于下一个值，那就是搜索二叉树，用morris遍历的方法做很好，熟悉morris遍历的代码。</li>
<li>0到2的32次方-1这么多数，找到哪个数不存在，用有限变量<br>二分法，左边如果没满，就去左边继续二分找，肯定能找到一个区间没有数。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.04_学习日记</title>
    <url>/2024/02/04/2024-02-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：小雪<br>学习地点：家<br>学习时长：8h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>mysql视图、存储过程、存储函数、触发器<br><img src="/2024/02/04/2024-02-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/04fa4ef00d4a18f2a3410a82f9dd1eb.png" alt="alt text"></li>
<li>大数据题目<br><img src="/2024/02/04/2024-02-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/ce422ef9e8a4811dcf80e8a665e3e8e.png" alt="alt text"><br><img src="/2024/02/04/2024-02-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b22c97aacbb63c1295495d25565dd89.png" alt="alt text"><br>怎么找到top100，先分成局部几部分数据，然后用哈希表记录每一部分的词频，然后用堆结构把词频排序，然后用一个新的堆结构放入各个小部分的堆顶并排序，然后弹出堆顶，就是全局最大值，并且看该堆顶之前是哪个堆的顶，然后把这个子堆的堆顶元素弹出放入新堆顶，然后循环弹出一百个数就是top100。<br><img src="/2024/02/04/2024-02-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/f8ed2e994dc1d74999414fe9cd92f2c.png" alt="alt text"><br>解决办法：<br>哈希函数分流：看1GB内存的哈希表能放多少数据，然后就能知道分多少小文件了，一个数通过哈希函数最后取模就知道放到哪个小文件里去，最后用哈希表对每个小文件进行词频统计，然后汇总就是答案。<br>位图方法：用两个位来判断一个数字出现的次数，如果是00，就没出现，01，出现一次，10，出现两次，11，出现很多次。2的32次方个数占用2的32次方*2&#x2F;8个字节。<br>找中位数的办法：<br><img src="/2024/02/04/2024-02-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/101686b0f88e32be4e7fc1878a062a5.png" alt="alt text"><br>腾讯面试题：怎么把一堆10G内存的没有排序过的数字通过任意内存比如1M内存然后生成一个排序过的文件？<br>第一种方法通过分段统计思想，计算1M能记录多少int数字，然后相除就可以知道分成多少个区间，然后对所有数字以及出现的次数处在第一个区间的放进小根堆，按照数值排序，然后根据词频放进生成的文件即可。<br>第二种方法是通过大根堆，大根堆放的数据量也是根据内存大小定，大根堆放数字以及词频，如果大根堆放满了，那就比较接下来的值和堆顶的大小，如果大，就跳过，如果小，堆顶弹出并且把这个值放进堆当中，遍历完以后让Y&#x3D;3，第二次遍历，只把Y&gt;3的数放进大根堆里来。<br>比较两个值的大小：<br><img src="/2024/02/04/2024-02-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/a625f509e4c6cee6914629ef74c601b.png" alt="alt text"><br><img src="/2024/02/04/2024-02-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9d097e2985c72ee7196e79cf9d5da97.png" alt="alt text"><br>怎么判断一个数是不是2或者4的幂？(lc342)<br>判断2的幂可以用x&amp;(x-1) &#x3D;&#x3D; 0来判断。<br>判断4的幂可以先判断是不是2的幂，然后用x&amp;(32位010101010101)来判断，如果!&#x3D;0，就是4的幂。二进制用0b的前缀表示。<br><img src="/2024/02/04/2024-02-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/53634a08dfc47a821fe9c65e007918c.png" alt="alt text"><br>+：两个数异或^就是不进位相加，两个数&amp;然后&lt;&lt;1就是进位信息，然后重复这样，直到两个数&amp;为0了，此时异或的值就是最后的答案。<br>-：a加上b的相反数，相反数就是b取反+1<br><em>：乘法二进制也跟十进制的乘法一样，a</em>b等于如果b末尾是1，那就res+a，然后a左移一位，b右移一位，如果末尾是0，跳过res+a部分，然后重复，直到b&#x3D;0弹出，返回res。<br>&#x2F;：除法就是看被除数左移多少位能被除数减掉，从31位开始往下数，如果到第三位，被除数大于除数，那么res &#x3D; 1左移3位，然后相减之后继续从第二位开始左移相减，如果左移后被除数大于除数，那么res+1左移2位，最后知道左移数为0跳出循环，返回res。<br><img src="/2024/02/04/2024-02-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b87de51dbf33e38b8c33853de7565c7.png" alt="alt text"><br><img src="/2024/02/04/2024-02-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/228a64b49c916b8d46c362527b3a0b1.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.05_学习日记</title>
    <url>/2024/02/05/2024-02-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：大雪<br>学习地点：家<br>学习时长：8h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>mysql 锁<br><img src="/2024/02/05/2024-02-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/30f971dbf73c808ad6444e9e23b6683.png" alt="alt text"></li>
<li>机器学习部分<br><a href="https://cuijiahua.com/blog/2017/11/ml_1_knn.html">KNN算法</a>：看这个点跟其他点的距离，找最近的k个点，然后按照概率进行分类。<br><img src="/2024/02/05/2024-02-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/0b7987b3303aa8be62b4dd19031e82a.png" alt="alt text"><br>KNN算法不具有显性的学习过程。（machine learing文件夹中有KNN代码）<br><img src="/2024/02/05/2024-02-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/34485c9b1920e6f61e0f4de00638804.png" alt="alt text"><br>算法还需要计算错误率，错误率在可接受范围内才能用KNN算法。<br>生成图的时候记得把FontProperties函数改成全小写，函数名不改，就改下面的FontProperties&#x3D;font部分。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.06_学习日记</title>
    <url>/2024/02/06/2024-02-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：大雪<br>学习地点：家<br>学习时长：8h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>KNN算法的优缺点<br><img src="/2024/02/06/2024-02-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b7cf4161cb880a37b4ad5e288fa587d.png" alt="alt text"></li>
<li><a href="https://cuijiahua.com/blog/2017/11/ml_2_decision_tree_1.html">决策树</a><br><img src="/2024/02/06/2024-02-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/a4b9c738341fb8e512cf57a02bfb49c.png" alt="alt text"><br>Sklearn之使用决策树预测隐形眼睛类型<br>glassdecisiontree这个文件的代码，先处理文件的特征、类别，放入字典，生成pandas表，然后序列化，用graphviz可视化决策树，然后就可以做测试了。<br>决策树的优缺点<br><img src="/2024/02/06/2024-02-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9cdbe01d0f3010f0b976448622b501d.png" alt="alt text"></li>
<li><a href="https://cuijiahua.com/blog/2017/11/ml_4_bayes_1.html">朴素贝叶斯</a><br><img src="/2024/02/06/2024-02-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3711595727687b25984be33e57d6be0.png" alt="alt text"><br>朴素贝叶斯之过滤垃圾邮件<br><img src="/2024/02/06/2024-02-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/4416aa2a220c02c6789aa15c894d679.png" alt="alt text"></li>
<li><a href="https://cuijiahua.com/blog/2017/11/ml_7_logistic_2.html">logistic回归</a><br><img src="/2024/02/06/2024-02-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b74817a4865f138fb677d594d7077ec.png" alt="alt text"><br>从疝气病症状预测病马的死亡率<br><img src="/2024/02/06/2024-02-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/8bb7ae44d056996891b2bde56e5f7b2.png" alt="alt text"><br>当数据集较小时，我们使用梯度上升算法<br>当数据集较大时，我们使用改进的随机梯度上升算法<br>在Sklearn中，我们就可以根据数据情况选择优化算法，比如数据较小的时候，我们使用liblinear，数据较大时，我们使用sag和saga。<br>这个方法还要更改solver和max_iter值，才能达到收敛。<br><img src="/2024/02/06/2024-02-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2a0cfe0dda1b090a2736fc53ac21498.png" alt="alt text"></li>
<li><a href="https://cuijiahua.com/blog/2017/11/ml_9_svm_2.html">SVM（支持向量机）</a><br><img src="/2024/02/06/2024-02-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/d2bcbe510dbd01dce39a2f183abdda5.png" alt="alt text"><br>可以增加维度来分低纬度不可分的数据，用核函数。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.07_学习日记</title>
    <url>/2024/02/07/2024-02-07-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：雾<br>学习地点：家<br>学习时长：5h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>bagging\boosting（集成方法）<br>bagging是从原始样本集抽取不同的样本集，然后每个样本集得到不同的模型。分类问题就采用投票的方式得到最后的结果，回归问题就用均值得到结果。这里面所有模型的重要性相同。<br>boosting跟bagging相似，但是不同的样本集权重不同。<br>区别：<br><img src="/2024/02/07/2024-02-07-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/23474e49261a55b9292bb9dbc9141a6.png" alt="alt text"></li>
<li><a href="https://cuijiahua.com/blog/2017/11/ml_10_adaboost.html">Adaboost</a><br><img src="/2024/02/07/2024-02-07-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/be368aa8d8f1dbb30660a5832db5991.png" alt="alt text"><br>代码很简单</li>
<li><a href="https://cuijiahua.com/blog/2017/11/ml_11_regression_1.html">回归</a><br>LWLR局部加权线性回归，过小的核可能导致过拟合现象，即训练集表现良好，测试集表现就渣渣了。</li>
<li><a href="https://cuijiahua.com/blog/2017/12/ml_12_regression_2.html">岭回归</a><br>缩减方法（逐步线性回归或岭回归），就是将一些系数缩减成很小的值或者直接缩减为0。这样做，就增大了模型的偏差（减少了一些特征的权重），通过把一些特征的回归系数缩减到0，同时也就减少了模型的复杂度。消除了多余的特征之后，模型更容易理解，同时也降低了预测误差。但是当缩减过于严厉的时候，就会出现过拟合的现象，即用训练集预测结果很好，用测试集预测就糟糕很多。<br>预测乐高玩具套件的价格：<br>可以用岭回归交叉验证，可以看到哪些特征是重要的，然后预测的时候可以就用这些特征预测，回归与分类的不同点在于，前者预测连续类型变量，而后者预测离散类型变量。</li>
<li>动态规划<br>建表，找表依赖关系，找可以填的base值，然后依次填表。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
</search>
