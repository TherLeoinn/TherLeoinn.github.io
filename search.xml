<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023.12.30_学习日记</title>
    <url>/2023/12/30/2023.12.30_%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：阴<br>学习地点：宿舍<br>学习时长：4h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>图的算法<ol>
<li>图的遍历（BFS, DFS）</li>
<li>最小路径（Dijkstra）</li>
<li>最小生成树（Prim, K）</li>
</ol>
</li>
<li>神策面试题和美团面试题<ol>
<li><img src="/2023/12/30/2023.12.30_%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/a0c3a998fd4e6182648b3c4c61ba7d7.png" alt="Alt text"><br><em>这个题很简单，一个是下标一个是值，找到数学算法之后直接遍历一次就行，遍历的时候记录res。</em></li>
<li><img src="/2023/12/30/2023.12.30_%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3ba9852c15f8184e6cd1dd43d1f241b.png" alt="Alt text"><br><em>俩数组把值变得一样，这个原题比较简单，递归+动态规划就行，leetcode72编辑距离难一点，是字符串不是数组，边界问题要细心考虑。</em></li>
</ol>
</li>
</ol>
<h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>这几个面试题不太难，看一遍基本就会了，动态规划忘的有点多，今天做了一个热热手，碰到越界问题找错太麻烦了，还好有万能的GPT省了我很多时间。今天起的太晚了，明天早起，over。</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>图的遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>2023.12.31_学习日记</title>
    <url>/2023/12/31/2023-12-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：阴（重度污染）<br>学习地点：宿舍<br>学习时长：5h（2023的最后一天也要进步！）</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>美团面试题（leetcode1162）<br><img src="/2023/12/31/2023-12-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/a481855af7730251c3d3aaa276bb352.png" alt="Alt text"><br><em>这个题用广度优先搜索，找所有岛的周围海域，用到deque，每遍历一遍step+1。</em></li>
<li>微软面试题（leetcode2384）<br><img src="/2023/12/31/2023-12-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/1cda8574d743b7f29392f9f1106b47f.png" alt="Alt text"><br><em>这个题就是用Counter函数统计数字的个数，然后用切片方法把这个词生成出来就行,还有lstrip和rstrip函数，很好用！</em></li>
<li>微软面试题（leetcode2477）<br><img src="/2023/12/31/2023-12-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/7855d0df445fa39a7ec024f131e5c9a.png" alt="Alt text"><br><em>这个题用了图的dfs算法，题不难，但是对dfs的递归要彻底弄透</em></li>
<li>网易面试题<br><img src="/2023/12/31/2023-12-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/a9fdf6d39c625bac7b5109a6c9557f6.png" alt="Alt text"><br><em>这个题可以用动态规划，关键是找到暴力递归的解法，这个递归是范围上的尝试模型，修改i位置的值，可以改为red三个值，同时考虑前面两个值的情况。</em></li>
<li>弗吉尼亚理工大学算法考试题<br><img src="/2023/12/31/2023-12-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/44fb1a48dd31fd0a9b25ada7904830f.png" alt="Alt text"><br><em>暴力递归到动态规划，index选还是不选，分情况讨论，剩余值会变动，最后转化成三维数组动态规划。</em></li>
<li>弗吉尼亚理工大学算法考试题<br><img src="/2023/12/31/2023-12-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e69717d9b1a589d7221cc679155734a.png" alt="Alt text"><br><em>跟上面的题一样，但是可以重复用绳子，所以index递归的时候可以不加1</em></li>
<li>吉尼亚理工大学算法考试题<br><img src="/2023/12/31/2023-12-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9fecc57982124c6632fc6b78d3f199c.png" alt="Alt text"><br><em>一样是选和不选的情况，但是函数变量要用的是上一个选的index，选的时候要判断preindex的结尾值是不是要等于index的初始值，最后动态规划，还可以有更优解法，用hashmap记录（x，y）中y开头的区间，如果有，hashmap+1，从右往左遍历就可以实现。</em></li>
</ol>
<h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>今天coding花了太多时间，题没有做几个，效率不够高，有待加强，明天是2024年了，希望女朋友大人考研成功，也希望我们能好好走下去。</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.01_学习日记</title>
    <url>/2024/01/01/2024-01-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：宿舍<br>学习时长：2h（2024的第一天也在学习！）</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>今天没有学习算法，但是把hexo的动态背景、加载效果等等都设置了一下，吐槽一下，bug太多了，打赏界面图标部署以后一直加载不出来，心烦的嘞。</p>
<h2 id="酒精日记"><a href="#酒精日记" class="headerlink" title="酒精日记"></a>酒精日记</h2><p>下午健身，晚上和家人一起吃饭，喝了红酒、啤酒、白酒。。。又喝杂了。。和哥哥嫂子聊到了女朋友，嘿嘿，很是开心！！坐地铁回到寝室又饿了，现在准备加餐！<br>over</p>
]]></content>
      <categories>
        <category>酒精日记</category>
      </categories>
      <tags>
        <tag>酒精日记</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-01-02-学习日记</title>
    <url>/2024/01/02/2024-01-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：宿舍<br>学习时长：3h（醒酒日。。）</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>字节面试题（leetcode1574变式）<br><img src="/2024/01/02/2024-01-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/018869481261887ca2064d472a264b1.png" alt="Alt text"><br><em>这个题用二分搜索+双指针解，培养画图的能力，有些题把图画出来好解很多，别光靠脑子画图，左右指针分别代表前缀后缀的反向后前指针，然后找最小值即可。</em></li>
<li>京东面试题<br><img src="/2024/01/02/2024-01-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/eebc6b774477d6fb4470a56d5cf86a5.png" alt="Alt text"><br><em>这个题值得反复看，用一个区间套住target并且讨论多种情况下左右边界是否做变化，最核心的思想是这个题最多的操作数是2，如果相同返回0，如果两个小于n的值返回2，然后讨论1的情况，还要用cnt函数数字出现的次数，比较考验思路请不清晰。</em></li>
</ol>
<h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>今天精神状态不佳，不找理由了，明天多做几个题把今天的补上。</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.04_学习日记</title>
    <url>/2024/01/04/2024-01-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：宿舍<br>学习时长：6h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>小红书面试题<br><img src="/2024/01/04/2024-01-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/f806571b470cf54c73391b0a4db1f07.png" alt="Alt text"><br><em>这个题先排除掉奇数个的情况以及红蓝数量大于一半的情况。然后将数组按照先无色、红色、蓝色分别排序并且把无色按照cost排序，cost指红色-蓝色cost最大的情况，统计每个颜色的数量，先把所有的无色都变成红色，然后算出有多少个要变成蓝色，然后把无色的前n个变化即可。<a href="https://github.com/algorithmzuo/publicclass2020/blob/master/src/class059/Code01_MagicStone.java">题解链接</a></em></li>
<li>网易面试题（lc135）<br><img src="/2024/01/04/2024-01-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/24d68ed6e3003491d46d5cae0484312.png" alt="Alt text"><br><em>就是从左往右遍历用一个数组记录每个位置连续比左边大的次数，再从后往前遍历一次记录比右边大的次数，最后取最大值即可，比较简单。如果是环形的，那就取局部最小值为1，然后左右遍历，遍历的时候用一个数组即可，左右得分别是局部最小值夹着。</em></li>
<li>腾讯面试题（lc881）<br><img src="/2024/01/04/2024-01-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/86dbeecd667add524a2c17cbeb6e153.png" alt="Alt text"><br><em>直接贪心，先排序，左右两个指针，左右两个值相加小于目标值的时候，左边右移，右边左移count+1，否则，count+1同时右边左移但左边不右移，因为右边的大的数没有小的数可以匹配了，左边还可以继续用，但是右边必须让count更新。</em></li>
<li>京东面试题（lclcr010）<br><img src="/2024/01/04/2024-01-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e9ffc17c308c7a593afcffc4266286e.png" alt="Alt text"><br><em>前缀和加哈希，这个题就是遍历一次，以每个数结尾的和-k值有多少个，并且同时记录前缀和，把前缀和记录到哈希表里，最后遍历相加每一个前缀和的个数即可。这个题很经典，多看</em></li>
</ol>
<h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>今天几个面试题很经典，每天保持做5个题左右，坚持到1月底能做150个题了，加油！希望2月份能拿到好的实习机会。</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.03_学习日记</title>
    <url>/2024/01/03/2024-01-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：宿舍<br>学习时长：8h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>公司面试题<br><img src="/2024/01/03/2024-01-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/48f6153b8cc1ffb4dc9058f9a58d8da.png" alt="Alt text"><br><em>变量复用这个技巧很重要，如果需要之前的一个信息，直接用变量复用，每次遍历该数据即可，整体思路是首先生成rightup和rightdown函数判断右边是否波浪滚动，从右往左遍历生成每个位置右边是否是上下波浪，然后从左往右遍历，如果删掉该位置，那么要符合前后的一些关系才行，这里用到变量复用。记得单独算删掉最后一个位置的情况。</em></li>
<li>火柴拼正方形（leetcode473）<br><img src="/2024/01/03/2024-01-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/5d7c5931282568abefba41a94801321.png" alt="Alt text"><br><em>这个题下次再刷一次，好经典的题，总体来说是判断一堆数字能否拼凑成四个大小一样的值，暴力方法是判断当前位置选择后是否超出边长，如果不超过，那就递归，如果相等，edges就-1，当前长度归0，继续递归。最核心的是status这个值，表示了0-15根火柴是否可选，用二进制表达，选了那就|（1&lt;&lt;i），判断是否全选就是（1&lt;&lt;lenth）-1，然后动态规划，只用记忆化status即可，初始化为0，如果可拼凑就是1，不行就是-1。</em></li>
<li>好子集的个数（leetcode1994，困难题）<br><img src="/2024/01/03/2024-01-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/7648877c92613d9e3efcecbfd82e9bd.png" alt="Alt text"><br><img src="/2024/01/03/2024-01-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3dee3a4807b007200ef3402ff19ddf1.png" alt="Alt text"><br><em>炫耀一下，打败100%用户！！！这个题很难，把0-30的所有数是否有质数表达成0001001010的形式，每个0或1表示当前质数是否是其因数，所以每个数字依次可以用status来表示，对于每个数组，遍历每个数字的次数，集合里每个数的状态形式分别&amp;10位质数的状态形式，如果&amp;后的值为0，说明可以放进去当子集，并且可以放进去这个数字的次数个，而且10位质数状态可能不止一个，是status[number]个，最后把所有的状态相加，不要忽略掉1的情况，每一个1都要×2。</em></li>
</ol>
<h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>这几个题做了起码6h，太难了，今天学到了状态压缩，还有二进制的位运算。。要想好每个题递归的变量，哪些变量是必不可少的，明天继续加油。</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.05_学习日记</title>
    <url>/2024/01/05/2024-01-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：宿舍<br>学习时长：6h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>猿辅导面试题<br><img src="/2024/01/05/2024-01-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c7d4663df3d308218d7c6bbcebad4d5.png" alt="Alt text"><br><em>这个题核心是想到，如果有a个1，那必定有a个0是右括号，剩下n-2a&#x2F;2对括号可以随意更改颜色，k种颜色就是k的这么多次方，然后如果有s种左右括号的确定值存在，就乘以s，最后写递归，i表示位置，j表示左括号比右括号多的个数，有一个剪枝就是当n-i&lt;j时，就得跳出。最后是动态规划。</em></li>
<li>米哈游面试题<br><img src="/2024/01/05/2024-01-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/8294946bf3229d1fe5df4028c2b49a1.png" alt="Alt text"><br><em>这个题首先是要会图的构建，【0：【next】】，list里套list即可，然后想到dfs，题目的要求可以转化为，任意一个head的多条边，颜色至少两种，所以准备两种着色方式，123，132，head为1，另外两条边按照这两条边来着色，用index%3可以重复123这个过程，并且有个筛选过程就是对没着色的才着色，着色的是父节点。然后一直dfs，最后对其他边分别着色132即可，最后返回colors数组。还有如果没找到有多个子节点的head的话，就返回1，1就行。</em></li>
<li>逆波兰式（lc150）<br><img src="/2024/01/05/2024-01-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/bcd35c15e39d8142dac539760e3619e.png" alt="Alt text"><br><em>逆波兰式表达成算术表达式，就是用到两个栈，第一个栈放值，第二个栈放值得类型，分为数字，加减，乘除，如果是数字，直接加入栈，如果是加减，返回一个a + b，并且第二个栈入加减，如果是乘除，第二个栈入乘除，然后判断左边和右边的数得类型，如果是加减那就要加括号，再返回。</em></li>
<li>lc2360（想了很久很久）<br><img src="/2024/01/05/2024-01-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/37d6bd87c5e867b8ea56376dc94b2b3.png" alt="Alt text"><br><em>这个题就是用一个数组记录访问该点的时间，如果该点访问过，还要判断访问时间和当前时间的大小，区分是老环还是新环，这个题做了两三个小时，又想多做两个题，又饿，搞得后面很紧张，其实题目本身不难，但是太急了，什么都想不好。。。</em></li>
<li>打怪物<br><img src="/2024/01/05/2024-01-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/bfced3fc9aca69b23ba938f7d3e897f.png" alt="Alt text"><br><em>看血量，很大，所以放弃递归，然后想到二分法能不能做，看单调性。先找到中间值看能不能死，不可能死就在右边，能死就在左边，判断能不能死就看每次的攻击伤害谁更高。任何窗口和二分问题都要看单调性。</em></li>
<li>最大栈<br><img src="/2024/01/05/2024-01-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/0c093874f1d1776df76d31285fa02c9.png" alt="Alt text"><br><em>用加强堆来实现栈内的元素排序，保存的是节点的内存地址，栈内放的元素是双向链表。这样就能实现最大栈。</em></li>
</ol>
<h1 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h1><p>今天刷题数量达标，最大栈这个问题还要看看，加强堆的结构后面再去了解一下，加油！</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>栈</tag>
        <tag>加强堆</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.06_学习日记</title>
    <url>/2024/01/06/2024-01-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：宿舍<br>学习时长：3h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>航班问题（lc1109）<br><img src="/2024/01/06/2024-01-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/69a278f5f666b0883c0e707171af482.png" alt="Alt text"><br><em>数组上累加数字并且数字相同的话，想到差分法，在i加上该数字，j+1减该数字，最后遍历一遍，后一个数&#x3D;前一个数加当前数字即可。学到新方法，差分法，类似于前缀和。</em></li>
<li>最小轮调（lc798）<br><img src="/2024/01/06/2024-01-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/53fa795034930c01a39093ac7473838.png" alt="Alt text"><br><em>看到这个题，想到用cnt记录移动0-k个单位的得分，因为是连续的一样的数字，所以想到用差分数组，然后分情况讨论值是否大于当前值的不同情况，最后遍历数组即可。</em></li>
<li>小红书笔试题<br><img src="/2024/01/06/2024-01-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/65938a7de1604b611556afae52a63fd.png" alt="Alt text"><br><em>这个题就是把想到0的个数-1的个数最多的时候，就翻转这个数组，这个时候把0变成1，1变成-1，就能找到0-1最多的区间了。</em></li>
</ol>
<h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>今天学到了差分法，第一个数字+1，最后一个数字下一位-1。还有把数字换成1，-1，求和就可以得到两个对象个数相减的个数。明天继续学习</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>差分法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.07_学习日记</title>
    <url>/2024/01/07/2024-01-07-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：宿舍<br>学习时长：2h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>小红书笔试题<br><img src="/2024/01/07/2024-01-07-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2e0f4af4161e72112ca37eec5628c06.png" alt="Alt text"><br><em>找一个数组的任意范围内最大值，用NlogN实现，想到用RMQ方法实现，这个方法是指第i个数往后的2的j次方个数的最大值，跟动态规划一样，先把第一行填完，i行j列，第一行就是每个值填进去就行，然后下面每一行都依赖前一行的值，因为i行j列依赖i行j-1列和后面那一堆的最大值然后取最大值。填完以后想找某个区间最大值就是找这个区间有多少个数，然后2的多少次方能到这个数，最后前后两个区间取最大值，O1的操作。</em></li>
<li>腾讯音乐面试题<br><img src="/2024/01/07/2024-01-07-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9af13223e2ff237dc3fcaff3096aa62.png" alt="Alt text"><br><em>两种方法，1：其实就是统计连续0的方法然后相乘，每个连续零可以搞个动态规划表出来，长度表示最大值，宽度表示数组长度，dp【i，j】就是4个连续0填3个格子的大小，最后返回几个dp值得乘积。2：第二个方法是用数学方法，n个数字里取m个单调不减数列，就是C（n+m，m），然后找到连续0得个数，最后乘起来。</em></li>
</ol>
<h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>今天学习时间比较短，明天要出门旅游，寒假开始喽，每天也要坚持刷题。</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.08_学习日记</title>
    <url>/2024/01/08/2024-01-08-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：多云<br>学习地点：寝室<br>学习时长：3h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>这周要旅游，下周统一更新具体学习内容。</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.09_学习日记</title>
    <url>/2024/01/09/2024-01-09-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：无<br>学习时长：0h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>今天没有学习，下周统一更新学习内容。</p>
]]></content>
      <tags>
        <tag>学习日记</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.16_学习日记</title>
    <url>/2024/01/16/2024-01-16-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：家<br>学习时长：3h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>今天在火车上看了视频，把堆结构简单复习了一下，明天开始正式学习！</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.17_学习日记</title>
    <url>/2024/01/17/2024-01-17-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：小雨<br>学习地点：家<br>学习时长：7h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>配置新的hexo博客<br>昨天晚上和今天一直在重新配置hexo，之前的博客突然不能上传了，改了很久才弄好，错误来源主要是环境配置的问题，<a href="https://blog.csdn.net/good_good_xiu/article/details/118567249">解决链接</a>在这里。<br>还有hexo图片加载不出来的情况，安装插件，重新配置即可。</li>
<li>算法题<br><img src="/2024/01/17/2024-01-17-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/75d1120c9956b829a75dedbf784c353.png" alt="Alt text"><br><em>子序列：不连续；子串：连续。这个题就是从左到右的尝试模型，四种基本模型之一，n个数选2个数加起来为偶数，dp[n][2],这个值取决于当前数到底选不选，不选的话，就依赖dp[n-1][2],选的话，就要看当前数是奇数还是偶数，奇数的话，那就依赖另一个dp表，dp~[n-1][1],如果是偶数，就依赖dp[n-1][1]。两个dp表都要填数，最后选和不选的情况分别相加即可。</em></li>
<li>微众算法题<br><img src="/2024/01/17/2024-01-17-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/d78a9cdddbcb6ce80c1c4465b529792.png" alt="Alt text"><br><em>这个题思路很难，核心思路是abc取余等于0的个数等于a00取余+ab0取余等于0的个数相加再加上abc是否取余等于0，需要两个表，cur和next表，next用来迁移，之后再看一次这个题解。<a href="https://www.bilibili.com/video/BV1DT411s7hp?p=31&vd_source=d980f353cbdc64ff6011544e1f205261">链接点这里</a></em></li>
<li>lc1345（困难题）<br><img src="/2024/01/17/2024-01-17-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/f263b8dab0a331a376f26ed29a2821f.png" alt="Alt text"><br><em>这个题用到宽度优先遍历bfs。用列表表示队列的方法需要再巩固一下，关键思路是用defaultdict记录每个数字出现的位置，用另一个数组表示是否访问该位置，最后bfs遍历整个数组，左边右边以及重复的数字如果不越界或者没有访问过就放到queue里，最后对cur进行pop操作，这是一个大的优化，优化以后就不会出现重复的遍历了。queue【0】要先放数字，再往下遍历。每个细节都要注意。</em></li>
<li>微众人工智能面试题<br><img src="/2024/01/17/2024-01-17-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c1380476e9dbb17407b789eefad95f6.png" alt="Alt text"><br><em>首先，判断一个数是否为偶数用a&amp;1 &#x3D;&#x3D; 0就行，然后这个题正常方法是用递归，四个参数，rest，who’s turn, jia数量， yi数量，如果rest为0，返回jia是否为偶数，如果rest不为0，继续递归，如果现在是jia回合，那么for循环3次，注意这里的循环次数要看rest数量的最小值，循环后就是rest-i，1，jia+i，yi的递归如果equals（jia），那么返回jia，第二种情况也类似。最后的优化是打表找规律，看看有没有规律，有的话，直接返回规律就行。</em></li>
<li>做了明天汇报的ppt</li>
</ol>
<h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>今天大部分时间在搞hexo，明天上午和晚上多花时间在算法上，再接再厉！</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>hexo配置问题</tag>
        <tag>BFS</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.18_学习日记</title>
    <url>/2024/01/18/2024-01-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：小雨<br>学习地点：家<br>学习时长：6h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>开组会<br>今天在组会上汇报了本学期工作，以及对2024春季学期的展望。</li>
<li>面试题<br><img src="/2024/01/18/2024-01-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2526e4ae6612cd6baec542ce033ac4c.png" alt="Alt text"><br><img src="/2024/01/18/2024-01-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/af916597493ea147b8a82b0c2220f61.png" alt="Alt text"><br><em>这个题有两问，第一问是有序，第二问无序。有序情况下，两种方法，哈希表和二分法，哈希表额外空间复杂度On，二分法O1，二分法就是先到中点，看这个值是不是等于n&#x2F;2，如果是的话，看下一位如果是n&#x2F;2+1，那么二分到后面半段，然后重复即可。第二问无序情况，就是追及问题，用快慢指针，快指针两步，慢指针一步，最后相遇以后快指针回到最初，然后快慢指针各走一步，最后相遇的点就是重复值。</em></li>
<li>蓝桥杯练习题<br><img src="/2024/01/18/2024-01-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/4b95e96607337e4c32ec60ddf6d4e2c.png" alt="Alt text"><br><em>这个题很难，是打表找规律的题，1到100的因子平方和再相加，其实是把1到100所有因子个数求出来，然后平方相加，首先用两个for循环找出有1-100有多少个因子，用一个数组表示出来，然后找规律，1到根号n的因子i可以找到规律，就是n&#x2F;i这么多次，所以先把这些平方和相加到ans上，然后找后面的规律，后面的规律就是如果是j这么多个，有一个范围的因子都能满足，就是用二分法，找到这个范围，二分法找一个边界即可，用一个函数，然后下边界就是参数+1的上边界-1，找这个边界用到二分法，k乘以中点如果大于n，那么肯定左边界在中点左边，然后重复就能找到边界，然后把每个因子对应的范围累加和到ans上，一个for循环就出来了，a方+b方+c方+d方等于1到d的平方和-1到a-1的平方和，1到n的平方和等于n乘以n-1乘以2n-1&#x2F;6.最后返回ans</em></li>
<li>optiver面试题（还有manacher算法没看）<br><img src="/2024/01/18/2024-01-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/f78342278e61528a7f52d3c7d6a17e9.png" alt="Alt text"><br><em>这个题就是贪心，从第一个找到最后一个，然后要用manacher算法，这个还没听过，等听完再回过来看这个题。<a href="https://www.bilibili.com/video/BV1Ef4y1T7Qi?p=36">manacher算法链接点这里</a></em></li>
<li>字节面试<br><img src="/2024/01/18/2024-01-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/660bf1c5ed5f6671b506725cd828292.png" alt="Alt text"><br><em>这个题看数据量就不能用动态规划，要用到RMQ，RMQ已经忘了，之后再看一下这个题。链接在这里。</em></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>manacher</tag>
        <tag>动态规划</tag>
        <tag>双指针</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.19_学习日记</title>
    <url>/2024/01/19/2024-01-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：小雨<br>学习地点：家<br>学习时长：4h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>网易面试题（lc135进阶）<br><img src="/2024/01/19/2024-01-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/dd0235b4190353ab7c4c87134741706.png" alt="Alt text"><br><em>这个题原版是分发糖果的问题，首先一个小孩分发多少糖果，取决于左边有多少连续比他小的值，也取决于右边有多少连续比他小的值，所以设置两个额外的数组用来放左边和右边两边遍历情况下的当前数值，从1开始，如果右边比左边大，那么加1，如果小或者一样大，继续是1，遍历结束得到左数组，右边的数组也是一样，最后取两个数组的最大值即可。进阶版的就要考虑首尾相连的问题，这个时候就是考虑用局部最小值当作首尾两个值，然后数组按顺序构建新数组解耦掉原数组，然后再分别左右遍历，取最大值即可。</em></li>
<li>小红书笔试题<br><img src="/2024/01/19/2024-01-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b085c2a4b98ae4007068b4c7286f6ea.png" alt="Alt text"><br><em>这个题的思路很简单，就是首先按照红色-蓝色代价排序，然后统计0、红蓝各有多少个，剔除掉奇数、红蓝有大于n&#x2F;2的情况，然后再首先把蓝色需要多少个才能变成一半算出来，红色同样，先全部变成红色，然后数组遍历蓝色次数，把红变蓝需要的代价减掉就行了。<a href="https://github.com/algorithmzuo/publicclass2020/blob/master/src/class059/Code01_MagicStone.java">code在这里</a></em></li>
<li>腾讯笔试题<br><img src="/2024/01/19/2024-01-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/53b4088b7c1d3665b83a71574cad715.png" alt="Alt text"><br><em>这个题是进阶版，低阶版是没有偶数这个条件，低阶版首先是排序，然后左右指针，分别遍历，左指针+右指针如果大于limit，右指针左移，res+1，如果小于等于limit，右指针左移，左指针右移，一个while搞定，最后返回res。进阶版就是分成奇偶两个数组，然后按上述方法统计，最后相加即可。</em></li>
<li>题目<br><img src="/2024/01/19/2024-01-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/4093c6f32f345617de69b4128ab4f6d.png" alt="Alt text"><br><em>子数组是连续的，这个题想到统计以每个位置结尾得时候，有多少个子数组，最后累加。然后想到以i位置结尾的时候，需要找到前缀和为sum-arr【i】的个数，所以前缀和要用一个hashmap统计出来，hashmap里首先要加上一个0：1，因为如果当前数字&#x3D;sum，前缀和如果没有sum-sum这个0值的话，就会生成0，但其实是1，因为子数组就是i位置这一个数形成得数组。所以遍历一次，每次先看前缀和有几个，然后更新当前和到前缀和里，遍历一次累加ans即可。</em></li>
<li>京东笔试题<br><img src="/2024/01/19/2024-01-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3ba337dc2d1c48b847904699ad7b05e.png" alt="Alt text"><br><em>要求每一部分01比例一样，先把整体01比例求出来，分割后的肯定也是这个比例，所以用map记录每个位置的前面所有01比例，如果当前整个是该比例，那么看map里有多少个该比例的个数，如果没有，那就是1，如果有就是1+该map数字，同时如果该位置比例有效，那更新map+1，最后返回res数组。</em></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.20_学习日记</title>
    <url>/2024/01/20/2024-01-20-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：小雨<br>学习地点：家<br>学习时长：6h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>认识复杂度和简单排序 基础知识巩固<ol>
<li>一堆数有两个数出现奇数次，其余都是偶数次，怎么找到两个数？这个时候要用到异或，异或就是相同异或为0，不同异或为1，用一个eor把整个数组都异或，最后会得到a^b，这个值找到其中是1的位数，比如第二位是1，那么a和b第二位必然不同，所以用另一个eor去异或数组中第二位是1的数，最后能得到a或者b，然后用之前的eor异或第二个eor，就能得到另一个值。注意：eor &amp; （~eor + 1）就能取出最右侧的1。</li>
<li>O（N^2）的排序：选择、冒泡、插入。其中插入排序会和数据状况有关系，如果本身有序的时候，那就是O（N）的复杂度，但是排序以最差情况估计，所以还是O（N^2）。</li>
<li>二分法：找局部最小值、找有序数组某个数是否存在、找有序数组的大于某个数的最左侧值等等。</li>
<li>对数器：不依赖线上测试平台也能搞定是否正确。</li>
<li>递归的复杂度（master公式）T(N) &#x3D; aT(N&#x2F;b) + O(N^d)。b：子过程的样本。a：子过程的计算次数。O(N^d)：子结果合并的时间复杂度。满足如上公式的程序都可以根据master公式计算时间复杂度：log(b，a) &gt; d ：时间复杂度为O(N^log(b，a))。log(b，a) &#x3D; d ：时间复杂度为O(N^d * logN)。log(b，a) &lt; d ：时间复杂度为O(N^d)</li>
</ol>
</li>
<li>认识O（N*LogN）排序<ol>
<li>归并排序：方法是左边排序，右边排序，然后merge一下递归。小和问题也可以用归并排序，一个数组，每个位置左边有多少数比当前小，这个可以转化为，右边有多少比当前位置大，然后可以用归并部分找右边有多少比当前大。还有逆序对问题，逆序对就是左边比右边大有多少个对，<a href="https://github.com/algorithmzuo/algorithmbasic2020/blob/master/src/class04/Code03_ReversePair.java">其实也是归并来解决</a></li>
<li>荷兰国旗问题：数组小于等于大于分开，不要求有序。两个区域，一个左一个右，i从左往右，i和左区域边界中间就是等于区域，i位置如果小于5，i和小边界下一个位置交换，小边界往右阔，i往右，如果等于5，i继续往右，如果大于5，i位置和大边界左边交换，大边界左阔，i不动，因为交换后的i还没比较。</li>
<li><a href="https://www.bilibili.com/video/BV1Ef4y1T7Qi?p=26&vd_source=d980f353cbdc64ff6011544e1f205261">快速排序</a>：随机选一个数（很重要，将n^2降到n*logN），和最后一个值交换，然后以最后一个值做荷兰国旗问题，然后递归。partion返回的是一个数组，就是等于这个值的数组。</li>
<li>堆排序：heapinsert方法可以把值向上对比形成大根堆，如果一个数组值一开始就知道，变成大根堆结构可以从倒数第二行开始或者从最后一个数开始，往前依次做heapify，也可以形成大根堆（重点优化）。大根堆最大值跟最后一个值交换，然后heapsize-1，让新的堆重新变成大根堆，用heapify操作，就是从头节点跟子节点最大值比，小的话就交换，周而复始就形成大根堆，然后重复交换最大值和最后一个值，最终形成有序。</li>
<li><a href="https://blog.csdn.net/weixin_46178278/article/details/134703192">小根堆，大根堆</a>：python里堆结构的实现，import heapq，heappush、heappoll方法，适用于小根堆。</li>
<li>比较器：自定义比较，类似于运算符重载。</li>
</ol>
</li>
<li>不基于比较的排序（不是很好用，要根据数据状况来看）<ol>
<li>计数排序，统计每个数的词频，然后遍历输出。</li>
<li><a href="https://www.bilibili.com/video/BV1Ef4y1T7Qi?p=27&spm_id_from=pageDriver&vd_source=d980f353cbdc64ff6011544e1f205261">基数排序</a>：根据个位十位百位来排序，放到几个桶里。放到桶里的操作可以用前缀和来代替。这个比较难懂，可以再看看视频。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.21_学习日记</title>
    <url>/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：雨夹雪<br>学习地点：家<br>学习时长：7h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>排序算法稳定性<br><img src="/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/85a53b7edab80de5b143b316e97cd6d.png" alt="Alt text"></li>
<li>反转单链表、双链表<br>反转单链表：注意要用一个tmp防止cur.next丢失，最后返回的是pre不是cur。<br>反转双链表：跟反转单链表一样，用一个tmp防止cur.next走丢，然后cru.next&#x3D;pre,cur.last&#x3D;tmp。</li>
<li>判断链表有没有环<br>快慢指针，相遇以后快指针回到head，然后快指针变成慢指针走一步，最后相遇就是入环节点。</li>
<li>判断两个链表相交节点<br>首先算出两个节点长度，然后长度相减得到一个值，最后让长链表先走这么多步，然后再一起走，走到交点就返回即可。还有一种情况是两个有环链表相遇，入环节点不一样，这个时候cur到第一个节点开始走，如果cur回到cur遇到了第二个节点，那就是这种情况，否则返回0。</li>
<li>二叉树遍历<br>递归遍历（先中后）：如果head空，返回空，然后print，再递归左，再递归右。<br>迭代遍历（先）：准备一个栈，先把头放进去，然后弹出来，打印，如果有右孩子和左孩子，先把右孩子压入栈，再左孩子压入栈，最后重复。<br><img src="/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2cb6be26d75b7301f7f8395cf6f1294.png" alt="Alt text"><br>后序遍历（迭代）：准备两个栈，一个准备栈，一个收集栈。先把head放进准备栈，再弹出到收集栈，然后弹入左和右节点，再循环，最后打印收集栈即可。因为是按照头右左的方式弹出到收集栈，最后打印就是左右头。<br>中序遍历：如果头节点不为空，那就把头节点整个左边界压入栈，当左节点为空的时候，弹出节点，打印，然后head&#x3D;右节点，再重复循环。<br><img src="/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/8644de21dfe7d8300db85de5b8fce72.png" alt="Alt text"><br>BFS宽度优先遍历：用队列。压入头节点，然后弹出打印，压入左右节点，继续周而复始。<br>求二叉树最大宽度：用队列。有几个变量，一个curlevel，curlevelnode，max，hashmap。头节点进队列，同时哈希表记录头节点的层数1。然后弹出，并且判断当前节点跟curlevel是不是一样，一样的话，curlevelnode++，如果不一样，那么更新max，同时curlevelnode&#x3D;1.然后压入左孩子，右孩子以及对应的层数。<br><img src="/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/7e678a4ba6c92f79b990ffd924015ce.png" alt="Alt text"><br>搜索二叉树：左边都比head小，右边都大。其实就是中序遍历判断是否降序。<br><img src="/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/5f2aec4d6993110d1b0ceea74af68b4.png" alt="Alt text"><br><img src="/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/0b6ed1e9f0db0b023fac6e651725a0a.png" alt="Alt text"><br>完全二叉树：宽度优先遍历，如果cur有右无左，false，如果cur有左无右，leaf&#x3D;true，然后判断如果leaf and 有左或右，那么false。<br><img src="/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/af10ef6348b10477cfa2e183993f6f5.png" alt="Alt text"></li>
<li>二叉树的递归套路<br>左数信息、右数信息，然后再判断。<br>搜索二叉树：lc98<br>用左右两个信息，把最小值最大值放入递归函数里，最小值最大值换成相应节点值。<br><img src="/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c47fa7be686a4fe5fbc5f25cf995dba.png" alt="Alt text"><br>二叉树的最近公共祖先：lc236<br>也可以用递归，如果root是空，p，q之中的话，返回root，否则，返回两边递归值（除非两边递归值都存在，就是pq分别在左右两边，返回root）<br><img src="/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/72a3965ab13004c97336491dae43657.png" alt="Alt text"><br>返回二叉树的后继节点：<br>后继节点是中序遍历的后面的值，其实就是，如果cur有右孩子，那就返回右孩子里最左的孩子，如果没有，就往上看，如果cur是父节点的左孩子，就返回父节点，否则一直往上走<br><img src="/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/f6331620cc7f23b1b5c387fb421ff95.png" alt="Alt text"><br><a href="https://www.bilibili.com/video/BV1Ef4y1T7Qi?p=30&vd_source=d980f353cbdc64ff6011544e1f205261">二叉树的序列化和反序列化</a>：<br>序列化：如果是空，返回#-，首先生成头节点-，然后左边递归、右边递归。<br>反序列化：把序列-用逗号分割，然后放到queue里，然后如果是#，返回空，head创立出来，然后左右分别递归。<br>折痕问题：<br>二叉树可以解决，每个折痕折一次，两边都会生成一个凸一个凹。所以用二叉树中序遍历就能生成上下顺序。<br><img src="/2024/01/21/2024-01-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/1145f1cd1d83f14f46e1b34b4f2b012.png" alt="Alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.22_学习日记</title>
    <url>/2024/01/22/2024-01-22-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：雪<br>学习地点：家<br>学习时长：7h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>图的算法</p>
<ol>
<li>图的表示很多 邻接矩阵 邻接表<br><a href="https://blog.csdn.net/wd9ljs18/article/details/112191078">建立图</a></li>
<li>图的宽度优先遍历<br>用一个set记录走过的node，建立queue，先放入node，set也放入node，然后遍历queue，弹出来并且打印，然后遍历node的nexts，判断nextnode是否在set里，不在的话，加入queue和set。</li>
<li>图的深度优先遍历<br>用一个set记录走过的node，建立stack，先放入node进他们中，然后直接打印，而不是弹出再打印，随后弹出栈，遍历nexts，如果不在set中，栈中放入node，然后再放入nextnode，set放入nextnode，打印nextnode。然后break掉，继续执行while而不是for的内容，这样就可以让node的其他next不会立马入栈，就可以实现深度遍历。</li>
<li>拓扑排序<br><img src="/2024/01/22/2024-01-22-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/7e9f3af61e8ec6f28e371295d0eb62a.png" alt="Alt text"><br>首先生成一个hashmap，记录node和node剩余的入度。生成一个queue，然后遍历整个graph的node，放入hashmap中，如果入度为0，放入queue里。当queue不为空的时候，把queue弹出cur，放入res中，然后遍历next，把hashmap的next入度-1，如果入度为0，继续放入queue中。</li>
<li>最小生成树（K、P算法）<br>K算法：从最小的边开始遍历，如果不形成环，加上，形成环，不加。<br><img src="/2024/01/22/2024-01-22-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/27c07cfed8c4931bf5f188a66a91fe3.png" alt="Alt text"><br>P算法：生成一个小根堆，一个set，首先把node放入set里，遍历node所有边，把边放入小根堆里，然后如果小根堆里有数的话，弹出堆顶的最小边，然后生成最小边的tonode，tonode看在不在set里，如果不在，set加入它，res加入这条边，然后遍历tonode的所有边，把边放入小根堆里即可。</li>
<li><a href="https://www.bilibili.com/video/BV1Ef4y1T7Qi?p=31&vd_source=d980f353cbdc64ff6011544e1f205261">dijkstra算法（迪杰特斯拉算法）</a><br>思路是有一个距离map记录当前距离，有一个set记录锁定一条边，首先把头节点放进map中，然后遍历边，生成tonode，如果tonode不在map里，往map里加上这条边的值，然后更新这个新的值是否比原值大。然后锁定一开始的node，然后从map里选最小值作为下一个要放入的node循环下去。具体看看视频和网页。<br>暴力递归</li>
<li>前缀树<br>具体看视频。暴力递归这一节。建立过程就是如果是abc，头节点以a为路径生成新节点，头节点pass+1，新节点pass+1，直到c加入以后，末节点end+1.可以查询字符串加入过几次（返回end），或者有多少字符以某字符串为前缀（返回pass）。删除操作就是沿途pass-1，最后节点end-1。如果发现一个节点pass-1&#x3D;&#x3D;0了，直接删掉后面所有信息，node.next&#x3D;NONE。</li>
<li>贪心算法<br><img src="/2024/01/22/2024-01-22-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/80a245766834549ad74874bb1af4e87.png" alt="Alt text"><br><em>生成最多会议数量：这个题就是先按照结束时间排序，然后遍历如果上一个选择的结束时间小于遍历到的最新的开始时间，那就选当下的。</em></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图的遍历</tag>
        <tag>拓扑排序</tag>
        <tag>前缀树</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.23_学习日记</title>
    <url>/2024/01/23/2024-01-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：雪<br>学习地点：家<br>学习时长：5h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>暴力递归、贪心</p>
<ol>
<li>贪心策略经常依据比较器实现堆或者排序。</li>
<li>返回最大钱数<br><img src="/2024/01/23/2024-01-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/5793f8ffd4d4fa6ae373dcb792bcc74.png" alt="Alt text"><br><img src="/2024/01/23/2024-01-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/5ef24095899d622bf1ef2411303852d.png" alt="Alt text"><br>一个小根堆用比较器进行排序，spend最小的在上面，一个大根堆用比较器排序，利润最大的再最上面。然后遍历小根堆，如果小根堆堆顶的花费小于我得钱，那么弹到大根堆里，如果大根堆空了，就返回money。然后更新money。</li>
<li>取得中位数<br>用两个堆，一个大根堆一个小根堆，先把第一个数字放入大根堆，接下来的数，如果小于大根堆的堆顶，如果是，放进大根堆，如果不是，放进小根堆，然后看size的差如果&#x3D;2，大size堆顶进小根堆。最终就是大根堆放小于中位数的数字，小根堆放大于中位数的数。最后看size，大的那个堆顶就是中位数，如果size相等，就是俩中位数。</li>
<li>N皇后（lc51）<br>版本1（打印出来）：思路就是用回溯算法，首先先生成全是.的n*n列表。主函数是当row走到n越界时，给res返回一种答案，这时候要用空格把每一行的列表变成字符串，然后return，找下一种方法。当到达i行的时候，要遍历每一列，看放到某个位置能不能行，如果能行，先把当前位置变成‘Q’那就继续往下dfs递归，当往下递归失败往上return以后，要把’Q’回复成.，最后bfs（0），然后返回res。判断是否有效就是看上方，左上方，右上方有没有Q，用到zip函数，可以把range的内容合在一起。<br>版本2（返回个数）：用一个record记录每一行放在第几列，然后当i来到n行，返回1，用res更新答案，来到第i行的时候对列遍历，如果有效，那么record记录上该位置j，然后res+dfs递归到下一行的结果，最后返回res，然后判断是否有效就是遍历之前的皇后，如果列数相等或者列数相减的绝对值等于行数相减，那就无效。</li>
<li>取出二进制中最右的1：pos&amp;（~pos+1）。可以用于遍历。</li>
<li>二叉树最大距离值<br><img src="/2024/01/23/2024-01-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/a40b3d58a2ba55a563de7f9aa3a1054.png" alt="Alt text"><br>这个题用到递归套路。第一种情况不要头节点，返回左右两边的最大值，第二种情况要头节点，返回头节点+左边（不为空情况）和头节点+右边（不为空）和头节点+左边+右边（都不为空）的最大值。</li>
<li>返回一个数组，java是返回node，python怎么搞明天搜一下。</li>
<li>数组的除以当前数字的乘积（facebook面试题）<br>要考虑0的个数，非零数乘起来，然后遍历的时候要看当前是不是0，以及0一共有多少个。1个和多个情况不一样。</li>
<li>k进制异或（找到一堆数里的不一样的一个数）<br><img src="/2024/01/23/2024-01-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9a9338190191fa55b078218949a0461.png" alt="Alt text"><br><img src="/2024/01/23/2024-01-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3c2b12f8ee34574de74c1f8c88cde74.png" alt="Alt text"><br>把数组所有数先生成k进制数，累加到一个数组里，然后对k取余，最后转化成10进制。</li>
<li>返回后序遍历数组是否生成最小搜索树<br>最小搜索树就是头节点左边小，右边大，所以后续遍历最后一个值是头节点，然后左边的值必然有个分界线，分界线左边的是头节点左边的值，右边是头节点右边的值，所以用二分法找这个分界线即可。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.24_学习日记</title>
    <url>/2024/01/24/2024-01-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：阴<br>学习地点：家<br>学习时长：4h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>哈希函数和哈希表</p>
<ol>
<li>实现常数复杂度级别的哈希表插入、删除、弹出随机key操作<br>弹出随机key：准备两个哈希表，然后分别插入值和index，index按顺序传，两个表相反。然后按照index随机数弹出。<br>删除：跟上面同样的数据结构，删除key用最后一个key来补之前被删的index的key。size-1。<br>插入：就是直接往后加，index++，然后要加两个哈希表。<br><img src="/2024/01/24/2024-01-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/439350ace3217433033119f517c74a3.png" alt="Alt text"></li>
<li>布隆过滤器（一个set，可以支持插入、查询，需要的内存小，会失误，把白名单认成黑名单url）<br>流程是把url网站通过k个哈希函数再%m，得到一个数，在长度为m的空间里，把这个位置描黑。查找的时候按照相同操作，看这些位置有没有描黑判断这个url在不在黑名单里。m和k都要控制，不然失误率会太大。根据n和m选择k，m相同，k越大，失误率按照先减少后增加的。<a href="https://www.bilibili.com/video/BV1Ef4y1T7Qi?p=34&vd_source=d980f353cbdc64ff6011544e1f205261">三个公式</a>：1小时50分</li>
<li>一致性哈希<br>看视频，听不太懂</li>
<li>网易面试题<br><img src="/2024/01/24/2024-01-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/27dc143da20a8bb212df3afddfbdeff.png" alt="Alt text"><br><img src="/2024/01/24/2024-01-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/77fba4892f1bfaa90341ffb3fd461f1.png" alt="Alt text"><br>这个题主要是考细心，一个数组可以变一个数，怎样才能变成x的倍数。先把整体和算出来，然后看当前数字变成另一个数字以后该数字取余+剩下数字取余是不是等于x或者当剩下取余是0那么取余是不是也等于0的所有情况。</li>
<li>N皇后2（lc52）<br><img src="/2024/01/24/2024-01-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/930147a97ab1b516932a65201f14c9c.png" alt="Alt text"><br>用位运算做的方法很好，取最右边的值，选可用的值等等方法还需要多看看。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>回溯算法</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.25_学习日记</title>
    <url>/2024/01/25/2024-01-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：阴<br>学习地点：家<br>学习时长：5h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>mysql的下载、安装、启动、数据模型<br>打开cmd，输入mysql -u root -p即可。</li>
<li>sql语言的分类<br>DDL：数据定义语言 DML：数据操作语言，增删改 DQL：数据查询语言，查 DCL：数据控制语言，控制权限，创建数据库</li>
<li>DDL<br><img src="/2024/01/25/2024-01-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/8b7c5f66dc489ae30588276f23042d8.png" alt="Alt text"><br><img src="/2024/01/25/2024-01-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/eb084dc2a05d597442a3b0be0a945f2.png" alt="Alt text"><br><img src="/2024/01/25/2024-01-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9ac94f892821c942bfbe54f509ffd98.png" alt="Alt text"><br><img src="/2024/01/25/2024-01-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e68ffbf44887945bd08fb31e1d7b3ac.png" alt="Alt text"><br><img src="/2024/01/25/2024-01-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9fc811f898b464175625cff82e544dd.png" alt="Alt text"><br>注册了7个月datagrip。datagrip操作更简单一些，可视化。</li>
<li>DML<br><img src="/2024/01/25/2024-01-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/02e2b69655f39d9144bbdd07f154be7.png" alt="Alt text"><br>学到15讲了。明天继续往后更新。</li>
<li>DQL（明天更新）</li>
<li>DCL（明天更新）</li>
<li>子集（lc78）<br><img src="/2024/01/25/2024-01-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b4a2af1cd3a20140cc98430545f7fbb.png" alt="Alt text"><br>所有子集，就是考虑当前数字选或者不选两种情况，所以考虑回溯函数，当index&#x3D;&#x3D;n越界时，返回一个sol，然后return。然后继续回溯，回溯两种情况，第一种要当前值，第二种不要当前值。然后主函数就从index&#x3D;0开始，sol为空数组开始。</li>
<li>全排列（lc46）<br><img src="/2024/01/25/2024-01-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/1d70ecec71c54d6b475f4dffb9eb6e1.png" alt="Alt text"><br>也是用回溯算法做，用check数组检查该位置有咩有选过，当sol长度&#x3D;&#x3D;nums长度，res就添加sol，然后如果选过了continue，没选过就选，check【i】记得在回溯以后要变成0，以免影响后续结果。</li>
<li>全排列2（lc47）<br><img src="/2024/01/25/2024-01-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/db8f6ccf7d033f3711c542857177054.png" alt="Alt text"><br>跟上个题一样，但是要考虑到剪枝，因为按照上面的122和122会出现两次，重复情况必须考虑清楚，所以剪枝条件就是先对nums排序后，如果当前值等于前面的值，并且前面的值没用过，那么下面递归的时候肯定要用到这个值，所以就continue。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Mysql</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.26_学习日记</title>
    <url>/2024/01/26/2024-01-26-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：阴<br>学习地点：家<br>学习时长：5h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>电脑主板烧了，直接没法开机，今天的内容1.30日更新。</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.29_学习日记</title>
    <url>/2024/01/29/2024-01-29-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：阴<br>学习地点：家<br>学习时长：3h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>今天换了新电脑，之前文件基本转移过来了，下各种软件，还有配置博客，这几天没学习，明天更新学习内容。</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.30_学习日记</title>
    <url>/2024/01/30/2024-01-30-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：阴<br>学习地点：家<br>学习时长：9h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>mysql 函数<br><img src="/2024/01/30/2024-01-30-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/d906bbc970b7fe53c7b8fe65b4ccec0.png" alt="Alt text"><br>几个用法用的时候看看就行，比较简单。</li>
<li>约束<br><img src="/2024/01/30/2024-01-30-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/388b5e6699d2505545a81f8ecfadf01.png" alt="Alt text"><br>同上，用的时候看看。</li>
<li>多表查询<br><img src="/2024/01/30/2024-01-30-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/d0acad4f6832e69191886019533d9ac.png" alt="Alt text"><br>看看案例就行，语法比较杂。明天看事务部分。</li>
<li>岛屿问题<br><img src="/2024/01/30/2024-01-30-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/5ece3f922c17a370dbea7e5f542556e.png" alt="Alt text"><br>遍历整个数组，如果值为1，就是岛屿，res+1，同时要对周围进行感染，把上下左右感染成2，然后就是这个感染函数，想清楚函数需要什么参数，i和j要变，grid也要变，然后考虑ij位置，越界了返回。然后把这个点变成2或者0，然后继续递归上下左右四个位置。</li>
<li>并查集<br>查询两个样本是不是在一个集合，两个集合合并都是O1的时间复杂度。<br>issameset：看两个是不是在一个集合，两个点往上找父节点，如果一样，就true。<br>union：看是不是issameset，如果不是，把短的点直接连给长的头节点。<br>准备三个map，elemap对应每个节点自身圈起来。fathermap对应每个节点的所有父节点。sizemap里面只放头节点，记录集合有几个点（包括自己）。<br>首先遍历list到三个表里，ele放自己，father放自己，size放1。<br><img src="/2024/01/30/2024-01-30-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3c4da56ae27f0f119877b02ce7e7183.png" alt="Alt text"><br>记得更新sizemap和fathermap。思路就是如果ele里有这两个点，返回findhead的头节点是否相等。以及如果有两个点，那么findhead分别求出来，长的big，短的small，然后维护size和father信息，sizemap里remove掉small。<br><img src="/2024/01/30/2024-01-30-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/78e6208d912df0ef323dda7314b85ce.png" alt="Alt text"><br>用一个path记录沿途所有father，如果当前的map父节点不等于自己，自己就变成父节点，父节点记录到path，找到后弹出，最后path栈弹出元素的fathermap全更新为找到的父节点。</li>
<li><a href="https://leetcode.cn/problems/number-of-islands/solutions/13103/dao-yu-shu-liang-by-leetcode/">岛屿问题并查集解法</a><br>着重看一下，还没完全掌握。自己写了一个优化版本，但是跑出来不理想。具体就是设置一个unionfind类，类里面有初始化，初始化设置count，parrent（m×n长度），size（m×n长度）。然后遍历整个列表，对于等于1的，把对应的父亲设置成自己的下标，并且count+1。然后设置findfather，如果parent不是自己的下标，那就递归自己的parent，递归前设置path放入当前下标。递归后弹出来path所有值，同时设置他们的父亲为头节点。然后是union函数，找到头节点，不相等的时候看size谁更大，然后把短的头设成长的，如果相等，那么size+1，然后count-1，因为union以后count-1。然后是getcount函数，就是返回本身的count。主函数的设置就是遍历整个数组，如果为1，更新成0，然后对周围四个点遍历，如果没有越界，或者为1，那么就union这个值跟原来的值。最后返回getcount。</li>
<li>最大人工岛问题（lc827困难）<br><img src="/2024/01/30/2024-01-30-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/efc85ed602162d706d3bf2b464be8dc.png" alt="Alt text"><br>这个题也是并查集的应用，着重看一下这个题，python版本怎么写并查集。定义find，union，不用定义类也行，然后想一下为什么不用self也行。设置parent数组n*n，size数组一样，遍历数组，如果为1，对周围四个点为1的union。然后岛屿出来了，size出来了，记录max为最大岛屿size，然后遍历数组，如果为0，建立一个visited集合用来看周围四个点的root，遍历周围四个点，如果为1，找到这个点的root，如果这个点不在visited里，加到visited里面，然后岛屿数t加上这个点的size，四个点遍历完以后更新max，最后返回max即可。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Mysql</tag>
        <tag>并查集</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.01.31_学习日记</title>
    <url>/2024/01/31/2024-01-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：阴<br>学习地点：家<br>学习时长：8h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>mysql事务<br><img src="/2024/01/31/2024-01-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/f9cf044f1fd7cbc089480a90c67e06d.png" alt="Alt text"></li>
<li>进阶篇 存储引擎<br><img src="/2024/01/31/2024-01-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/68be66cf782f3226052708aaf9a8753.png" alt="Alt text"><br>简单看看，感觉不太重要</li>
<li>KMP算法（找子串）<br><img src="/2024/01/31/2024-01-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/1875f6b5ffeb2b49a72510ba75e79eb.png" alt="Alt text"><br><img src="/2024/01/31/2024-01-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/409c1dad985659ece2966d96f744d80.png" alt="Alt text"><br>KMP算法就是AB两个字符串，看A是不是包含B这个子串。整个方法就是首先边界条件设置好，然后生成一个next数组，统计B子串当前位置的开头前缀和结尾前缀相同的个数，然后就是循环，当两个字符串不越界的时候，如果当前位置相同，i，j都+1，如果不同并且next数组位置&#x3D;-1,那么i+1，跳到下一个位置去重新比对，next数组位置不等于-1的话，j位置就跳到next【j】上来，最后返回有两种情况，第一种是A不包含B，A越界，另一种是包含B，B到了终点位置，所以最后如果j到了终止位置，返回i-j，否则返回-1。<br>KMP算法逻辑就是两个字符串，如果对比到i位置不相同，前面都相同，那么B串有两个相同的前缀，然后A串的后前缀跟A的后前缀相同，所以也就跟A的前前缀相同，然后把B子串往后推到该位置来对比就行了，如果相同就继续都+1，不同并且next不为-1，就继续推，推的过程可以用i位置跟next【j】位置来对比就行了。<br>关键是求next数组，0位置-1，1位置0，然后后续就是看n-1位置跟cn位置是不是一样，cn位置就是next【n-1】这个位置，如果相同，那么next【n】&#x3D;next【n-1】+1&#x3D;cn+1，然后n++，同时cn++，如果不相等并且cn&gt;0，那么cn&#x3D;next【cn】，如果cn&#x3D;0，那么next【n】&#x3D;0，并且n++。</li>
<li>重复子串（lc459）<br><img src="/2024/01/31/2024-01-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/0d0287cd916db14e5c34335c63a8dc2.png" alt="Alt text"><br>kmp算法，这个要看包含自身的这个最长子串，所以初始化的时候把s后面加一个空格，然后在算最后一个的next值，这个next值剩下的部分就是重复子串，所以最后返回len能不能整除这个重复字串的长度。把创建next数组的流程记住了，-1，0，然后往后看cn跟i前一个数是不是相等，不相等cn大于0就往前继续找。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Mysql</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.01_学习日记</title>
    <url>/2024/02/01/2024-02-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：阴<br>学习地点：家<br>学习时长：5h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>mysql索引<br><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68&spm_id_from=pageDriver&vd_source=d980f353cbdc64ff6011544e1f205261">B树</a>，有一个degree值，当前节点数满了就取中间元素向上溢出，从下往上。具体看视频。<br>B+树，跟b树一样，但是向上溢出要的时候元素要保留，并且生成一个指针，从左指向右。所有数据都会出现在叶节点。<br>hash存储，容易引发hash碰撞，因为经过哈希函数计算后，可能算出来的值一样，这个时候往后面加链表就行。<br>聚集索引和二级索引：聚集索引放id，挂全部信息，二级索引放后面的信息，挂id，如果找一个名字的所有信息，就先在二级索引里找名字，名字下面挂了id，然后回表查询id对应的全部信息。<br>索引设计原则：<br><img src="/2024/02/01/2024-02-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/f6087281c5a7fa7545b50609d43a77e.png" alt="Alt text"><br><img src="/2024/02/01/2024-02-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/fcc119d25e09a62fdbbcab5c6c85928.png" alt="Alt text"><br><img src="/2024/02/01/2024-02-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b8860a078c7042e534249bf5bebf843.png" alt="Alt text"></li>
<li>manacher算法<br>暴力解法：从左往右遍历每个位置，看左右两边是不是相等，然后统计最大回文子串长度，但是会有奇偶情况，所以把每个字符两边都加一个#sharpe，然后再遍历，最后结果除以2即可。<br>manacher解法：<br>回文直径、回文半径：回文的长度、长度&#x2F;2<br>R：从左往右遍历的时候，每个位置回文直径的右边界位置，只增不减，一直更新。<br>C：遍历的时候最右边界位置的那个中心位置。<br><img src="/2024/02/01/2024-02-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/11c58242eab92c311b9712363d7ba61.png" alt="Alt text"><br><img src="/2024/02/01/2024-02-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/8a443712261e3c6a0ec39b4740d5417.png" alt="Alt text"><br><img src="/2024/02/01/2024-02-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/4498ae69f121305bc9fdf580cfc4a73.png" alt="Alt text"><br>这个题核心是，首先把字符串中间两边加上#，然后生成一个数组，数组内容是当前位置的最大回文半径，同时有R和C两个值需要更新，初始值为-1。一共有四种情况，第一种i位置在R范围外面，这时候只能暴力寻找回文半径，然后是在R范围内，首先找到2C-i位置，就是相对于中心点的对称位置i1，这个位置三种情况，第一，i1左回文位置半径在L右边，这时候i的回文半径&#x3D;i1回文半径，第二，i1左回文位置半径在L左边，这时候i半径就是R-i，第三，回文半径跟L重合，这时候i半径需要暴力尝试从R位置开始，R位置内的一定重合。一共四种情况，代码首先看边界条件，空就返回0。然后求出i最少的回文半径先给到当前位置，当R &lt; i的时候，等于1，&gt;i的时候，就等于R-i和carr【i1】这个半径的最小值。然后再对其依次遍历，当i位置+最小半径和-最小半径不越界的时候，如果这两个位置相等，carr【i】+1，否则break，然后更新一下R和C，更新max（整个数组最大回文子串长度），最后返回max-1，因为半径大小-1才是最后的最大回文长度。</li>
<li><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">最长回文子串（lc5）</a><br><img src="/2024/02/01/2024-02-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e5db18d926613e14c3a024269cf2495.png" alt="Alt text"><br>这个题就是用manacher算法写，生成数组可以用“#”+’#’.join(s)+’#’,用列表也可以，最后记得join，这个题要想清楚最后生成字符串时候的开始位置和结尾位置。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Mysql</tag>
        <tag>manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.02_学习日记</title>
    <url>/2024/02/02/2024-02-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：家<br>学习时长：4h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>滑动窗口（lc239困难）<br><img src="/2024/02/02/2024-02-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/6c76fe7712ad0b68d628d10ee7e3e8f.png" alt="Alt text"><br><img src="/2024/02/02/2024-02-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/6cf1e1516ba18a4319b553e7aea6d8e.png" alt="Alt text"><br>这个题是滑动窗口问题，如何用On的复杂度返回窗口的最大值最小值，这里用最大值举例。首先生成一个双端队列，双端队列左大右小，每进一个数，跟最右边的数比，如果小，就放右边，如果大，那队列弹出末尾元素，然后继续比较，然后需要删除过期元素以及返回最大值给数组，最后返回res数组即可，双端队列维护的这个区间就是最左边的数是最大值，L往右动一次那么最大值更新一次。最小值的话就是队列从小到大排列。<a href="https://leetcode.cn/problems/sliding-window-maximum/description/">记得看一下python版本。</a></li>
<li>各种数据结构python如何引用<br><a href="https://www.jianshu.com/p/9b94651534c3">引用链接</a></li>
<li>最小覆盖子串（lc76）<br><img src="/2024/02/02/2024-02-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/8b75d7db9d3c44c9567214d85b36c4d.png" alt="Alt text"><br>这个题就是用一个字典记录窗口内还需要多少个target的字符数量，分三步，第一步从0开始往右走，直到cnt&#x3D;0位置，窗口左边界往右动，动到need【c】&#x3D;0的时候停止，遇到t的元素，然后更新最小值最大值，第三步就是i往下动，need【c】+1，cnt+1，然后右边界继续往右动，最后返回i到j的索引切片，如果j一直没更新还是最大值，那就返回空，没有更新。</li>
<li>单调栈<br>单调栈就是一个栈结构，下面大上面小，遍历一个数组，可以把数组左右边离你最近的更大的数字生成。具体就是如果当前位置比栈顶小就进栈，大的话就弹出栈顶元素，此时栈顶元素下面的位置就是左边最近的，当前位置是右边最近的，然后继续对比，如果小的话就进栈。但是遇到重复值的时候要把下标重叠起来，变成一个集合。</li>
<li>接雨水（lc42）<br><img src="/2024/02/02/2024-02-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/eb42ff632c07c87ab49cf7874a6af5a.png" alt="Alt text"><br>这个题就是用单调栈，当前如果大于单调栈顶，栈顶弹出后左边的值是left，当前值是right，然后左右最小值-栈顶元素高度就是雨水高度，right-left-1就是雨水长度，累加乘起来就行。while中间加了等号，可以排除掉重复元素。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>滑动窗口</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.03_学习日记</title>
    <url>/2024/02/03/2024-02-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：阴<br>学习地点：家<br>学习时长：4h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>SQL优化<br><img src="/2024/02/03/2024-02-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/76f1db048bc01a918e4ccd50580dead.png" alt="alt text"><br>到时候再看看</li>
<li>二叉树的直径<br><img src="/2024/02/03/2024-02-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e339200c7f0eb0befeb538e78f5e4be.png" alt="alt text"><br>这种题要从左右两边要信息，所以用一个init函数初始化我们需要的结果，然后dfs返回我们需要的信息，比如高度，然后ans就在dfs里更新生成，最后主函数返回ans就行。</li>
<li>树形dp<br><img src="/2024/02/03/2024-02-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c7dfe84fdff6ea4134a8c2f59032b04.png" alt="alt text"><br>遇到这种题就是想好从左右两边要什么信息，还有头节点参不参与，如果头节点参与，那么返回子节点不参与的最大快乐值相加，如果头节点不参与，那就返回子节点参与或者不参与的最大快乐值，然后相加，最后更新最大值。</li>
<li>morris遍历<br><img src="/2024/02/03/2024-02-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/a21835f68d8104417616b2008b5b26d.png" alt="alt text"><br><img src="/2024/02/03/2024-02-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/027df02d70226ae2898cc9f8cd06fcb.png" alt="alt text"><br><img src="/2024/02/03/2024-02-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/f35bcb4bae2f3bc01a6ee180dafcddd.png" alt="alt text"><br>先序遍历：如果只出现一次，直接打印，如果出现两次，第一次的时候打印。<br><img src="/2024/02/03/2024-02-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c95dab6c2ab8fb2acf6b5d0ead52198.png" alt="alt text"><br>中序遍历：如果只出现一次，直接打印，如果出现两次，第二次的时候打印，所以直接在没有左树的情况下打印即可。<br><img src="/2024/02/03/2024-02-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/bd0ea3cb8e72e0136d444f37138cb2f.png" alt="alt text"><br><img src="/2024/02/03/2024-02-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/d745f187c42c4d17c234215401f8a94.png" alt="alt text"><br>后序遍历：如果出现两次，第二次来到自己的时候逆序打印所有右边界，最后再逆序打印整个二叉树的右边界。逆序操作就是反转单链表。</li>
<li>验证搜索二叉树（lc98）<br><img src="/2024/02/03/2024-02-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/94e7a950f82d3aaaa714af00ce98577.png" alt="alt text"><br>就是中序遍历的情况下，看当前值小于等于下一个值，那就是搜索二叉树，用morris遍历的方法做很好，熟悉morris遍历的代码。</li>
<li>0到2的32次方-1这么多数，找到哪个数不存在，用有限变量<br>二分法，左边如果没满，就去左边继续二分找，肯定能找到一个区间没有数。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Mysql</tag>
        <tag>动态规划</tag>
        <tag>二叉树遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.04_学习日记</title>
    <url>/2024/02/04/2024-02-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：小雪<br>学习地点：家<br>学习时长：8h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>mysql视图、存储过程、存储函数、触发器<br><img src="/2024/02/04/2024-02-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/04fa4ef00d4a18f2a3410a82f9dd1eb.png" alt="alt text"></li>
<li>大数据题目<br><img src="/2024/02/04/2024-02-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/ce422ef9e8a4811dcf80e8a665e3e8e.png" alt="alt text"><br><img src="/2024/02/04/2024-02-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b22c97aacbb63c1295495d25565dd89.png" alt="alt text"><br>怎么找到top100，先分成局部几部分数据，然后用哈希表记录每一部分的词频，然后用堆结构把词频排序，然后用一个新的堆结构放入各个小部分的堆顶并排序，然后弹出堆顶，就是全局最大值，并且看该堆顶之前是哪个堆的顶，然后把这个子堆的堆顶元素弹出放入新堆顶，然后循环弹出一百个数就是top100。<br><img src="/2024/02/04/2024-02-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/f8ed2e994dc1d74999414fe9cd92f2c.png" alt="alt text"><br>解决办法：<br>哈希函数分流：看1GB内存的哈希表能放多少数据，然后就能知道分多少小文件了，一个数通过哈希函数最后取模就知道放到哪个小文件里去，最后用哈希表对每个小文件进行词频统计，然后汇总就是答案。<br>位图方法：用两个位来判断一个数字出现的次数，如果是00，就没出现，01，出现一次，10，出现两次，11，出现很多次。2的32次方个数占用2的32次方*2&#x2F;8个字节。<br>找中位数的办法：<br><img src="/2024/02/04/2024-02-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/101686b0f88e32be4e7fc1878a062a5.png" alt="alt text"><br>腾讯面试题：怎么把一堆10G内存的没有排序过的数字通过任意内存比如1M内存然后生成一个排序过的文件？<br>第一种方法通过分段统计思想，计算1M能记录多少int数字，然后相除就可以知道分成多少个区间，然后对所有数字以及出现的次数处在第一个区间的放进小根堆，按照数值排序，然后根据词频放进生成的文件即可。<br>第二种方法是通过大根堆，大根堆放的数据量也是根据内存大小定，大根堆放数字以及词频，如果大根堆放满了，那就比较接下来的值和堆顶的大小，如果大，就跳过，如果小，堆顶弹出并且把这个值放进堆当中，遍历完以后让Y&#x3D;3，第二次遍历，只把Y&gt;3的数放进大根堆里来。<br>比较两个值的大小：<br><img src="/2024/02/04/2024-02-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/a625f509e4c6cee6914629ef74c601b.png" alt="alt text"><br><img src="/2024/02/04/2024-02-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9d097e2985c72ee7196e79cf9d5da97.png" alt="alt text"><br>怎么判断一个数是不是2或者4的幂？(lc342)<br>判断2的幂可以用x&amp;(x-1) &#x3D;&#x3D; 0来判断。<br>判断4的幂可以先判断是不是2的幂，然后用x&amp;(32位010101010101)来判断，如果!&#x3D;0，就是4的幂。二进制用0b的前缀表示。<br><img src="/2024/02/04/2024-02-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/53634a08dfc47a821fe9c65e007918c.png" alt="alt text"><br>+：两个数异或^就是不进位相加，两个数&amp;然后&lt;&lt;1就是进位信息，然后重复这样，直到两个数&amp;为0了，此时异或的值就是最后的答案。<br>-：a加上b的相反数，相反数就是b取反+1<br><em>：乘法二进制也跟十进制的乘法一样，a</em>b等于如果b末尾是1，那就res+a，然后a左移一位，b右移一位，如果末尾是0，跳过res+a部分，然后重复，直到b&#x3D;0弹出，返回res。<br>&#x2F;：除法就是看被除数左移多少位能被除数减掉，从31位开始往下数，如果到第三位，被除数大于除数，那么res &#x3D; 1左移3位，然后相减之后继续从第二位开始左移相减，如果左移后被除数大于除数，那么res+1左移2位，最后知道左移数为0跳出循环，返回res。<br><img src="/2024/02/04/2024-02-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b87de51dbf33e38b8c33853de7565c7.png" alt="alt text"><br><img src="/2024/02/04/2024-02-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/228a64b49c916b8d46c362527b3a0b1.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Mysql</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.05_学习日记</title>
    <url>/2024/02/05/2024-02-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：大雪<br>学习地点：家<br>学习时长：8h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>mysql 锁<br><img src="/2024/02/05/2024-02-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/30f971dbf73c808ad6444e9e23b6683.png" alt="alt text"></li>
<li>机器学习部分<br><a href="https://cuijiahua.com/blog/2017/11/ml_1_knn.html">KNN算法</a>：看这个点跟其他点的距离，找最近的k个点，然后按照概率进行分类。<br><img src="/2024/02/05/2024-02-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/0b7987b3303aa8be62b4dd19031e82a.png" alt="alt text"><br>KNN算法不具有显性的学习过程。（machine learing文件夹中有KNN代码）<br><img src="/2024/02/05/2024-02-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/34485c9b1920e6f61e0f4de00638804.png" alt="alt text"><br>算法还需要计算错误率，错误率在可接受范围内才能用KNN算法。<br>生成图的时候记得把FontProperties函数改成全小写，函数名不改，就改下面的FontProperties&#x3D;font部分。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.06_学习日记</title>
    <url>/2024/02/06/2024-02-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：大雪<br>学习地点：家<br>学习时长：8h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>KNN算法的优缺点<br><img src="/2024/02/06/2024-02-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b7cf4161cb880a37b4ad5e288fa587d.png" alt="alt text"></li>
<li><a href="https://cuijiahua.com/blog/2017/11/ml_2_decision_tree_1.html">决策树</a><br><img src="/2024/02/06/2024-02-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/a4b9c738341fb8e512cf57a02bfb49c.png" alt="alt text"><br>Sklearn之使用决策树预测隐形眼睛类型<br>glassdecisiontree这个文件的代码，先处理文件的特征、类别，放入字典，生成pandas表，然后序列化，用graphviz可视化决策树，然后就可以做测试了。<br>决策树的优缺点<br><img src="/2024/02/06/2024-02-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9cdbe01d0f3010f0b976448622b501d.png" alt="alt text"></li>
<li><a href="https://cuijiahua.com/blog/2017/11/ml_4_bayes_1.html">朴素贝叶斯</a><br><img src="/2024/02/06/2024-02-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3711595727687b25984be33e57d6be0.png" alt="alt text"><br>朴素贝叶斯之过滤垃圾邮件<br><img src="/2024/02/06/2024-02-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/4416aa2a220c02c6789aa15c894d679.png" alt="alt text"></li>
<li><a href="https://cuijiahua.com/blog/2017/11/ml_7_logistic_2.html">logistic回归</a><br><img src="/2024/02/06/2024-02-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b74817a4865f138fb677d594d7077ec.png" alt="alt text"><br>从疝气病症状预测病马的死亡率<br><img src="/2024/02/06/2024-02-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/8bb7ae44d056996891b2bde56e5f7b2.png" alt="alt text"><br>当数据集较小时，我们使用梯度上升算法<br>当数据集较大时，我们使用改进的随机梯度上升算法<br>在Sklearn中，我们就可以根据数据情况选择优化算法，比如数据较小的时候，我们使用liblinear，数据较大时，我们使用sag和saga。<br>这个方法还要更改solver和max_iter值，才能达到收敛。<br><img src="/2024/02/06/2024-02-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2a0cfe0dda1b090a2736fc53ac21498.png" alt="alt text"></li>
<li><a href="https://cuijiahua.com/blog/2017/11/ml_9_svm_2.html">SVM（支持向量机）</a><br><img src="/2024/02/06/2024-02-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/d2bcbe510dbd01dce39a2f183abdda5.png" alt="alt text"><br>可以增加维度来分低纬度不可分的数据，用核函数。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.07_学习日记</title>
    <url>/2024/02/07/2024-02-07-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：雾<br>学习地点：家<br>学习时长：5h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>bagging\boosting（集成方法）<br>bagging是从原始样本集抽取不同的样本集，然后每个样本集得到不同的模型。分类问题就采用投票的方式得到最后的结果，回归问题就用均值得到结果。这里面所有模型的重要性相同。<br>boosting跟bagging相似，但是不同的样本集权重不同。<br>区别：<br><img src="/2024/02/07/2024-02-07-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/23474e49261a55b9292bb9dbc9141a6.png" alt="alt text"></li>
<li><a href="https://cuijiahua.com/blog/2017/11/ml_10_adaboost.html">Adaboost</a><br><img src="/2024/02/07/2024-02-07-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/be368aa8d8f1dbb30660a5832db5991.png" alt="alt text"><br>代码很简单</li>
<li><a href="https://cuijiahua.com/blog/2017/11/ml_11_regression_1.html">回归</a><br>LWLR局部加权线性回归，过小的核可能导致过拟合现象，即训练集表现良好，测试集表现就渣渣了。</li>
<li><a href="https://cuijiahua.com/blog/2017/12/ml_12_regression_2.html">岭回归</a><br>缩减方法（逐步线性回归或岭回归），就是将一些系数缩减成很小的值或者直接缩减为0。这样做，就增大了模型的偏差（减少了一些特征的权重），通过把一些特征的回归系数缩减到0，同时也就减少了模型的复杂度。消除了多余的特征之后，模型更容易理解，同时也降低了预测误差。但是当缩减过于严厉的时候，就会出现过拟合的现象，即用训练集预测结果很好，用测试集预测就糟糕很多。<br>预测乐高玩具套件的价格：<br>可以用岭回归交叉验证，可以看到哪些特征是重要的，然后预测的时候可以就用这些特征预测，回归与分类的不同点在于，前者预测连续类型变量，而后者预测离散类型变量。</li>
<li>动态规划<br>建表，找表依赖关系，找可以填的base值，然后依次填表。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.08_学习日记</title>
    <url>/2024/02/08/2024-02-08-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：家<br>学习时长：1h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>今天就下了个软件，Anaconda、pytorch。</p>
]]></content>
      <categories>
        <category>酒精日记</category>
      </categories>
  </entry>
  <entry>
    <title>2024.02.09_学习日记</title>
    <url>/2024/02/09/2024-02-09-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：家<br>学习时长：2h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>今天就继续下了tensorflow等等深度学习的包。</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
  </entry>
  <entry>
    <title>2024.02.10_学习日记</title>
    <url>/2024/02/10/2024-02-10-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：家<br>学习时长：3h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>深度学习<br>ReLU激活函数：<br><img src="/2024/02/10/2024-02-10-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9bbe62f3203215a7a9694257bf201a0.png" alt="alt text"><br>对于图像应用，我们经常在神经网络上使用卷积（Convolutional Neural Network），通常缩写为CNN。对于序列数据，例如音频，有一个时间组件，随着时间的推移，音频被播放出来，所以音频是最自然的表现。作为一维时间序列（两种英文说法one-dimensional time series &#x2F; temporal sequence）.对于序列数据，经常使用RNN，一种递归神经网络（Recurrent Neural Network），语言，英语和汉语字母表或单词都是逐个出现的，所以语言也是最自然的序列数据，因此更复杂的RNNs版本经常用于这些应用。<br>结构化数据意味着数据的基本数据库。例如在房价预测中，你可能有一个数据库，有专门的几列数据告诉你卧室的大小和数量，这就是结构化数据。非结构化数据是指比如音频，原始音频或者你想要识别的图像或文本中的内容。这里的特征可能是图像中的像素值或文本中的单个单词。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>神经网络与深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.11_学习日记</title>
    <url>/2024/02/11/2024-02-11-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：家<br>学习时长：3h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>深度学习<br><img src="/2024/02/11/2024-02-11-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3be8c93e667cf2be0ef2520cf3a6f01.png" alt="alt text"><br>不能在隐藏层用线性激活函数，可以用ReLU或者tanh或者leaky ReLU或者其他的非线性激活函数，唯一可以用线性激活函数的通常就是输出层；<br><img src="/2024/02/11/2024-02-11-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/8e1d09d18bd2ac956cbf39832465f30.png" alt="alt text"><br>当你训练神经网络时，权重随机初始化是很重要的。对于逻辑回归，把权重初始化为0当然也是可以的。但是对于一个神经网络，如果你把权重或者参数都初始化为0，那么梯度下降将不会起作用。<br><img src="/2024/02/11/2024-02-11-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/142d0b10befac275d2eec9c9e6349e5.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>神经网络与深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.15_学习日记</title>
    <url>/2024/02/15/2024-02-15-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：阴<br>学习地点：家<br>学习时长：2h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>复习了一下之前的博客笔记。</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.21_学习日记</title>
    <url>/2024/02/21/2024-02-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：雨<br>学习地点：学校<br>学习时长：6h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>深度学习<br><img src="/2024/02/21/2024-02-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2761cfc7852f8b460043b70dc57c154.png" alt="alt text"><br>深度学习可能存在过拟合问题——高方差，有两个解决方法，一个是正则化，另一个是准备更多的数据，这是非常可靠的方法，但你可能无法时时刻刻准备足够多的训练数据或者获取更多数据的成本很高，但正则化通常有助于避免过拟合或减少你的网络误差。<br>其他正则化方法：数据扩增（翻转放大扭曲），Early stopping<br><img src="/2024/02/21/2024-02-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/a010227a2cc6a36cbf015fc0bc83e27.png" alt="alt text"><br>动量梯度下降法：比梯度下降好，可以加快梯度下降<br>RMSprop（加速梯度下降）：也能加速梯度下降<br>Adam优化算法：动量梯度和RMSprop结合的算法<br><img src="/2024/02/21/2024-02-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/ce0d06d63e383c15ee6db9aa3b1b148.png" alt="alt text"><br><img src="/2024/02/21/2024-02-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/476fd3605174f664f118b3f82a86573.png" alt="alt text"><br><img src="/2024/02/21/2024-02-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/337674dc404dcb514d2029aef421e44.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>神经网络与深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.22_学习日记</title>
    <url>/2024/02/22/2024-02-22-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：雨<br>学习地点：外面<br>学习时长：3h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>深度学习<br>如果你认为存在数据不匹配问题，我建议你做错误分析，或者看看训练集，或者看看开发集，试图找出，试图了解这两个数据分布到底有什么不同，然后看看是否有办法收集更多看起来像开发集的数据作训练。我们谈到其中一种办法是人工数据合成，人工数据合成确实有效。在语音识别中。我已经看到人工数据合成显著提升了已经非常好的语音识别系统的表现，所以这是可行的。但当你使用人工数据合成时，一定要谨慎，要记住你有可能从所有可能性的空间只选了很小一部分去模拟数据。</li>
<li>迁移学习<br><img src="/2024/02/22/2024-02-22-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/131baa3135b094b6bd8891dfa78687e.png" alt="alt text"><br><img src="/2024/02/22/2024-02-22-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/30cb5ffa91daf09b5e7a39315bb99a5.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>神经网络与深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.26_学习日记</title>
    <url>/2024/02/26/2024-02-26-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：阴<br>学习地点：学校<br>学习时长：8h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>深度学习<br>看了下RNN算法</li>
<li>字节面试题<br><img src="/2024/02/26/2024-02-26-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/bd704ef373a9808de4d7b18438af220.png" alt="alt text"><br><img src="/2024/02/26/2024-02-26-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/be02b1bba906b53935a9eab7826057a.png" alt="alt text"><br>用线段树解，线段树记得看看，把所有身高排序，分别生成对应身高的排名，然后对其做线段树的更新数据操作。</li>
<li>网易面试题<br><img src="/2024/02/26/2024-02-26-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/4dbfd3bfa944d23f4e0383c0566e045.png" alt="alt text"><br><img src="/2024/02/26/2024-02-26-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/5a97503e00507373579d1c9a316b35c.png" alt="alt text"><br><img src="/2024/02/26/2024-02-26-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/0b3b1559cbb2db8af945c5deced68bd.png" alt="alt text"><br><img src="/2024/02/26/2024-02-26-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3cfe607a4213fa7a4cbc30d0f8a21a4.png" alt="alt text"><br>用djkstra算法，生成一个魔法点和魔法边，如果当前点是魔法点，那接下来只能走实边，如果当前是实点，下面可以走魔法边也可以走实边。</li>
<li>网易面试题<br><img src="/2024/02/26/2024-02-26-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e8555848389c4eda1ab30423ccb012d.png" alt="alt text"><br><img src="/2024/02/26/2024-02-26-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3bdd5bed8cdde8558dbad580f0a0be8.png" alt="alt text"><br><img src="/2024/02/26/2024-02-26-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/4a672cd7fe7915f3b26ea2e8c47763b.png" alt="alt text"><br>并查集方法，反向从最后一个数字开始往前遍历，当该方块为0的时候，finger一下该点，finger函数是把该点变白并且周围所有点union。</li>
<li>lc803打砖块<br>可以详细看一下这个题，也是逆向解并查集。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>神经网络与深度学习</tag>
        <tag>并查集</tag>
        <tag>djkstra</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>2025.02.23_学习日记</title>
    <url>/2024/02/23/2024-02-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：雨<br>学习地点：学校<br>学习时长：6h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>深度学习<br><img src="/2024/02/23/2024-02-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/06220b2ffe0d2f9d8dfac62dc2c2f00.png" alt="alt text"><br>valid卷积和same卷积：valid卷积会改变大小，越来越小，same卷积就是padding，往四周填充，最后矩阵大小不变。<br>最大池化：选最大值放入输出层。最大池化只是计算神经网络某一层的静态属性。<br><img src="/2024/02/23/2024-02-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/30c76ce78a2192b8f6f5821f5a60dd7.png" alt="alt text"><br>第一，池化层和最大池化层没有参数；第二卷积层的参数相对较少，前面课上我们提到过，其实许多参数都存在于神经网络的全连接层。观察可发现，随着神经网络的加深，激活值尺寸会逐渐变小，如果激活值尺寸下降太快，也会影响神经网络性能。示例中，激活值尺寸在第一层为6000，然后减少到1600，慢慢减少到84，最后输出softmax结果。我们发现，许多卷积网络都具有这些属性，模式上也相似。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>神经网络与深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.27_学习日记</title>
    <url>/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：10h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>深度学习<br>GRU的优点是这是个更加简单的模型，所以更容易创建一个更大的网络，而且它只有两个门，在计算性上也运行得更快，然后它可以扩大模型的规模。但是LSTM更加强大和灵活，因为它有三个门而不是两个。如果你想选一个使用，我认为LSTM在历史进程上是个更优先的选择，所以如果你必须选一个，我感觉今天大部分的人还是会把LSTM作为默认的选择来尝试。虽然我认为最近几年GRU获得了很多支持，而且我感觉越来越多的团队也正在使用GRU，因为它更加简单，而且还效果还不错，它更容易适应规模更加大的问题。</li>
<li>机器学习<br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/adaa751a98a120eda4dbd3ad0075a23.png" alt="alt text"><br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/fb03d8e7b863edd8c3c3a4779d301e9.png" alt="alt text"><br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b9274a894a87bbbf54f70e4aa142691.png" alt="alt text"><br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/dc0cb0186b3f2287ebf85300394cdf1.png" alt="alt text"><br>神经网络是典型的不需要增加特征数目就能完成非线性分类问题的模型。<br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/15f7377af81a3e6c5f5ff4b02881f39.png" alt="alt text"><br>什么时候采用大规模的数据集呢，一定要保证模型拥有足够的参数（线索），对于线性回归&#x2F;逻辑回归来说，就是具备足够多的特征，而对于神经网络来说，就是更多的隐层单元。这样，足够多的特征避免了高偏差（欠拟合）问题，而足够大数据集避免了多特征容易引起的高方差（过拟合）问题。<br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/484626b8efc5129cf71a94c40fc4252.png" alt="alt text"><br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/35b9c15e56cfba084c0b51c8893ab6d.png" alt="alt text"></li>
<li><a href="https://www.bilibili.com/video/BV1kQ4y1h7ok?p=18&spm_id_from=pageDriver&vd_source=d980f353cbdc64ff6011544e1f205261">有序表</a><br>AWS、阿里云里找5-6个热门项目，再找开源对应产品，最后自己编业务。</li>
<li>括号题<br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/379738fd5dd8d99f17bb5ce1c3bbd0a.png" alt="alt text"><br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/1206a7d5c2144759c64fbd3957f3a99.png" alt="alt text"><br>看要添加多少括号，就是看左边添加多少左括号，右边添加多少右括号，用一个cnt变量从左往右遍历，左括号+1，右括号-1，如果cnt&#x3D;0遇到右括号，res+1，res代表添加左括号的量，最后还剩的cnt肯定大于等于0，如果为正，代表左括号多，就需要cnt个右括号补满，所以最后返回的是res+cnt。</li>
<li>去重数字对<br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/1d2d9183c45e39f5713ad52792b1d15.png" alt="alt text"><br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/8cd8a9552fa744b46fc0ef02da59c38.png" alt="alt text"><br>哈希表统计所有数字，然后遍历哈希表，如果哈希表的数字+k也在哈希表内就返回该数字对。</li>
<li>magic操作<br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c7f7b6ae9ccd8b45899ce7c51b46268.png" alt="alt text"><br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/62bd1771e70c0198e46d6cd2bc11a64.png" alt="alt text"><br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c9c6d6513f21fe67faa368061213912.png" alt="alt text"><br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3e63efee774568513abee836365c75d.png" alt="alt text"><br>先求出两个的和以及平均值，如果平均值相等，返回0，平均值不相等，把大的转给小的才行，转的区间只能是平均值相差范围内的，把多的排序，把平均值小的数组放进hashset里，把满足条件的cur从大平均值的去除，更新size，小的数组加上，更新size。ops+&#x3D;1.</li>
<li>有效括号<br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2d0eca8b30d1bed5e0d5ae6f1d47037.png" alt="alt text"><br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/f25ec0f3426398b228878fd694a3355.png" alt="alt text"><br>生成一个dp数组，dp代表以当前位置结束时，最多有多少有效括号，最后返回最大值就行。当前位置的值如果是（，那就是0，如果是），当前位置的最大值依赖前一个位置的dp值，前一个位置的dp值如果为4，那就看往前第五个位置，是不是左括号，如果是左括号，那就至少为6，2+4，然后还要再加上pre前一个位置的值，因为前面可能还有有效的括号。如果pre位置是），那就直接返回0，没有讨论的必要，因为如果是），前面还有左括号，那么前一个位置的值就不会是4。</li>
<li>从大到小的栈<br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9afc339b631cb1975bce3534ebd6bd6.png" alt="alt text"><br>有一个辅助栈，还有个原始栈，原始栈里弹出数字到辅助栈，然后原始栈继续弹，如果小于辅助栈的栈顶元素，就直接放进去，如果大于，那辅助栈的元素弹进原始栈，然后继续比较下面的数字，直到该元素小于辅助栈顶元素为止，放入辅助栈，接下来继续弹出，直到全部放进辅助栈，最后把辅助栈的全部弹进原始栈就生成了从大到小的栈。</li>
<li>动态规划题<br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/40da81a470a55b822eb0b60a46dd224.png" alt="alt text"><br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e33cf85536451c728aa12d08d4c11e2.png" alt="alt text"><br>当前位置选或者不选的问题，从左往右的尝试模型，如果当前位置是0，返回0，如果当前位置到终点，返回1，然后如果下一个位置是终点，就返回只能选当前位置的递归值，如果下一个位置不是，那就返回只选当前位置的结果和选当前位置和下一个位置的共同的结果，前提是这两个值小于27，最后还能通过动态规划防范简化。</li>
<li>二叉树最大权值和<br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3547dc99e605688da97f257f953af77.png" alt="alt text"><br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/42d292e8234ca9e36076d6dbba91d41.png" alt="alt text"><br>basecase先写出来，当左右孩子都没有的时候，返回当前值。然后找左右孩子的最大值递归值，返回头节点加上该值即可。</li>
<li>算法题<br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/82b6c861fbf85c63f283ae39bec4ed8.png" alt="alt text"><br>从右上角开始遍历，如果当前数大于aim，那下面的可以不用看了，往左走，然后如果小于aim，那左边可以不用看了，往下走，然后循环这样，直到找到为止。<br>还有个题就是一个matrix，左边都是0，右边都是1，怎么找到行里1最多的行，也是从右上角出发，看这一行有多少1，直到0停下，然后往下走，如果是0，就继续往下走，如果是1，看往左走可以不，如果可以就更新res的行，不能往左走就append这一行，最后一直更新。</li>
<li>字节题<br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/f67f9e552d3ea17d59c4bc0dae95931.png" alt="alt text"><br>process方法表示前面都相等时，到当前位置还能不能继续选，核心思想是limit值从第一位开始看，如果arr里有值相等的话，就选该值，然后看后面一位，如果arr没有值相等，但有一个小于接近它的值，那就选该值，后面的值全选最大值即可，如果arr的值全比当前值大，就返回-1，上一级的值如果能往下降，那就降到更小的这个值，然后后面全选最大的，如果上一级的值不能往下降，那就继续向前返回-1.然后主函数里看process能不能做到，如果返回的ans！&#x3D;-1，那就返回ans，如果&#x3D;&#x3D;-1，那就证明第一个值都不能满足，那就位数减少一位，然后全选最大值。代码可以再看看<a href="https://www.bilibili.com/video/BV1DT411s7hp?p=42&vd_source=d980f353cbdc64ff6011544e1f205261">视频</a>。</li>
<li>京东题<br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/306861c43b8defdefdc39cb7d5420ee.png" alt="alt text"><br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c593d138376d5b8da037b0dc1e78d8f.png" alt="alt text"><br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/716603e31afccaa358e622ec4af7d39.png" alt="alt text"><br><img src="/2024/02/27/2024-02-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/31599fc283c2a32460736f91bbae78e.png" alt="alt text"><br>首先，当len长度&#x3D;&#x3D;k的时候，即前面已经收集到了k个，后面怎么删也没用了，所以返回最大值，如果len不到k，当index到达总长度的时候，就表示到总长度了还没有k个值，所以返回删除0个数字，最后一种情况就是没到k并且还有数字的情况，这个时候cur可以保留可以删除，但是当cur小于len或者cur大于len+1的时候，不用删除，保留就行，不会影响，因为1-k都还没有完全拼出来，但是如果cur&#x3D;&#x3D;len+1的时候，就可以保留也可以删除，此时选择递归两者的最小值即可。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>神经网络与深度学习</tag>
        <tag>动态规划</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.28_学习日记</title>
    <url>/2024/02/28/2024-02-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：雨<br>学习地点：学校<br>学习时长：10h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>机器学习<br>K-means聚类方法：<br><img src="/2024/02/28/2024-02-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e35b46357dd967815d26af23f048cc8.png" alt="alt text"><br>二分 K-Means 不急于一来就随机 K KK 个聚类中心，而是首先把所有点归为一个簇，然后将该簇一分为二。计算各个所得簇的失真函数（即误差），选择误差最大的簇再进行划分（即最大程度地减少误差），重复该过程直至达到期望的簇数目。虽然二分 K-Means 能带来全局最优解，但是我们也可以看到，该算法是一个贪心算法，因此计算量不小。<br>CA，Principle Component Analysis，即主成分分析法，是特征降维的最常用手段。顾名思义，PCA 能从冗余特征中提取主要成分，在不太损失模型质量的情况下，提升了模型训练速度。把高纬度降到低纬度。<br><img src="/2024/02/28/2024-02-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/0f4ea456ef2dd9c7a89eaba69828d47.png" alt="alt text"></li>
<li>LC517<br><img src="/2024/02/28/2024-02-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/08a4e0b252ecfe1a54616864dd98976.png" alt="alt text"><br>这个题的思路是，先计算出每个洗衣机平均需要多少衣服，然后遍历数组，当前位置左边和右边分别需要多少衣服，或者需要给两边多少衣服，如果左右两边都需要衣服，那就更新ans&#x3D;左右两边衣服数量相加和ans的最大值，如果两边都大于0，或者有一边大于0，那就等于左右两边值的最大值和ans最大值，不要忘记每次要更新左边的和。</li>
<li>螺旋遍历二维数组<br><img src="/2024/02/28/2024-02-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/318b270640d9074af7ace283f20a96d.png" alt="alt text"><br>把左上右下两个角标记出来，最后螺旋完以后会出现两种情况，一种是还剩一行，一种是还剩一列，这两种分别打印完就行，核心思想是先遍历上面，再右边，再下面，再左边，每次打印到倒数第二个值就行，用currow和curcol去遍历，然后遍历完一圈后，左上右下两个角要动一下，直到while条件结束为止，这个题一定要看是否越界！！</li>
<li>lc48旋转图像<br><img src="/2024/02/28/2024-02-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/1c128066d1b51979511b889596c164c.png" alt="alt text"><br>跟上面这个题类似，先打印外圈再打印内圈，打印外圈的时候，把它们分为不同组，每个边框取一个位置变成一个组，然后有多少组就循环多少次，每一次直接换位置就行，然后主函数里把对角线两个点的位置信息要更新，while循环也要注意条件。</li>
<li>小根堆解法<br><img src="/2024/02/28/2024-02-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/5ccff5b15b37387514e7e39f4de0bfd.png" alt="alt text"><br>用一个容量为k的小根堆，遍历整个数组放进哈希表里，然后把哈希表所有数字放进小根堆比较它是否比小根堆堆顶大，如果更大，那就弹出堆顶，然后放进去，最后就能生成topK。</li>
<li>lc3<br><img src="/2024/02/28/2024-02-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/6ae177b3ee8e8d0756ce7e57a70a633.png" alt="alt text"><br>看到这种子串、子数组之类的题，就想到以当前位置结尾，最长子串长度是多少，然后生成一个数组，返回这个数组最大值即可。每到一个位置，就可以想当前位置的值能不能由前一个位置的值得到。当前位置的数字上一次出现的位置，还有前一个位置的值.用一个哈希表记录每个位置的字符上次出现的位置，每到一个位置，看这个位置的字符在不在哈希表里，不在的话p1&#x3D;i+1，在的话就p1&#x3D;i-前一个位置哈希值，p2&#x3D;pre+1，pre的意思就是前一个位置的字符的p值，pre要一直更新，从第一个位置往后一直更新，pre每次要更新成cur，hash表上一次当前位置的值也要更新成当前的i位置。</li>
<li>lc494<br><img src="/2024/02/28/2024-02-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/ba7271321d1f0d4caaa07b5fdcb7ca4.png" alt="alt text"><br><img src="/2024/02/28/2024-02-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/fcb53a6782ef09d274fd888585f11c3.png" alt="alt text"><br>最简单的方法就是用一个函数，变量为index和rest值，当index到arr长度时，如果rest为0，就返回1。最后返回当前值为正和为负的递归值。更好的办法是有几个优化点，首先sum如果小于target，返回0。其次如果target和sum奇偶性不同返回0，否则返回能凑出t+sum&#x2F;2的方法数，这个是数学推导出来的。记得考虑target是否为复数。<br><img src="/2024/02/28/2024-02-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/bd132d74e25ddf1ac5e26cbc7aa0ffd.png" alt="alt text"><br>好好看看这段代码。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>动态规划</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.02.29_学习日记</title>
    <url>/2024/02/29/2024-02-29-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：雨<br>学习地点：学校<br>学习时长：10h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>机器学习在管理学上的应用<br>生成有价值的信息，比如生成性格特质，大五人格模型的特质，作为自变量。可以做一个验证实验，来预测该机器学习方法能不能很好预测生成特质的信息。<br>预测。添加一些机器学习生成的特质到模型里去，对比原模型和新模型的预测能力差别。<br>因果推断，略。<br>机器学习的研究方法主要就是生成一些特征，下一步需要弄清楚怎么生成特征。<br>《管理者短视主义影响企业长期投资吗？——基于文本分析和机器学习》文章中用机器学习方法生成了管理者是否短视这个特征。通过别的论文的种子词汇，然后用word2vec扩展相似词，然后看所有词词频占所有词词频比例，得到一个指标用来衡量管理者是否短视。<br><img src="/2024/02/29/2024-02-29-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b8ae0c0417982b74f4a10d1537c6c9c.png" alt="alt text"><br><img src="/2024/02/29/2024-02-29-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/eba4100acf3c4d74aeb0bc96248c3ca.png" alt="alt text"><br>《数字化转型、竞争战略选择与…于机器学习与文本分析的证据》这篇文章也用相似方法生成企业竞争战略指标，通过数字化转型的不同层面统计词频然后生成数字化转型的指标。</li>
<li>lc32<br><img src="/2024/02/29/2024-02-29-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9b4e168791c20762fc7facb0ccaf026.png" alt="alt text"><br>这个题跟最长子串子数组一样，就是用一个dp数组，算以当前为结尾最长括号的个数，最后返回max（dp）即可，如果当前为），前一个为（，那就返回dp【i-2】+当前括号2.如果前一个是），那前面就一定有一段有效长度，i-dp【i-1】-1位置上如果是（，那就看i-dp【i-1】-2位置，如果存在那就加上这个位置的dp值，再加2，如果不存在，那就是上一个位置+2。<br>还有栈的方法，from collections import deque，返回栈顶元素是deque【-1】。核心思想先放入-1入栈，因为如果一开始是（进去，如果弹出左括号，返回i-栈顶元素应该是2，所以最开始的值放-1进去。如果左括号入栈，右括号就弹出栈顶元素并且i-新栈顶元素，如果弹出后栈为空，那就把右括号入栈。最后返回最大值。</li>
<li>栈队列互相实现<br>栈实现队列：用两个栈，一个push栈，一个pop栈，用户输入123，要返回123，先把123放入push栈，如果pop栈没东西，就把push栈全部放入pop栈，pop栈就是321，然后再从pop栈里弹出就是队列方法输入123。<br>队列实现栈：两个队列，先放入123，输出也会是123，但是如果要pop的话，就把12弹出到另一个队列里，然后弹出剩下的3就能实现栈的pop方法。<br>图的宽度优先遍历只能用队列实现，图的深度优先遍历只能用栈来做，但是栈和队列可以互相改。</li>
<li>接雨水lc42<br>有一个新的解法，就是双指针，左右两边分别生成最大值，如果当前位置大于左右两边值的最小值，那就为0，并且更新最大值，指针相应移动，如果小于，ans就加上差值，最后返回ans。</li>
<li>洗咖啡杯问题<br>首先用一个小根堆把（开始泡咖啡时间，泡咖啡需要的时间）按照这两个值之和排序，遍历数组，每次弹出小根堆堆顶，并且更新开始泡咖啡时间，然后重新放入小根堆，用一个tmp数组，记录每个人泡完的时间，最后生成数组。该数组再用动态规划思想，basecase就是当index&#x3D;&#x3D;数组长度时，返回min（max（洗杯子时间，tmp【index】）+洗杯子的时间a，蒸发时间b+tmp【index】），然后wash&#x3D;max（洗杯子时间，tmp【index】）+洗杯子的时间a），即什么时候洗完杯子，next1&#x3D;递归（index+1，wash），p1&#x3D;这两种情况的最大值。dry&#x3D;蒸发时间b+tmp【index】，next2&#x3D;递归（index+1，washline即初始wash时间），p2&#x3D;这两种情况最大值，最后返回min（p1，p2）.<br><img src="/2024/02/29/2024-02-29-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/74ec0cd93abc5ba45612300692461ea.png" alt="alt text"><br><img src="/2024/02/29/2024-02-29-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/0515f52b83ab408ad1eacccf70b92a7.png" alt="alt text"></li>
<li>算法题<br><img src="/2024/02/29/2024-02-29-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2d63dad964ce3f032763843a17bd5a2.png" alt="alt text"><br><img src="/2024/02/29/2024-02-29-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2d6adc887f9fc48fcb3c3e86e0ea1cf.png" alt="alt text"><br><img src="/2024/02/29/2024-02-29-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/99780ee90f40afb02736ce17633ab3c.png" alt="alt text"><br>先分成两组，如果长度是奇数，返回0.然后递归动态规划，index到长度，返回0。还剩下司机的话，如果长度-index刚好等于rest，那就只能等分到A组，如果index到长度了，rest还有，那就只能分到B组，递归就行。如果都可以去，那就分别递归，返回最大值即可。</li>
<li>lc135分发糖果<br><img src="/2024/02/29/2024-02-29-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/6e61d1319c96967f42916ec3d055e03.png" alt="alt text"><br>之前做过，就是两个数组，left数组表示如果右边值比左边大就+1，否则就&#x3D;1，right就是相反，最后返回两个数组最大值的和即可。</li>
<li>lc97<br><img src="/2024/02/29/2024-02-29-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/50e3f199debb395cfdb237af6349c12.png" alt="alt text"><br>这个题不能用双指针，因为如果字符一样就没法判断总字符串来自哪里，只能用动态规划，样本对应模型，dp表表示当s1用i个数字，s2用j个数字，能否凑出s3的i+j个字符，第一行和第一列就是如果当前位置能否完全由s1或者s2前n个数字拼凑出来，当遇到不能拼出来的时候，后面就全是False，其他位置的依赖是，ij位置的值等于如果s3当前位置等于s1位置，并且i-1j位置为True，或者等于s2位置时，ij-1位置为True，那就返回tRUE,最后返回dp【-1】【-1】。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>动态规划</tag>
        <tag>双指针</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.01_学习日记</title>
    <url>/2024/03/01/2024-03-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：雨<br>学习地点：学校<br>学习时长：5h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>机器学习在管理学上的应用<br>《“放管服”改革与纳税人满意度:施策重点与优化路径——基于机器学习方法》，这篇文章用了随机森林模型对问卷的特征重要性进行排名。<br>《高管个人特征与公司业绩———基于机器学习的经验证据》，这篇文章用boosting回归树对模型进行预测，用前一年数据训练，后一年数据检验，叫做一年滚动窗口期的拟合结构，然后对比rmse等数据，看添加了一些特征后的模型是不是有更好的表现，同时对比其他机器学习方法看boosting回归树是不是有更好的拟合效果。然后还对特征重要性进行排名，看高管特征对公司业绩重要性高不高。还选了高重要性的特征单独拿出来看和公司业绩的依赖图。</li>
<li>lc lcr155<br><img src="/2024/03/01/2024-03-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/be7f70c42f59a86b61456514b6a882b.png" alt="alt text"><br>搜索二叉树的中序遍历就能生成有序数组，所以这个题就用中序遍历，然后把打印部分替换成自己想要的操作，这个题中的操作就是把每次遍历到的cur的left指针指向pre，把pre的right指针指向cur，当pre不存在的时候，把head设成cur表示是有序数组的head节点，每次操作部分还需要将pre替换成cur，下一次cur到下一个位置时，pre才能更新。最后还需要把头节点head的左指针指向pre，把pre的right指针指向head，此时pre在最后一个位置。</li>
<li>self的用法<br>self是全局变量，放在函数外面，然后函数内部想用这个变量就加self，还有用其他函数的时候也要加self。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.02_学习日记</title>
    <url>/2024/03/02/2024-03-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：3h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>腾讯面试题<br><img src="/2024/03/02/2024-03-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/7ec785ab96826e12a9186db3e90ab99.png" alt="alt text"><br><img src="/2024/03/02/2024-03-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/db5b1b3dd333e3b0bc5ff42b2dd0ca5.png" alt="alt text"><br>返回左树的相等头节点数量和右数的数量再加上如果左树和右数一样的话+1，不一样+0。判断左树和右数是不是一样是另一个函数，如果左树和右树只有一个为空，那就false，都为空返回true，如果左节点的值等于右节点，并且左节点左树和右节点左树也要相等递归，右数也一样。</li>
<li>lc编辑距离<br><img src="/2024/03/02/2024-03-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/f95873051911f3bfc436f46a0120468.png" alt="alt text"><br>用动态规划，dp表含义是word1的前i个和word2的前j个变成一样需要的最少代价。当最后一个字符相同，就返回dpi-1，j-1.不同的话，返回dpi-1j-1 +1，这是替换掉最后一个字符的情况。还有删除最后一个字符的情况，如果要删word1的最后一个字符，就返回1+dpi-1j，如果要删2的最后一个字符就返回1+dpij-1，最后返回这三个值的最小值即可。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.03_学习日记</title>
    <url>/2024/03/03/2024-03-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：4h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>lc224<br><img src="/2024/03/03/2024-03-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c655e047698bff24dba24104020d629.png" alt="alt text"><br><img src="/2024/03/03/2024-03-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/cae0ae27e58d5a8bf6ff32191bd28ed.png" alt="alt text"><br>栈是用来存放左括号前面的东西以及左括号前的符号，还要准备一个sign用来看当前num的符号，如果遇到数字，num就更新，遇到+-号，ans更新，num重置到下一个位置的数字，更新为0，sign更新为当前遍历到的符号。如果遇到左括号，把此时的res以及sign添加到栈，然后ans更新为0，sign更新为+，遇到右括号的时候，括号里面的计算完了，就要把当前括号里的和左括号前面的ans计算一下，所以ans里面最后的num*sign+res更新一下，得到ans值，然后乘以stack的pop符号，再加上stack的pop值，num要更新为0，因为当前值计算完了。最后还要继续往后遍历，把最后的num值要加上。</li>
<li>lc11<br><img src="/2024/03/03/2024-03-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e9ef97e4271b5f57cfb4f67602116a9.png" alt="alt text"><br>用一个res记录最大值，用双指针解，如果最左边小于最右边，那res&#x3D;小边*宽度，然后小边往中间移动，为什么这样能更新最大值，因为如果小边往里移动，就算大边的外面有更大的值能更新更大的宽度，但是既然大边已经往里移动了，那大边的外面肯定是有比小边更大的值，这个更大的值往中间移动了就证明这个更大的值有一个更大宽度的res，所以可以这样更新res。</li>
<li>lc20<br><img src="/2024/03/03/2024-03-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/469e4b105a6e03e2f379327b0c409d2.png" alt="alt text"><br>左括号入栈，用哈希表对应左右括号，然后看stack弹出的值能否在哈希表内匹配，如果不能匹配就false，最后返回stack长度是不是等于1，那如果右括号多，stack弹出报错怎么办呢？初始化的时候往stack里放入一个‘？’，哈希表也放一个‘？’：‘？’，如果右括号多的话，stack弹出的元素会和右括号不匹配，这样就提前false了。</li>
<li>lc301<br><img src="/2024/03/03/2024-03-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/350da8ea3ba0e726ede2c9a14095f20.png" alt="alt text"><br>这个题用bfs做很好理解，首先认识filter函数，filter（函数名，筛选对象）就能把对象中符合函数名的子对象筛选出来，然后当删除最小数量个括号以后的答案，如果要生成就可以用bfs来做，第一次先把整个s放进filter，然后删除掉s的每个括号，然后放进nextlevel里再放进filter里，如果有满足条件的，那就返回即可，如果没有就继续删括号，重复这个过程，filter的函数就是判断括号是否有效的函数，就是上面第三题的简化版，用cnt就能判断。还有一个细节就是加入nextlevel的部分应该是item【：i】+item【i+1：】，因为右括号切片是取不到的，还有一个细节是用set可以过滤重复的答案，set只能add不能append。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>双指针</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.04_学习日记</title>
    <url>/2024/03/04/2024-03-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：雨<br>学习地点：学校<br>学习时长：10h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li><a href="https://mp.weixin.qq.com/s/56cI3vcPEoQ3y6WVAqeoaA">情绪词统计</a><br>通过统计积极和消极情绪词的数量，再进行加减乘除操作得到一个词，判断年报公司的情绪。</li>
<li><a href="https://www.bilibili.com/video/BV1rB4y1p7ga/?p=11&spm_id_from=pageDriver">snownlp包做评论分类</a><br>比较新的方法，可以直接用。</li>
<li><a href="https://www.bilibili.com/video/BV1LQ4y1Q7xv/?spm_id_from=333.788&vd_source=d980f353cbdc64ff6011544e1f205261">LdA主题模型</a></li>
<li>lc55<br><img src="/2024/03/04/2024-03-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/cb302d0e08ee760abb4d43315c9027c.png" alt="alt text"><br>这个题很简单，就是看当前位置往后跳能不能跳到终点，当前位置jump+i就是能跳到的最右位置，如果大于max，就更新max值，但是有两个条件完成才能更新max值，第一个是max值要大于等于i，如果小的话，前面的max值到不了i位置，无法往后更新，第二个条件是i+jump要大于max值，如果不大于就不用更新。</li>
<li>lc45跳跃游戏2<br><img src="/2024/03/04/2024-03-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/5fa39b6ddf244aff2c802bedce94e25.png" alt="alt text"><br>这个题是要返回到达终点的最小步数，最小步数用res记录，类似于宽度优先遍历，走一步的最大范围内遍历，遍历下一次走的最大宽度，然后下一次在第二步的范围内继续更新，找最大值，直到nxt大于等于边界就弹出res步数。</li>
<li>lc1306跳跃游戏3<br><img src="/2024/03/04/2024-03-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/fb74b7759a14f553aff7e84865aef25.png" alt="alt text"><br>这个题是i可以往左右跳，看最后能不能跳到值为0的位置，定义一个函数，如果i跳到边界外，返回false，i跳到0，返回true，准备一个set，每次i的位置放进set，如果i跳到set里的位置，就证明重复了，返回false，最后递归左右两个位置。</li>
<li>lc739<br><img src="/2024/03/04/2024-03-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2b52dd1ec1226b670da949ca7f96f79.png" alt="alt text"><br>这个题用单调栈，单调栈的用法就是生成一个栈，并且栈内元素始终是单调的，不满足单调的元素要及时pop掉。这个题就是从后往前遍历，当遇到小的值就添加进栈，并且更新ans数组值，ans值&#x3D;栈顶元素-i。如果遇到更大的值，就把小的值pop掉，然后再放入栈中，最后返回ans数组。</li>
<li>lc554<br><img src="/2024/03/04/2024-03-04-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e39d52ceaedb4d5c3526d80a5feb792.png" alt="alt text"><br>这个题要返回最小穿过的砖块数量，可以想到把每一行的缝隙列统计一下，用哈希表记录一下当前缝隙出现的个数，但注意不能遍历到最后一列，最后一列全都是缝隙，最后返回n-哈希表里value的最大值即可，用defaultdict记录，default设置为0，表示当不存在最大值的时候返回0。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>BFS</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.05_学习日记</title>
    <url>/2024/03/05/2024-03-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：雨<br>学习地点：学校<br>学习时长：8h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>机器学习<br>看了snownlp等方法做情感分析。</li>
<li>媒体情绪传染与分析师乐观偏…学习文本分析方法的经验证据<br>这篇论文可以再看看，学学爬虫怎么爬到百度新闻指定日期指定主题的内容。</li>
<li>lc139<br><img src="/2024/03/05/2024-03-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/973884c5c45164a26f0c354cc6c2761.png" alt="alt text"><br>这个题想到用动态规划，dp表示前i个字符串能不能用子字符表示出来，先遍历字符串，再遍历字符表，如果当前i大于等于word长度，并且i-word长度的值为true，并且这两段字符相等，dp值就true，break出来，到下一个字符，最后返回dp【-1】，这个题要注意切片索引。</li>
<li>lc15<br><img src="/2024/03/05/2024-03-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/8d30c8bd6d1a76eeac77b958c7b6284.png" alt="alt text"><br>这个题要想到首先把nums排序，然后想到有三个指针，但是不能三个指针一起遍历，要先固定一个指针k，从左往右走，遇到相同值跳过，然后定义一个k右边的双指针，一个左往右，一个右往左，遇到相同值跳过（不跳过更快？？），如果三数相加大于0，右指针过大，左移，三数相加小于0，左指针太小，右移，如果等于0，res就添加三个值，i右移，j左移，如果有重复值跳过，当k的值大于0的时候，就break返回res。k遍历的值为n-2，因为右边始终有两个大的值。</li>
<li>基本计算器<br><img src="/2024/03/05/2024-03-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e1e8e9bcc4efedbfb4157e1541b0ddd.png" alt="alt text"><br>这个题跟有括号的不一样，这个题是用到栈，同样也用preop记录前面的符号，当遇到运算符或者终点位置，就证明数字num已经结束了，需要计算，计算完的结果放进栈，如果+，直接放进去，-，放进相反数，*弹出元素再相乘以后放进去，&#x2F;有点复杂，如果栈顶是正数，直接&#x2F;&#x2F;地板除，如果是负数，就&#x2F;，然后转为int值，然后放进去，最后栈内元素相加就行，每次遍历要更新preop和num。之前的基本计算器题目只有加减乘除，但是有括号，要把符号也push进栈，左边是ans和符号，符号记录的是num的符号以及遇到括号时num右边的符号，然后更新res和符号，直到遇到右括号，就把整个括号内的都算完了，然后栈顶弹出两个元素进行运算，然后继续遍历。</li>
<li>岛屿问题<br><img src="/2024/03/05/2024-03-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/fb0eec6002a49237f22c947544c0e28.png" alt="alt text"><br><img src="/2024/03/05/2024-03-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e29234cf2e9d454fb3f56c038df995e.png" alt="alt text"><br>并查集解法，先定义并查集union和find方法，然后遍历整个list，如果当前位置是1，那就看左边和上面是不是也为1，如果是，就union。最后用一个哈希表来遍历整个生成的findfather数组，看有几个father即可。<br><img src="/2024/03/05/2024-03-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/85d38c3fc8922d109854b3a5f3231ba.png" alt="alt text">、<br>dfs解法，设置dfs方法，使用dfs首先让当前字符变为0，然后遍历上下左右四个地方，看是不是也是1，如果是1并且不越界，就继续dfs这个位置。整个算法是遍历整个数组，如果是1，那就dfs，dfs后ans+1，因为每dfs一次，值都会变成0，看一共能遇到多少次1，就是多少个岛屿。</li>
<li>全排列<br><img src="/2024/03/05/2024-03-05-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e20b73a9e5d8e2f6c46e9d8fea9c1fd.png" alt="alt text"><br>回溯算法，用check数组来记录当前位置有没有取过，递归算法就是如果check当前位置为1，那就continue，如果为0，那就用当前位置，check变成1，然后继续递归，递归结束要返回check为0才行，比如1选了，2没选，选了以后就123，但是2已经标记了1，现在想递归132，那2就不能标记为1，所以要复原。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>并查集</tag>
        <tag>DFS</tag>
        <tag>动态规划</tag>
        <tag>双指针</tag>
        <tag>栈</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.06_学习日记</title>
    <url>/2024/03/06/2024-03-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：雨<br>学习地点：学校<br>学习时长：10h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>爬虫<br>爬虫内容需要找到更好的视频资源。</li>
<li>lc402<br><img src="/2024/03/06/2024-03-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/5ce0699debda70eb5630d8cda245900.png" alt="alt text"><br>类似于单调栈的做法，栈内只保留从小到大的顺序，如果遍历到当前元素比栈顶元素更大，那就要弹出栈顶，k-1，然后入栈，最后要把多余元素和初始的0剔除掉，所以用lstrip函数剔除左边的0，用切片剔除后面的元素。</li>
<li>lc316<br><img src="/2024/03/06/2024-03-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e387d805890f6cd7bcfda736d630ee6.png" alt="alt text"><br>跟上一个题一样，用一个栈保留从小到大的字母，同时用一个counter函数记录每个字母出现的个数，每遍历一个，counter当前字母的数量-1，不能让后面的重复字母进栈，所以要用一个set哈希表来记录当前字母是否进栈，如果进set表了，那就不能再进了，但是如果从stack弹出了，这个字符又可以重新进stack了，所以stack弹出以后，set也要discard这个字母，最后返回栈内元素即可。</li>
<li>lc321<br><img src="/2024/03/06/2024-03-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/ebbf5334e2b24714f2eeda898efa0aa.png" alt="alt text"><br>定义两个函数，一个是取出最大值函数，一个是合并两个数组并且按照顺序排。取出最大值函数就跟上面一样，用单调栈的思想，当前位置的值如果大于栈顶元素，栈顶就pop，每个字符都要append进栈，n-k是要丢弃的值长度，每pop一个n-k就要继续-1，直到0为止跳出循环。合并函数就是看谁大，数组比较大小就是比较第一个字符的大小，然后每次把大的数的【0】字符加到res数组里即可。最后返回i从0到k的所有情况，nums1取i个，nums2取k-i个，如果i和k-i都小于数组长度，那就返回这些的最大值。</li>
<li>lc56<br><img src="/2024/03/06/2024-03-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/fd9e0e4808159b0fee3ffbdc580f6e3.png" alt="alt text"><br>这个题是合并一堆区间，首先排序这堆数组，根据数组0位置排序，用sorted(nums, key&#x3D;lambda x:x[0])表示，定义一个judge函数，判断两个数组能否合并成一个数组，判断条件就是看首尾数字的大小有没有交叉。然后主函数就是遍历整个排序数组，res放进第一个小数组，用res的最后一个数组和遍历到的数组比较，类似于单调栈，如果遍历到的能合并就合并，不能合并res就append这个数组，合并的时候直接改res【-1】的后面一个元素即可，两者的最大值。</li>
<li>lc5manacher算法<br><img src="/2024/03/06/2024-03-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3d6b157fb4629f379b5d5b112a54bf9.png" alt="alt text"><br>c和r代表中心和往外扩的最大边界，把所有字符拆中间两边加上#，再初始化一个数组，每个数组的值代表当前位置的最大半径。先初始化一个最小半径，如果i在r外面，最小半径为1，如果i在r里面，最小半径就是r-i和与c对称点的最小半径的最小值，然后再遍历，如果最小半径左右的值相等，最小半径+1，直到不相等为止，然后更新最大边界以及最大半径和最大中心，因为parr【i】循环时多加了1，所以最后切片要注意是从pmax_idx-pmax+2开始切，切到pmax_idx+pmax为止，2为跨度，因为要筛掉#，最后返回str（‘’.join(res)）。</li>
<li>lc332<br><img src="/2024/03/06/2024-03-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/6a71ba9b96f13fce879102345b1c2fb.png" alt="alt text"><br><img src="/2024/03/06/2024-03-06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/fefeab8f9be3ad680d938a1f9e98f3f.png" alt="alt text"><br>一个dp数组就能遍历完，因为dp依赖左边和上面的值，所以dp从做往右填就行，i大于coin的情况就直接用range跳过coin前的部分即可，最后返回最后一个值即可。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>manacher</tag>
        <tag>动态规划</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.07_学习日记</title>
    <url>/2024/03/07/2024-03-07-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：雨<br>学习地点：学校<br>学习时长：7h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>论文<br>可以用年报文本分析法和年报财务数据相结合的方法，我国上市公司自2007年开始实施新会计准则，故而研究样本时间设定为2007—2022年。其一，将银行、证券、保险等金融行业相关上市公司进行剔除；其二，对研究样本时期内有过ST特殊处理、退市等非正常上市状态的公司样本进行剔除；其三，将上市公司IPO所在的当年样本进行剔除；其四，在进行上述样本筛选步骤的基础上保留具有连续三年及以上研究样本的上市公司以提升计量研究效率。此外，为了减缓样本异常值的潜在扰动，对计量检验所涉及的所有连续型变量按1%和99%水平进行缩尾处理。<br><img src="/2024/03/07/2024-03-07-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2b5d2b08c18eb2ef67059a04b719e0f.png" alt="alt text"></li>
<li>爬虫源码，词频统计jieba.py里。<br><img src="/2024/03/07/2024-03-07-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b3065550b07dc3e5f65e8cae568db55.png" alt="alt text"><br>正则表达式，提取年报MD&amp;A部分。</li>
<li>lc322<br><img src="/2024/03/07/2024-03-07-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/532df035159851cc509eac19018ae27.png" alt="alt text"><br>完全背包问题，当前位置取或者不取，取的话是dp[i][rest-coins[i]],不取的话是dp[i+1][rest]，然后对比最大值，初始化的时候全设置成inf，这个题要用动态规划和滚动数组优化。</li>
<li>lc84<br><img src="/2024/03/07/2024-03-07-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b868dfcd2d6ffff90c9b17a0ce5ef63.png" alt="alt text"><br>两个解法。首先想到i位置最大矩形，就是i位置左右两边第一个比它小的位置中间这一段乘以i的高度，所以就是找到每个位置左右两边第一个比当前位置小的值就行，用两个数组，left数组表示当前位置左边第一个比它小的位置，用一个while循环一下就行，right同理，从右往左循环，left左往右，最后用res算出最大值。<br>另一个解法是用单调栈，从左往右每次遇到比栈顶小的值时就用计算要弹出的这个栈顶的res值，栈顶下面的值就是左边界，遍历到的值就是右边界，所以能直接算出res值，然后当前元素入栈，遍历完救能得到最大值。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.08_学习日记</title>
    <url>/2024/03/08/2024-03-08-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：3h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>论文<br>爬虫到指定段落，在3文件夹下面，newest.py文件里。</li>
<li>lc415<br><img src="/2024/03/08/2024-03-08-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/d5c35cceffad3ede43d56e8bb5f9401.png" alt="alt text"><br>双指针，从后往前遍历，不要计算，直接用字符串相加的方式就行。</li>
<li>lc394<br><img src="/2024/03/08/2024-03-08-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/8ff3574729e2e19381f26fe610adc9e.png" alt="alt text"><br>这个题用栈，跟以前计算器的思路不同，他是直接全部进栈，遇到】才停下来，然后统计括号里的词，用str，遇到左括号以后再看前面有没有num，然后str&#x3D;int num * str，弹入栈内，每次循环前str和num要清空，最后返回栈内的，判断一个字符串是不是数字用isdigit。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.09_学习日记</title>
    <url>/2024/03/09/2024-03-09-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：5h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>lc1004<br><img src="/2024/03/09/2024-03-09-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/bec9d99432ad6323736b601d4f369bd.png" alt="alt text"><br>双指针解法，题意换一个思路就是，一个滑动窗口里最多有k个0，如果超过k个0，left指针就右移，如果没超过，right右移，最后返回res即可。</li>
<li>lc22<br><img src="/2024/03/09/2024-03-09-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/dcd983c6e599fdbad3f8f22c0168993.png" alt="alt text"><br>这个题用dfs，跟全排列有点像，如果左边小于右边就return，如果左边和右边都&#x3D;n，res就加上sol，然后分别递归添加（）的情况。</li>
<li>lc45<br><img src="/2024/03/09/2024-03-09-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/cf731d176168aa27cc7791e9e386204.png" alt="alt text"><br>这个题类似于dfs，之前做过，每次跳跃都可以在一个区间内，max生成这个区间的最大值，一直更新这个max值，下次遍历就在上一个区间右边遍历到max位置即可，最后返回res。</li>
<li>lc735<br><img src="/2024/03/09/2024-03-09-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3fa29b579ce849891e530e5be1bf61a.png" alt="alt text"><br>看到这个题想到有些要保留，有些要剔除，想到栈的数据结构，然后分情况讨论，设置一个bool值，如果bool为真就添加，然后想逻辑，如果遍历位置小于0，并且栈内有元素，栈顶大于0并且栈顶大于遍历位置绝对值，那么就pop，然后再看栈顶元素是不是正数，如果是，bool为假，再看栈顶是不是等于遍历位置，如果是，继续pop，最后返回stack。</li>
<li>lc53<br><img src="/2024/03/09/2024-03-09-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/28417202ba93475d81e016303d52a3a.png" alt="alt text"><br>因为数字有正负，所以要考虑加不加前面的数字，cur就是看当前位置数字为尾和不以当前位置为尾的情况的最大值，然后res就是记录整个数组的最大值。</li>
<li>lc451<br><img src="/2024/03/09/2024-03-09-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/288bafb92583099c1b63dd745726c95.png" alt="alt text"><br>两种解法，第一种投机取巧用counter函数生成一个map，然后counter有most_common()函数，可以按照value最大值往下排序，然后打印即可。第二种解法用大根堆，生成一个堆就是heapq.heapify(s),然后往里heapq.heappush值，把counter里的值push进去，push一对（-值，元素），-的意思就是生成大根堆，没有负就是小根堆，然后返回heapq.heappop(堆)【1】用‘’连接起来。</li>
<li>lc3最大不重复子串<br>看到这种子串、子数组之类的题，就想到以当前位置结尾，最长子串长度是多少，然后生成一个数组，返回这个数组最大值即可。每到一个位置，就可以想当前位置的值能不能由前一个位置的值得到。当前位置的数字上一次出现的位置，还有前一个位置的值.用一个哈希表记录每个位置的字符上次出现的位置，每到一个位置，看这个位置的字符在不在哈希表里，不在的话p1&#x3D;i+1，在的话就p1&#x3D;i-前一个位置哈希值，p2&#x3D;pre+1，pre的意思就是前一个位置的字符的能到的最远距离，pre要一直更新，从第一个位置往后一直更新，pre每次要更新成cur，hash表上一次当前位置的值也要更新成当前的i位置。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DFS</tag>
        <tag>动态规划</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.10_学习日记</title>
    <url>/2024/03/10/2024-03-10-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：6h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>论文<br>企业数字化转型与资本市场表现——来自股票流动性的经验证据。<br>这篇文章也是用了词频分析，生成一个企业数字化转型的变量。<br><img src="/2024/03/10/2024-03-10-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2eca599228803902014cb3ebe84d707.png" alt="alt text"><br>数字化发展与服务化转型——来自制造业上市公司的经验证据<br>这个也是用词频分析生成数字化转型的变量，很有参考意义，针对2007-2014年、2015年、2016-2017年上市公司年报，分别将“董事会报告”、“管理层讨论与分析”、“经营情况讨论与分析”部分文本内容提取出来。<br><img src="/2024/03/10/2024-03-10-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/846b8d46d3385920691dfe072df0e95.png" alt="alt text"></li>
<li>lc54<br><img src="/2024/03/10/2024-03-10-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/09ee0bd4be1c34f5c2dce3fcd04fc34.png" alt="alt text"><br>这个题就设置四个边界，l,r,t,b,然后分别依次遍历，每次遍历要更新边界，然后当l&gt;r,t&gt;b的时候就break掉while循环。</li>
<li>lc679<br><img src="/2024/03/10/2024-03-10-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/032a704666fb7587b25c06228842952.png" alt="alt text"><br>这个题就是看一个数组能不能通过运算返回24这个数，核心思路是先合并两个数，再用一个新数组放新数和两个剩下的数，然后递归回溯，递归实现了就返回true，否则递归结束后回溯pop掉该运算方法，选择下一个运算方法。这个题算出来是float，所以判断返回24点要看答案-24的绝对值&lt;1e-6。递归方法是，选两个数，当两个位置不同就生成一个新list然后把剩下的数字放进list，然后遍历不同符号，list添加相应的算术结果，如果是&#x2F;，要看除数是不是0，如果是0要continue，并且要避免重复运算，比如+*两个符号，如果是这两个符号，算一次就行，加个判断当i&gt;j并且为+**的时候就continue，这样就只用算i小于j的情况了。</li>
<li>lc994<br><img src="/2024/03/10/2024-03-10-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/278378e05d9853e6ce799cb4d2b298a.png" alt="alt text"><br>用bfs，bfs用队列，把烂的放进队列，while队列，对每个pop值更新时间和腐烂，放进队列的是（i，j，time），弹出的时候也要对应起来，最后返回时间。</li>
<li>lc400<br><img src="/2024/03/10/2024-03-10-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c5b56763219f48d0945021f928fb981.png" alt="alt text"><br>题目先要看懂，比如第13位，实际是11这个数的第二位，返回1。所以首先要知道这是哪个数，还要知道是这个数的第几位。1位数有9个，2位数有90个所以有2*90个数字，所以就用一个while就能确定这是个几位数，确定好是cur位数以后，再看是cur位数开头的第几个数字，所以要n&#x2F;&#x2F;cur + 10<strong>（cur-1），10</strong>（cur-1）的意思是第cur位数开始前面是第几位，n%cur就是该数字的第几位。最后返回值就是先&#x2F;&#x2F;再%，把后面的数字去掉留idx前面的，最后%10。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.11_学习日记</title>
    <url>/2024/03/11/2024-03-11-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：5h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>做好简历和博客简历部分</li>
<li>lc1345<br><img src="/2024/03/11/2024-03-11-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/aeea5cb53f2f942fe97509efed7dd0a.png" alt="alt text"><br>这个题就是bfs，bfs用队列解决，用一个哈希表记录每个元素对应的下标，方便之后在队列里遍历这些重复值，有一个优化就是每次遍历完当前重复值以后，就把哈希表里的这个重复值删掉，这样下次遍历到重复值位置的时候就不用花时间重复遍历这些了。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>个人简历</title>
    <url>/2024/03/11/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</url>
    <content><![CDATA[<center>肖卓君</center>
<center>17671374134 | jr1767137@163.com | 上海市 | 在读研二 </center>
<center>25岁丨男</center>

<p><strong>教育经历</strong>		<br><strong>同济大学</strong> 企业管理硕士 2022年09月	- 2025年03月<br><strong>西南财经大学</strong> 金融学学士 2017年09月 - 2021年07月</p>
<span id="more"></span>
<p><strong>技能&#x2F;证书及其他</strong><br>技能：数据结构与算法，Python，机器学习，Mysql数据库，博客<br>证书&#x2F;执照：	证券从业资格证<br>个人博客：<a href="https://therleoinn.github.io/">therleoinn.github.io</a>	记录2024年每天学习内容</p>
<p><strong>实践&#x2F;项目经历</strong><br>经管学院-科研助理 2022年09月 - 2024年03月<br>利用机器学习、Python爬虫等工具构建变量指标考察变量间因果关联与预测能力<br>(1).研究内容：基于公司年报文本数据，运用机器学习与文本分析“种子词集+Word2Vec相似词扩充”的方法，构建了企业数字化转型与竞争战略选择指标。(2).研究成果：成功检验企业数字化转型对股票流动性的影响、机制。<br>(1).研究内容：采用机器学习中的Boosting回归树算法，对比RF、XGBoost算法考察了多维度的高管特征与公司业绩之间的关联。(2).研究成果：通过Boosting算法成功验证高管持股比例和年龄与公司业绩的非线性关系以及相对其他算法的稳健性。</p>
<p>国泰君安证券股份有限公司-新能源与电力设备团队实习生 2023年03月 - 2023年09月<br>利用机器学习、神经网络等工具对新能源行业公司股价进行预测<br>协助团队进行新能源行业研究及深度报告撰写，通过LSTM递归神经网络、DCF模型和相对估值法预测全球股票指数以及风力新能源公司股价并给出投资建议，个人也通过预测纳斯达克指数获取超过市场45%正收益。<br>跟踪新型钒电池招投标信息和行业动态，通过机器学习回归算法预测电机招投标价格并估计CF，并通过LSTM预测项目未来月度新订单数量、全球市场需求、市场占有率等指标进行项目投融资分析，配合路演帮助企业融资。</p>
<p><strong>社团和组织经历</strong>			<br>金融学院青年志愿者协会 副会长 2019年09月 - 2020年07月<br>领导与管理：负责管理三个部门，有效与学生会及初高中合作，组织多校活动，提升校际交流。<br>项目策划：成功组织“三下乡”社会服务项目、财经素养与光华创业比赛，覆盖500+人次，促进学生创业精神和财经知识普及。<br>资金管理：协助申请并管理活动基金，确保资源有效利用，提高活动影响力。</p>
<p>金融学院青年志愿者协会 财经素养部部长 2018年09月 - 2019年07月<br>财经类教育推广：在成都共计5所初高中及4个社区实施财经类教育项目，通过普及教育提升组织活动与教学的能力。<br>资金筹集与志愿者管理：在部员的协助下，成功申请各项志愿者基金，用于制作财经类书籍，通过该项目，累计捐赠800本书籍。</p>
]]></content>
      <tags>
        <tag>个人简历</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.12_学习日记</title>
    <url>/2024/03/12/2024-03-12-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：7h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>lc752<br><img src="/2024/03/12/2024-03-12-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/d5001eefc315f8d8447c436686266ad.png" alt="alt text"><br>这个题用bfs做，bfs模板要记住，visited数组，queue的初始化，然后遍历queue，对每一个符合要求的入队列，不符合的continue，最后step+1，还要设置up和down函数。<br><img src="/2024/03/12/2024-03-12-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/1bac84a7a54b124552231e59961e2c1.png" alt="alt text"></li>
<li>lc76<br><img src="/2024/03/12/2024-03-12-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/fe7aa085123ec9cd6f55db48442b72e.png" alt="alt text"><br>滑动窗口解决，滑动窗口模板要记住，不满足条件r一直往右，满足了l就左移找到最小的，然后判断能不能更新最小值，最后l右移重新开始移动r。need表记录需要哪些数字以及个数，needcnt记录t还需要多少个字母。<br><img src="/2024/03/12/2024-03-12-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/cc2c2e0bdeadee2bc886837ad17418a.png" alt="alt text"></li>
<li>lc567<br><img src="/2024/03/12/2024-03-12-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c2996733e9827b1b946064fa74f7ac7.png" alt="alt text"><br>这个题也是滑动窗口，是一个固定长度的滑动窗口，一个cnt记录target词频，一个need记录需要多少个字母，然后滑动窗口，最后判断need是不是为0，滑动的时候要注意条件判断，看left和right在不在cnt内，不在cnt内就不用管。<br><img src="/2024/03/12/2024-03-12-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2ddc8a2cbabe2c8554ab226647fc3dc.png" alt="alt text"></li>
<li>lc438<br><img src="/2024/03/12/2024-03-12-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/5d9ea8a694e03d97c2ceba95c43fb87.png" alt="alt text"><br>跟上个题一样，就是加个res数组返回第一个值。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.13_学习日记</title>
    <url>/2024/03/13/2024-03-13-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：6h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>lc121<br><img src="/2024/03/13/2024-03-13-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/4d2337291ea9d5277fd908974f019ff.png" alt="alt text"><br>这个题只有一次买卖机会，所以遍历一次找到前面的最小值，最小值就用一个变量记录，同时记录ans，每次遍历到一个位置都更新ans，最后返回ans即可。</li>
<li>lc122<br><img src="/2024/03/13/2024-03-13-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/26baf9df4b65164693c0f6423fe7b1a.png" alt="alt text"><br>这个题就是从左往右遍历，因为可以买完马上卖，所以当i- i-1 大于0的时候，profit+&#x3D;tmp，每次有上涨的时候都买就行了。</li>
<li>lc123<br><img src="/2024/03/13/2024-03-13-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/bbbc4fdc165c81b6eb7204d3f3f8c62.png" alt="alt text"><br>这个题用<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/solutions/2199035/yi-tao-mo-ban-ji-xing-dai-ma-bi-zhao-yan-0ap8/">动态规划</a>，前面的题都可以用动态规划，当天的dp值取决于前一天的值，再看看代码，dp的含义就是当前第i天第一次买，第一次卖，第二次买，第二次卖。<br><img src="/2024/03/13/2024-03-13-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/4b2b6dcc19086e2a65de79b9882535b.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.14_学习日记</title>
    <url>/2024/03/14/2024-03-14-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：8h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>lc198<br><img src="/2024/03/14/2024-03-14-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/206fdceece426f63aeedabe0a818fef.png" alt="alt text"><br>这个题就是当前dp值&#x3D; 偷n-2个，第n-1个不偷，偷当前 + 偷前n-1个，当天不偷，用两个变量就能滚动起来，最后返回最后的值。</li>
<li>lc213<br><img src="/2024/03/14/2024-03-14-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/d731502f74b2d1f591708ebac143ce3.png" alt="alt text"><br>这个题就是有一个条件，首尾不能同时偷，所以就看前n-1个和后n-1个谁更大。<br><img src="/2024/03/14/2024-03-14-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/581db3e3afd36dc765ebbec39eefd0f.png" alt="alt text"></li>
<li>lc337<br><img src="/2024/03/14/2024-03-14-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/128d9a4f158b3e54b8067518163f91a.png" alt="alt text"><br>这个题用递归，递归返回两个值，一个值是选根节点，一个不选。然后分别递归左边和右边，选根节点的时候是左边不选+右边不选+根值，不选根节点是左边选或者不选的最大值+右边最大值，最后dfs（root）</li>
<li>lc18<br><img src="/2024/03/14/2024-03-14-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/320c42fde41b99361525c8176e3cc0d.png" alt="alt text"><br>四个数相加，首先看两数相加，就是左右指针，往中间移动。三数相加就是固定一个位置，剩下位置满不满足两数相加。四数相加就是先固定一个位置，然后筛掉一些条件，比如当前值+后面连续三个值如果大于target，就可以break了，或者+最后三个值小于t，也可以break。然后固定第二个数，同理，再进行两数之和左右指针即可。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.15_学习日记</title>
    <url>/2024/03/15/2024-03-15-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：12h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>pytorch学了导入数据集</li>
<li>lc416<br><img src="/2024/03/15/2024-03-15-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/d23a78fd5253a06bc41d8c0609dcadb.png" alt="alt text"><br>这个题用动态规划做，dpij的含义是取前i个值的和能不能&#x3D;j，返回bool值。如果当前值要大于j-numi，那么就不能选当前值，dpij&#x3D;dpi-1,j，否则，就看是选或者不选的情况，dpij&#x3D;dpi-1,j | dpi-1,j-num[i-1]，因为numi-1就是第i个值。然后动态压缩要注意，0-1背包问题，动态压缩要注意逆序，因为ij依赖上面和左上方的值，如果正序遍历的话，那么左上方的值会先被计算出来，覆盖掉原本需要的左上方的值，所以要逆序。</li>
<li>lc518<br><img src="/2024/03/15/2024-03-15-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/54014f4e567f246388f87b59892e8a1.png" alt="alt text"><br>动态规划，这个题是完全背包，不用倒叙。<br><img src="/2024/03/15/2024-03-15-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/81168cffc0e4293da0b7efa2887754a.png" alt="alt text"></li>
<li>lc72编辑距离<br>前面做过很多次了，动态规划，考虑最后一个字符是不是相等，相等的话，就看dp[i-1][j-1],不相等就看让前面i-1或者j-1个相等，然后删掉最后一个字符，或者前面变成一样，最后一个替换，三个的最小值。</li>
<li>lc312<br><img src="/2024/03/15/2024-03-15-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/6a278cd70879cd0d95c0ce811d70c6e.png" alt="alt text"><br>这个题动态规划，要往左右两边加1，这个题dp含义是ij之内，打破气球得到的最大值，不包括ij，所以两边加1，这样dp[0][n+1]就是满足题意。然后当i大于等于j就不满足题意，为0。然后对每一个ij，最后一个选择都是扎破最后一个气球，所以逆向思维就是最后一个扎破i到j的任意一个返回值，最后选最大的。所以dp[i][j] &#x3D; max(dp[i][j], dp[i][k]+dp[k][j]+nums[k]*nums[i]*nums[j]).<br><img src="/2024/03/15/2024-03-15-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e221e281c538db440d2629724dafb00.png" alt="alt text"></li>
<li>算法题<br><img src="/2024/03/15/2024-03-15-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/546c5012adb9d616af04ed769505103.png" alt="alt text"><br>看当前字符，如果相等dpij&#x3D;dp[i-1][j-1]+1,不相等就等于两个分别少一个的最大值。<br><img src="/2024/03/15/2024-03-15-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/249e0e4eb4f9fd88cf6f670d7644b8d.png" alt="alt text"></li>
<li>算法题<br><img src="/2024/03/15/2024-03-15-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/4c767a3e95827258fb8933900cfb285.png" alt="alt text"><br>dp含义就是ij范围内回文子串最大长度，当ij相等就是i+1j-1dp值+2，不相等就是看要i或者要j的dp值哪个更大，初始化就是ij相等时候返回1。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Pytorch</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.17_学习日记</title>
    <url>/2024/03/17/2024-03-17-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：8h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>pytorch学了目标检测以及基本的代码，卷积池化激活全连接。</li>
<li>lc10<br><img src="/2024/03/17/2024-03-17-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/ced81df18a36f7214c4cc7b7b745866.png" alt="alt text"><br>这个题用动态规划来做，dp含义是s的前i个和p的前j个字符是否能匹配。然后看最后一个字符是不是‘*’,如果是就是三个情况，不是就是两个情况。<br><img src="/2024/03/17/2024-03-17-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/38bfd82718d7810e190006faa32ea0a.png" alt="alt text"><br><img src="/2024/03/17/2024-03-17-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/712d40ff75538d542f98e895d76abd6.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Pytorch</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.18_学习日记</title>
    <url>/2024/03/18/2024-03-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：8h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>KMP<br>KMP用一个next数组，next数组记录前一个位置的前后缀相等的长度，0位置是-1，1位置是0，后面就依次根据前面得出。具体看视频。</li>
<li>lc452<br><img src="/2024/03/18/2024-03-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/97b91c7992583598798108048346e96.png" alt="alt text"><br><img src="/2024/03/18/2024-03-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/06323bae41c980c350b0fecb3c9cf13.png" alt="alt text"><br>这个题就是看交集，先排序，按照第一个数字排序，start,end表示交集的两边，每次更新交集就行，遍历的时候如果左边的边大于end，那么start,end就变成遍历到的那个区间，并且res+1，否则，更新区间，左边界&#x3D;原始左边界和遍历到位置的左边界的最大值，右边&#x3D;原始右边界和遍历到位置的右边界的最小值，最后res还要+1，因为最后一个区间还没加上。</li>
<li>lc886<br><img src="/2024/03/18/2024-03-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/8c1b0b442e51ce2f3119ab1a56270cb.png" alt="alt text"><br>这个题用并查集，并查集模板记住，一个find，一个union。然后初始化p数组，每个p的值就是本身，然后设置g数组defaultdict(list)，对每个dislike的数组都分别把g对应的加上，表示每个位置对应的不喜欢的人。然后遍历所有位置，并且看每个位置的不喜欢的值遍历一下，看其父亲节点是不是相等，相等就false，然后对每个j的父节点的父节点设成对应数组里的g【i】【0】的父节点。</li>
<li>优先级队列（从小到大排序，插入和删除都可以重新排序）<br><img src="/2024/03/18/2024-03-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/850265dd7dd26643a78bc47abdbee21.png" alt="alt text"></li>
<li><a href="https://leetcode.cn/problems/smallest-k-lcci/solutions/402287/python38chong-ji-chu-pai-xu-suan-fa-shi-jian-bu-fe/">所有排序</a></li>
<li>大顶堆<br><img src="/2024/03/18/2024-03-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/a939890a9b327d881c5ba795a9107a0.png" alt="alt text"><br>py只能实现heapq的小顶堆，大顶堆可以取相反数放进去heapify，然后当遇到比堆顶大的数，实际是比堆顶小的数，那就弹出堆顶，最后返回res。<br><img src="/2024/03/18/2024-03-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b338d8cb897d5a6c69f909d4e3c4e8e.png" alt="alt text"></li>
<li>搜索二叉树<br><img src="/2024/03/18/2024-03-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e060679e68d93197223c50cab8c9608.png" alt="alt text"><br><img src="/2024/03/18/2024-03-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/ed089d71a25948090569a479de0afaa.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Pytorch</tag>
        <tag>并查集</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.19_学习日记</title>
    <url>/2024/03/19/2024-03-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：8h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>lc450<br><img src="/2024/03/19/2024-03-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9866d5258ea77563eaeaf60e09fbaa1.png" alt="alt text"><br><img src="/2024/03/19/2024-03-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/0f345f13c9366121d7066a7f3ff25ae.png" alt="alt text"><br><img src="/2024/03/19/2024-03-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/50d39569205185f1d6708f3ac11703b.png" alt="alt text"><br>删除一个节点以后，关键的是要用右子树的最小值或者左子树的最大值来替换当前节点，同时递归删除对应子树的节点。</li>
<li>滑动窗口<br><img src="/2024/03/19/2024-03-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/aba2d914bcbec953bcaf88794043974.png" alt="alt text"><br>该算法的核心思想是利用双端队列维持当前滑动窗口内的最大值。队列的首部始终保存当前窗口的最大值的索引，而队列本身保持递减顺序。这样每次滑动窗口移动时，只需要比较新进入窗口的元素与队尾元素；如果更大，则弹出队尾元素，直到该条件不满足为止，然后将新元素加入队列。同时，检查队首元素是否已经不在窗口内，如果是，则将其从队首移除。这种方法的时间复杂度为 O(n)，因为每个元素最多被压入和弹出队列一次。<br><img src="/2024/03/19/2024-03-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/351beb133549052ac42d0bceec280c2.png" alt="alt text"></li>
<li>解数独<br><img src="/2024/03/19/2024-03-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/85fdf31d78cee1f1f9af37c623444f6.png" alt="alt text"><br><img src="/2024/03/19/2024-03-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/4db96c329aee72ca081f3a7f34d0155.png" alt="alt text"><br><img src="/2024/03/19/2024-03-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/d29b23498837a5b632f21d0092b157b.png" alt="alt text"><br>这段代码实现了一个典型的回溯算法来解决数独问题。它首先遍历每个空白位置（用.表示），然后尝试填充数字1到9，每次填充后都会递归地尝试解决剩下的数独。如果在某个位置上所有数字都不能导致一个有效解决方案，算法会回溯到之前的状态，尝试下一个数字。这个过程一直持续，直到找到有效解决方案或确定数独无解。</li>
<li>汉明重量<br><img src="/2024/03/19/2024-03-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e5ce87adcf46f2057a7e955bc28d570.png" alt="alt text"><br><img src="/2024/03/19/2024-03-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/a71e5162feb8521b408d7a795b70ae8.png" alt="alt text"><br>删掉最后一个1就是n&amp;&#x3D;n-1。二进制表达方式就是bin(8)</li>
<li>煎饼排序<br><img src="/2024/03/19/2024-03-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9ea531a7f2c9b0945d7b87619e0eddd.png" alt="alt text"><br><img src="/2024/03/19/2024-03-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/5ec30bd7542137cd413cfd8da4daeb9.png" alt="alt text"><br>煎饼排序的基本思想是在每一步找到未排序部分的最大元素，并通过最多两次翻转操作将其移动到未排序部分的末尾。</li>
<li>和为k的数组<br><img src="/2024/03/19/2024-03-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/4127b2d9d0b6d676eeb6c56b9946249.png" alt="alt text"><br><img src="/2024/03/19/2024-03-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/73ed612967c39fbe4648e573cef2112.png" alt="alt text"><br>遍历数组，计算每个位置的前缀和，并使用字典 dic 记录每个前缀和出现的次数。在遍历过程中，如果存在前缀和为 pre - k 的子数组，说明存在一个和为 k 的子数组，因此更新计数器 count。最后返回 count 即可得到满足条件的子数组数量。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>前缀和</tag>
        <tag>回溯算法</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.20_学习日记</title>
    <url>/2024/03/20/2024-03-20-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：8h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>字符串相乘<br><img src="/2024/03/20/2024-03-20-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/4e5557428c297d030e79ed544a27187.png" alt="alt text"><br><img src="/2024/03/20/2024-03-20-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/a4b36773373131519fe28cfe5ca3acc.png" alt="alt text"><br>map函数第一个是函数，第二个是目标，map(str, res)就是把res所有内容全部执行str函数。</li>
<li>着色问题<br><img src="/2024/03/20/2024-03-20-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/0e6ca55c64ad9f2910f6a49463a89ee.png" alt="alt text"><br><img src="/2024/03/20/2024-03-20-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/1a658fdcaecf6d0d65aca0d8473c353.png" alt="alt text"><br>低阶岛屿问题，bfs，dfs都能做，bfs就是遍历四个方向，遍历完同时放进队列里。</li>
<li>区间交集<br><img src="/2024/03/20/2024-03-20-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/6aedf9ff9c18c6941dd4a3bada79b8a.png" alt="alt text"><br><img src="/2024/03/20/2024-03-20-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/60f47d4804415f09cd0125a07789bd1.png" alt="alt text"><br>使用了两个指针 i 和 j 分别遍历两个区间列表，通过比较当前两个区间的起始点和结束点，判断它们是否相交，如果相交则计算交集的起始点和结束点，并将其加入结果列表中。在每次比较后，根据两个区间的结束点的大小关系移动相应的指针。最后返回计算得到的交集区间列表。</li>
<li>滑动谜题<br><img src="/2024/03/20/2024-03-20-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/d1a58986d1967a226fc3f5c96b57d87.png" alt="alt text"><br><img src="/2024/03/20/2024-03-20-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/bc7c48b5850f9aae3ac8bd48027dc2c.png" alt="alt text"><br><img src="/2024/03/20/2024-03-20-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/7de60578a61bf27c62e4fe9fc234fcf.png" alt="alt text"><br>BFS经典套路，其实就是把字符串变成123450，找到初始的0位置然后bfs到相邻的位置，step+1，用队列，每次还要判断是否visited过。</li>
<li>二分问题<br><img src="/2024/03/20/2024-03-20-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/7585993f1de8029aad2ca02cef91cef.png" alt="alt text"><br><img src="/2024/03/20/2024-03-20-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2ef4b9020fdd34e2d89515d5578f95c.png" alt="alt text"><br>二分问题，记住一种，while l &lt; r, 那么下面l就要更新为mid-1，或者r更新为mid，这是死的，返回最小速度，就返回l。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.21_学习日记</title>
    <url>/2024/03/21/2024-03-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：5h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>二分题目<br><img src="/2024/03/21/2024-03-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/50864656a9742a38f3946b682f1fbab.png" alt="alt text"><br><img src="/2024/03/21/2024-03-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/11361806e4e5da21779b14f7a74b372.png" alt="alt text"><br>记住位运算优先级很低，所以记得加括号。</li>
<li>接雨水问题<br><img src="/2024/03/21/2024-03-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/486b119ee94fe7cea15b5967b8d3bd5.png" alt="alt text"><br>使用了左右两个指针从两边向中间扫描，根据左右两侧的最大高度来决定当前位置能接多少雨水。它利用了这样一个事实：在任意位置，能接的雨水量由两边最高的较小者决定。因此，通过移动左右指针并更新左右最大高度，可以逐步计算出所有位置能接的雨水总量。</li>
<li>删除重复值，链表和数组都可以用<br><img src="/2024/03/21/2024-03-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b18fa86b93587ca1f9701b068aa49fe.png" alt="alt text"><br><img src="/2024/03/21/2024-03-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/35fc9a4cc68dd4ccfcfe7f634bc669d.png" alt="alt text"></li>
<li>反转k链表<br><img src="/2024/03/21/2024-03-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/543ab0e6f7285033a0c48f9ba246f80.png" alt="alt text"><br><img src="/2024/03/21/2024-03-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/1069f43f9e18adb21b773d1ca10fdbc.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.23_学习日记</title>
    <url>/2024/03/23/2024-03-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：5h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>XGboost和GBDT的区别<br><img src="/2024/03/23/2024-03-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c2d349c8037fb8103d9dc14493db81b.png" alt="alt text"><br>XGBT代码在XGBOOST文件夹里。</li>
<li>二分算法<br><img src="/2024/03/23/2024-03-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/4f890d56e0352abee308282f6aecbb4.png" alt="alt text"><br><img src="/2024/03/23/2024-03-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/88e186daf667dad752462d161cc51a7.png" alt="alt text"><br>lower_bound 函数是实现了二分查找的下界算法，用于在有序列表中找到第一个大于等于目标值的元素的索引。</li>
<li>移动0到最后<br><img src="/2024/03/23/2024-03-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/1785d3d0eee02bed1895bd5a645ae4f.png" alt="alt text"><br><img src="/2024/03/23/2024-03-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/aeeb377cf0d8294f5ccb99855c5d978.png" alt="alt text"></li>
<li>双指针<br><img src="/2024/03/23/2024-03-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/7679ca5d7aef648f9b6dd78af70772b.png" alt="alt text"><br><img src="/2024/03/23/2024-03-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2b3ab35a6b0811a9f5c0762fe7af872.png" alt="alt text"><br><img src="/2024/03/23/2024-03-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c63156ab8982111c5fc1648de0f40d3.png" alt="alt text"></li>
<li>双指针、前缀和二分解法<br><img src="/2024/03/23/2024-03-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/a81c7c073a075522f4b08b429297d0f.png" alt="alt text"><br><img src="/2024/03/23/2024-03-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3520eb829f7db6b00557db02320df85.png" alt="alt text"><br>滑动窗口解法，比较简单<br><img src="/2024/03/23/2024-03-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/dbf1bc935cafbbf7b4c8723407271a7.png" alt="alt text"><br>使用前缀和数组 sums 来快速计算任意子数组的和，并通过二分查找来确定满足条件的子数组的左右边界，从而找到长度最小的满足条件的子数组。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
        <tag>前缀和</tag>
        <tag>滑动窗口</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.24_学习日记</title>
    <url>/2024/03/24/2024-03-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：5h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>双指针<br><img src="/2024/03/24/2024-03-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/151d124945edd54896350ab08901d32.png" alt="alt text"><br><img src="/2024/03/24/2024-03-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/6aea9f49bfa18ea9a4ef93232ed7d4d.png" alt="alt text"><br>使用两个指针i和j表示当前考虑的子数组的左右边界。使用哈希表hashmap记录当前窗口内每种水果的数量。使用cnt记录当前窗口内包含的不同水果的种类数。当cnt超过2时，通过移动左指针i来缩小窗口，直到窗口内再次包含最多两种水果为止。在每一步中，如果当前窗口满足条件（即，最多包含两种水果），则更新最大子数组长度res。</li>
<li>双指针<br><img src="/2024/03/24/2024-03-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/8088b9c5516440d551556cca348a360.png" alt="alt text"><br><img src="/2024/03/24/2024-03-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b2bed4e04dca52eed51b48241b6a9b7.png" alt="alt text"><br><img src="/2024/03/24/2024-03-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/11146b2b571cb81998a6e86bf7d8787.png" alt="alt text"><br>通过维护两个指针来实现滑动窗口，其中 i 和 j 分别表示左右指针。在移动右指针的过程中，不断更新需要匹配的字符的哈希表 needMap 和需要匹配的字符数量 needCnt，并在满足条件时，尽可能地压缩左边界 i，以找到最小的满足条件的窗口，并更新结果字符串 res。</li>
<li>算法题<br><img src="/2024/03/24/2024-03-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/614238cbda19055c2ecb8ef238f71fb.png" alt="alt text"><br><img src="/2024/03/24/2024-03-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2688ce899952ab97f1cd74a7e0dd5fd.png" alt="alt text"><br>纯coding，没什么技巧，要分清楚边界问题。<br><img src="/2024/03/24/2024-03-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/4b4232fd705845a6bdaa0f01238a8fd.png" alt="alt text"><br>这是另一个螺旋数组的解法，只要求顺时针打印，通过四个循环遍历的方式，依次遍历了螺旋矩阵的上、右、下、左四个边界，每次遍历完一个边界后，更新相应的边界指针，并判断是否需要终止遍历。最终返回结果列表 res 即为螺旋遍历的顺序。</li>
<li>数组题总结<br>数组题主要就是二分、双指针、滑动窗口。</li>
<li>翻转任意两个链表<br><img src="/2024/03/24/2024-03-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/84591492520a4d68c08fd06d3b1cd88.png" alt="alt text"><br><img src="/2024/03/24/2024-03-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/d624eb1a9a8c70856bb409331609f54.png" alt="alt text"></li>
<li>快慢指针<br><img src="/2024/03/24/2024-03-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/4af3d36893f173978a8229295e21f5f.png" alt="alt text"><br>快指针先走n+1步，因为快指针走到空，慢指针要走到删除位置的前一个。</li>
<li>链表相交<br><img src="/2024/03/24/2024-03-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/40a3919aff385c8320dff7c85e1c2bc.png" alt="alt text"><br><img src="/2024/03/24/2024-03-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/332efe6be18d7927c7a17d03fd80818.png" alt="alt text"></li>
<li>环形链表<br><img src="/2024/03/24/2024-03-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/6490ba64536521e26800eee693489d8.png" alt="alt text"><br>数学方法，快慢指针然后都变成慢指针。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
        <tag>二分法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.25_学习日记</title>
    <url>/2024/03/25/2024-03-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：10h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>哈希表<br><img src="/2024/03/25/2024-03-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/851dd6f91adbc5b153c25bb6e81b459.png" alt="alt text"></li>
<li>快乐数<br><img src="/2024/03/25/2024-03-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9853f76000621c77984a7ff8ca3cded.png" alt="alt text"><br>想求数字的每一个值可以把数字转化成字符串再遍历</li>
<li>四数相加<br><img src="/2024/03/25/2024-03-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/48fdc023c5e5a365be989740994c2b7.png" alt="alt text"></li>
<li>四数之和&#x3D;target<br>这个题记得注意剪枝和continue以及break的使用。</li>
<li>KMP lc28题<br><img src="/2024/03/25/2024-03-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/92f2736b449f12b90893cd22843ae49.png" alt="alt text"><br><img src="/2024/03/25/2024-03-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/7c93e520eca8984836d17ff1531e443.png" alt="alt text"></li>
<li>KMP题<br><img src="/2024/03/25/2024-03-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/a374b2f9cea5589d289c6f3340e3fda.png" alt="alt text"><br>(n % (n - kmplist[-1]) &#x3D;&#x3D; 0): 这部分判断是判断字符串的长度能否被重复子串的长度整除。n 是字符串 s 的长度，(n - kmplist[-1]) 表示重复子串的长度，因为 KMP 算法的 kmplist[-1] 表示了字符串 s 中重复子串的长度。如果 n 能够被 (n - kmplist[-1]) 整除，说明存在重复子串。</li>
<li>双指针<br><img src="/2024/03/25/2024-03-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/1434b0f6d5fcb1ea8b560724fa0c981.png" alt="alt text"></li>
<li>栈<br><img src="/2024/03/25/2024-03-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/66428ba91d034ca42ddb84f5a19c73d.png" alt="alt text"><br>try和except的用法注意。一般概率比较大的时候用try。</li>
<li>双端队列经典题<br><img src="/2024/03/25/2024-03-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/47d7a02e4d8b6ddd46be6bd43e50156.png" alt="alt text"><br>这种方法的关键在于双端队列的使用，它保持了一个有效的递减序列。队列的头部总是当前窗口最大值的索引，每次窗口滑动时，只需查看队列头部的索引对应的值即可。这样可以在O(n)的时间复杂度内解决问题，其中n是数组的长度。</li>
<li>小根堆<br><img src="/2024/03/25/2024-03-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/58a5054e9b2116b551e4b8da51e7c26.png" alt="alt text"><br>详细看看堆的用法。注意堆的heapreplace和heappush用法。</li>
<li>二叉树的迭代遍历<br><img src="/2024/03/25/2024-03-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2c6e0bb6123e346022e18cfe8963d1f.png" alt="alt text"><br><img src="/2024/03/25/2024-03-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b8a54d755a38bbb95791e535f30fb17.png" alt="alt text"><br><img src="/2024/03/25/2024-03-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/403e2819937781b78ee369c666a87c6.png" alt="alt text"></li>
<li>二叉树的层序遍历<br><img src="/2024/03/25/2024-03-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c2dadf818e764a48e50504bbb308eed.png" alt="alt text"><br>打印从右往左看的所有节点就是用层序遍历，遍历每一层，如果遍历到最右边，就把该节点放到res中。</li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>KMP</tag>
        <tag>双指针</tag>
        <tag>栈</tag>
        <tag>哈希表</tag>
        <tag>队列</tag>
        <tag>二叉树</tag>
        <tag>小根堆</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.26_学习日记</title>
    <url>/2024/03/26/2024-03-26-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：5h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>二叉树迭代<br><img src="/2024/03/26/2024-03-26-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/80ed6c6ffa8cfe197961407156fd9d8.png" alt="alt text"></li>
<li>二叉树众数<br><img src="/2024/03/26/2024-03-26-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/91a02ac260e776d894159bd5ad16a0f.png" alt="alt text"><br>注意self的用法还有一些细节。</li>
<li>二叉树题目<br><img src="/2024/03/26/2024-03-26-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/0454ecae0504a9393f1238ebeb77abc.png" alt="alt text"></li>
<li>二叉树题目<br><img src="/2024/03/26/2024-03-26-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3e8183f223ecd4828ce4456e5f8ba45.png" alt="alt text"></li>
<li>二叉树插入<br><img src="/2024/03/26/2024-03-26-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/00959224c911fefb1abe1d1d71a78fb.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.27_学习日记</title>
    <url>/2024/03/27/2024-03-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：7h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>删除二叉树节点<br><img src="/2024/03/27/2024-03-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/ebb6d1ecb6e19fac6532e93d136e3d9.png" alt="alt text"><br>如果左右节点都有，那删掉root节点的时候，就要把左边的节点放到右节点最左边的那个节点的左边才行，才满足BST。</li>
<li>累加树<br><img src="/2024/03/27/2024-03-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/0fd3c2ad455bb7e547023849e783a40.png" alt="alt text"><br>用一个全局变量来记录当前值要加上的值。</li>
<li>组合问题<br><img src="/2024/03/27/2024-03-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/147c6329415ea592f91e49d991012d2.png" alt="alt text"></li>
<li>组合问题求和<br><img src="/2024/03/27/2024-03-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b095e811af2c99d764d2b3c36c110bd.png" alt="alt text"></li>
<li>组合问题电话<br><img src="/2024/03/27/2024-03-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/d8e60bf5b9ac47ff6b65b96c7994f9d.png" alt="alt text"></li>
<li>组合问题<br><img src="/2024/03/27/2024-03-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/08c1bfc643db70bd17501f67ec5103a.png" alt="alt text"></li>
<li>组合问题<br><img src="/2024/03/27/2024-03-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/62f65574c26159a3e24169420082ae0.png" alt="alt text"></li>
<li>分割回文串<br><img src="/2024/03/27/2024-03-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/6826fda8de54edd016ca648503a3ec2.png" alt="alt text"></li>
<li>子集问题<br><img src="/2024/03/27/2024-03-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/ae24d1b8e7195756fcfcdb44f9c90a3.png" alt="alt text"><br>注意和子集问题的区别</li>
<li>递增子序列<br><img src="/2024/03/27/2024-03-27-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/79b9d686e2dfbe45f72e3db97a262c5.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>回溯算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.28_学习日记</title>
    <url>/2024/03/28/2024-03-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：7h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>全排列<br><img src="/2024/03/28/2024-03-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/61fc5587657157132a8497813be6d9f.png" alt="alt text"></li>
<li>全排列2<br><img src="/2024/03/28/2024-03-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/fc003a2383c8ba9588bb309b6bf7b0c.png" alt="alt text"></li>
<li>N皇后<br><img src="/2024/03/28/2024-03-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/65f09dd105dea457328a7cabbbd666b.png" alt="alt text"></li>
<li>解数独<br><img src="/2024/03/28/2024-03-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/44b5c4fbdf37a6c105e51e0280e145b.png" alt="alt text"></li>
<li>贪心<br><img src="/2024/03/28/2024-03-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/ce6e3f5e72577d8708aaeb739442f38.png" alt="alt text"><br>计算相邻元素之间的差值，然后判断这些差值是否符合摆动序列的定义。如果符合条件，就将摆动序列长度加1。最后返回计算得到的最大摆动序列长度。</li>
<li>贪心<br><img src="/2024/03/28/2024-03-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/14fbb6207363a363b5604c211ee7ed7.png" alt="alt text"></li>
<li>贪心<br><img src="/2024/03/28/2024-03-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/28bbdeb28d562143431969b8f1b215a.png" alt="alt text"></li>
<li>贪心<br><img src="/2024/03/28/2024-03-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/67dc330fe8fa129c7634dcfbe1e1ae7.png" alt="alt text"></li>
<li>贪心<br><img src="/2024/03/28/2024-03-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b06f0d819cfa141f2d31e555f68043e.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>回溯算法</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.29_学习日记</title>
    <url>/2024/03/29/2024-03-29-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：5h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>动态规划<br><img src="/2024/03/29/2024-03-29-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/6bfdc11df00b1cc8c968d8f59dc2eb3.png" alt="alt text"></li>
<li>动态规划<br><img src="/2024/03/29/2024-03-29-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/4dedc7ef3f01ce8c6c2783024e38194.png" alt="alt text"><br>dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。</li>
<li>动态规划<br><img src="/2024/03/29/2024-03-29-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c2a28147a46fbe42c710c4b746df11a.png" alt="alt text"><br>dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]。</li>
<li>动态规划<br><img src="/2024/03/29/2024-03-29-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/984da402fd157f0a9ea1abd73de33ea.png" alt="alt text"></li>
<li>动态规划<br><img src="/2024/03/29/2024-03-29-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3e05a55be76373dfab535f5bc6215c8.png" alt="alt text"></li>
<li>动态规划<br><img src="/2024/03/29/2024-03-29-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3e9ded19d638ae125d37c1d81c2aa8e.png" alt="alt text"></li>
<li>动态规划<br><img src="/2024/03/29/2024-03-29-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/8121662eef99b101f85cb47c44b73d8.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.03.31_学习日记</title>
    <url>/2024/03/31/2024-03-31-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：6h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>复习了一些机器学习算法和动态规划的题</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.04.01_学习日记</title>
    <url>/2024/04/01/2024-04-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：8h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>完全背包<br><img src="/2024/04/01/2024-04-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/d535b273e8edc260572e0077823ace3.png" alt="alt text"></li>
<li>完全背包<br><img src="/2024/04/01/2024-04-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/705308fe43170a5d27b23db7e59c307.png" alt="alt text"><br>这个题记得要排列问题，外层循环是amount，组合问题外层循环是物体。</li>
<li>背包<br><img src="/2024/04/01/2024-04-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e754361e39bbab657943e218ff0b07d.png" alt="alt text"><br>这个题记得初始值设成inf。</li>
<li>完全背包<br><img src="/2024/04/01/2024-04-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3690399e22460445d49da910555feea.png" alt="alt text"></li>
<li>单词拆分<br><img src="/2024/04/01/2024-04-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/030587ae18292526d9cfc8454229b64.png" alt="alt text"></li>
<li>打家劫舍<br><img src="/2024/04/01/2024-04-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2ed9e65b616cabcb11870e249f3b8d9.png" alt="alt text"></li>
<li>树形dp<br><img src="/2024/04/01/2024-04-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/00b9a91d5f79841e7f988728634ae5e.png" alt="alt text"></li>
<li>买卖股票<br><img src="/2024/04/01/2024-04-01-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/ce47c99af4c23432b1b38b76216645b.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.04.02_学习日记</title>
    <url>/2024/04/02/2024-04-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：8h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>买卖股票<br><img src="/2024/04/02/2024-04-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/386990b0b3c21bcfc37f61c2ea6ceb6.png" alt="alt text"></li>
<li>买卖股票有冷冻期<br><img src="/2024/04/02/2024-04-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/36c7a4bd152697bb9243b4da7a720e9.png" alt="alt text"></li>
<li>买卖股票含冷冻期<br><img src="/2024/04/02/2024-04-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/7337909c8c177c48bfa92c699a7bc03.png" alt="alt text"></li>
<li>最长递增子序列<br><img src="/2024/04/02/2024-04-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b15b3c83256bbde148c604cfe2dc997.png" alt="alt text"></li>
<li>最长公共子序列<br><img src="/2024/04/02/2024-04-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/80e5d22f1c3bbe046d9115b303138f1.png" alt="alt text"></li>
<li>最大子数组<br><img src="/2024/04/02/2024-04-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/6a575f2613888f79dd6cd9df9ff130e.png" alt="alt text"></li>
<li>这个题着重看一下<br><img src="/2024/04/02/2024-04-02-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/de8b30a5fdb7ffcdfd7ebf0548e9e80.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.04.03_学习日记</title>
    <url>/2024/04/03/2024-04-03-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：5h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>今天跑了很多数据，用研发占比当作因变量效果会更好。</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.04.08_学习日记</title>
    <url>/2024/04/08/2024-04-08-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：10h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>单调栈<br><img src="/2024/04/08/2024-04-08-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/0cff42586eed5ad27c1bbcf588b16bd.png" alt="alt text"></li>
<li>双指针<br><img src="/2024/04/08/2024-04-08-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b34e9b67a01ca946a718977c55c95d1.png" alt="alt text"></li>
<li>单调栈<br><img src="/2024/04/08/2024-04-08-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/d5c88704d7de13b404610eb323546de.png" alt="alt text"></li>
<li>dfs<br><img src="/2024/04/08/2024-04-08-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/4c2cec0e57a54d76d35dea9235afeeb.png" alt="alt text"></li>
<li>岛屿问题bfs解法<br><img src="/2024/04/08/2024-04-08-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/fa9440a0f2b0a7d51231fc976683b10.png" alt="alt text"></li>
<li>岛屿最大面积BFS解法<br><img src="/2024/04/08/2024-04-08-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/1889bf3a4b626d3a9b9e632810fbef7.png" alt="alt text"></li>
<li>岛屿最大面积DFS解法<br><img src="/2024/04/08/2024-04-08-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/ec41f6b1aabea63135ad256a28aa5af.png" alt="alt text"></li>
<li>飞地数量BFS解法<br><img src="/2024/04/08/2024-04-08-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/57771ddf0b5095fc41748f4e8d2ac9c.png" alt="alt text"></li>
<li>飞地数量DFS解法<br><img src="/2024/04/08/2024-04-08-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/5ea97bf4a7b0f2790425aba8d9227b4.png" alt="alt text"></li>
<li>DFS解法<br><img src="/2024/04/08/2024-04-08-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/aeeb45b99674e47919b71b9585006ea.png" alt="alt text"></li>
<li>BFS解法<br><img src="/2024/04/08/2024-04-08-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/eab70dcd92aca7bc78c479d46ca1a38.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DFS</tag>
        <tag>动态规划</tag>
        <tag>双指针</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.04.09_学习日记</title>
    <url>/2024/04/09/2024-04-09-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：10h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>太平洋大西洋问题DFS解法<br><img src="/2024/04/09/2024-04-09-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/729c40e8a7aa53f5bbfe6c760514e21.png" alt="alt text"></li>
<li>BFS解法<br><img src="/2024/04/09/2024-04-09-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2017b8b56bb25ee372f9fe75e3c2609.png" alt="alt text"></li>
<li>最大人工岛 并查集<br><img src="/2024/04/09/2024-04-09-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/7c6c08d2ebc8316653a844db8088d08.png" alt="alt text"><br><img src="/2024/04/09/2024-04-09-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/030042bb9d0b9eccdf26f545a456ec6.png" alt="alt text"></li>
<li>单词接龙<br><img src="/2024/04/09/2024-04-09-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/1e818638a2c7eb14dcc38bba13ac214.png" alt="alt text"></li>
<li>钥匙问题DFS<br><img src="/2024/04/09/2024-04-09-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/7e55fc5b0b2053f0dce41286a57f453.png" alt="alt text"></li>
<li>钥匙问题BFS<br><img src="/2024/04/09/2024-04-09-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/419ddc01e87acb27c32be05b02715d5.png" alt="alt text"></li>
<li>并查集问题<br><img src="/2024/04/09/2024-04-09-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/5329e4f4f3822a5fc1c8969b3165cb3.png" alt="alt text"></li>
<li>冗余连接<br><img src="/2024/04/09/2024-04-09-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/f34240476cadae94998a8a87e8033d1.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DFS</tag>
        <tag>动态规划</tag>
        <tag>双指针</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.04.10_学习日记</title>
    <url>/2024/04/10/2024-04-10-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：10h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>感冒了，看了一小时论文，明天再学。</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.04.11_学习日记</title>
    <url>/2024/04/11/2024-04-11-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：10h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>往右移动k个元素<br><img src="/2024/04/11/2024-04-11-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/48435a370aef4e6eabb2ea8fdc65513.png" alt="alt text"></li>
<li>二分查找<br><img src="/2024/04/11/2024-04-11-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/ca9901f1f5a6766a105547c59ca128d.png" alt="alt text"></li>
<li>奇偶排序<br><img src="/2024/04/11/2024-04-11-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/1a24f8db998d2885669cb63db69ea4a.png" alt="alt text"></li>
<li>有效ip地址（认真看）<br><img src="/2024/04/11/2024-04-11-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/360c6ad3c821a2eac1ecbc4e258a0a6.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分法</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.04.12_学习日记</title>
    <url>/2024/04/12/2024-04-12-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：10h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>双指针<br><img src="/2024/04/12/2024-04-12-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/abab3980a3f668879bc6b5a91826fd8.png" alt="alt text"></li>
<li>DFS<br><img src="/2024/04/12/2024-04-12-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b6f9f02062241f2afa57778d58b5b74.png" alt="alt text"></li>
<li>搜索二叉树转化为平衡二叉树<br><img src="/2024/04/12/2024-04-12-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2496e7c6a22727a7cd037facc7ab502.png" alt="alt text"></li>
<li>二叉树<br><img src="/2024/04/12/2024-04-12-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/5476ade34f7a63136232a2061f15f2d.png" alt="alt text"></li>
<li>二叉树迭代法<br><img src="/2024/04/12/2024-04-12-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9c2a519d0dfa9d52d57e51e0738de33.png" alt="alt text"></li>
<li>N皇后2<br><img src="/2024/04/12/2024-04-12-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/6652d7cf666eca6525d7aa765d2008a.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分法</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.04.15_学习日记</title>
    <url>/2024/04/15/2024-04-15-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：10h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>动态规划<br><img src="/2024/04/15/2024-04-15-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c8402ac230ecb024251ccefa50a7b7c.png" alt="alt text"></li>
<li>动态规划<br><img src="/2024/04/15/2024-04-15-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/5f8884246b8846f17a4b1c9675409fa.png" alt="alt text"></li>
<li>岛屿周长<br><img src="/2024/04/15/2024-04-15-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/1ea4cc2d0c33e22de3fd70b9555df94.png" alt="alt text"></li>
<li>BFS<br><img src="/2024/04/15/2024-04-15-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e3d5314c0cd20f48c12603ed0e36d68.png" alt="alt text"></li>
<li>排列<br><img src="/2024/04/15/2024-04-15-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/101b6609242433585165f024690d80a.png" alt="alt text"></li>
<li>二进制<br><img src="/2024/04/15/2024-04-15-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/31fbcd752b1363cca112bd970f0c2e8.png" alt="alt text"></li>
<li>哈希表<br><img src="/2024/04/15/2024-04-15-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/777f181b194e5ad129f7add35275ebd.png" alt="alt text"></li>
<li>哈希表<br><img src="/2024/04/15/2024-04-15-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/97a2531ec83be41b33fe787e9578e34.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>动态规划</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.04.16_学习日记</title>
    <url>/2024/04/16/2024-04-16-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：10h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>机考是ACM<br><img src="/2024/04/16/2024-04-16-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/d0138d61d05ebcec2793e9b24477125.png" alt="alt text"><br>如果是要输入多行多个数据，那么就要用split函数去分割input，然后用map函数把数值变为int，再转化为list才能变成一个列表list。最后还要print。如果输入多行就要用while True才行。<br><img src="/2024/04/16/2024-04-16-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/5246be799f46299b8189a4b26064975.png" alt="alt text"><br>第一行是一个数的话直接n&#x3D;int(input()),然后再用try except，里面可以加ifelse，或者用for循环也可以<br><img src="/2024/04/16/2024-04-16-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/230eefa4e1792333d35d7b1a9e4c782.png" alt="alt text"><br>题目说了只有两行就不用while，也不用转换为int类型。</li>
<li>最长回文子串动态规划解法<br><img src="/2024/04/16/2024-04-16-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/eec1da20585bdda207bf60131e1e21f.png" alt="alt text"></li>
<li>计算质数<br><img src="/2024/04/16/2024-04-16-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/fb537038168339046ab35d3b747f8b7.png" alt="alt text"></li>
<li>环形公路<br><img src="/2024/04/16/2024-04-16-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b875233b19c68f555a9f47e30fd0fbc.png" alt="alt text"><br>注意交换xy位置</li>
<li>美团题<br><img src="/2024/04/16/2024-04-16-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/deae7b17588e6fe6b82c9f802677b36.png" alt="alt text"></li>
<li>美团题<br><img src="/2024/04/16/2024-04-16-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/5a5b052ed22db52848d03b3314a1c73.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.04.17_学习日记</title>
    <url>/2024/04/17/2024-04-17-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：10h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>动态规划<br><img src="/2024/04/17/2024-04-17-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/50a37bafb9d0287ed03dc46b0076f58.png" alt="alt text"><br>dp的含义是n个数的数组里有多少个长度为rest满足条件的子序列。</li>
<li>动态规划<br><img src="/2024/04/17/2024-04-17-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b230fd7ba615f8a31f8e756e709765c.png" alt="alt text"></li>
<li>贪心<br><img src="/2024/04/17/2024-04-17-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/fc0fd773952ea45e0915696a0e141e7.png" alt="alt text"></li>
<li>图形题<br><img src="/2024/04/17/2024-04-17-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/a4e6189fe411cc3859e062f83d3ae20.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.04.18_学习日记</title>
    <url>/2024/04/18/2024-04-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：4h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>算法题<br><img src="/2024/04/18/2024-04-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c3f683570993e866f0119ae0f48660e.png" alt="alt text"></li>
<li>算法题<br><img src="/2024/04/18/2024-04-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/f609ba645b911d551b74065024f2595.png" alt="alt text"></li>
<li>算法题<br><img src="/2024/04/18/2024-04-18-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/26481243a97d29d6398252187480cc4.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.04.19_学习日记</title>
    <url>/2024/04/19/2024-04-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：学校<br>学习时长：5h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>算法题<br><img src="/2024/04/19/2024-04-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/76879dabc56d75311d5327c6d3d5a00.png" alt="alt text"></li>
<li>算法题<br><img src="/2024/04/19/2024-04-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/7c9c751c877dc31e0177d08a2bbd781.png" alt="alt text"></li>
<li>算法题<br><img src="/2024/04/19/2024-04-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/1440f0fc81b82980aecbce40a3d10d8.png" alt="alt text"></li>
<li>算法题<br><img src="/2024/04/19/2024-04-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/4414c78315dd92e727d63cb8c477339.png" alt="alt text"></li>
<li>算法题<br><img src="/2024/04/19/2024-04-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c396eb60f9970372d5365115ec61851.png" alt="alt text"></li>
<li>算法题<br><img src="/2024/04/19/2024-04-19-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/fef33e28918a04a909920132824713a.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.04.21_学习日记</title>
    <url>/2024/04/21/2024-04-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：浦东图书馆<br>学习时长：5h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>算法题<br><img src="/2024/04/21/2024-04-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e29d26675fe9a14cdc9b1092dca33ad.png" alt="alt text"></li>
<li>算法题<br><img src="/2024/04/21/2024-04-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b8e901ada4cbb87bb722a3eaa05767e.png" alt="alt text"><br>注意setdefault用法以及设置s以及邻接表的写法</li>
<li>算法题<br><img src="/2024/04/21/2024-04-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9f78b7384da72e636043e3df253bc20.png" alt="alt text"></li>
<li>求导题<br><img src="/2024/04/21/2024-04-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/94057d8cc82e8c057b183e2ee02d223.png" alt="alt text"><br>要考虑边界问题，求导的时候考虑恒大于0的情况。</li>
<li>算法题<br><img src="/2024/04/21/2024-04-21-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/52b4c715e27d977deb4b02d568bbc97.png" alt="alt text"></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.04.22_学习日记</title>
    <url>/2024/04/22/2024-04-22-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：图书馆<br>学习时长：10h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>二叉树树形dp问题（图）<br><img src="/2024/04/22/2024-04-22-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/e07b8ffe9bcbb79140970af46568213.png" alt="alt text"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">cur, pre, s</span>):</span><br><span class="line">    <span class="comment"># 如果当前节点的状态已经计算过，则直接返回结果</span></span><br><span class="line">    <span class="keyword">if</span> dp[cur][s] != -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> dp[cur][s]</span><br><span class="line">    notch = <span class="number">0</span>  <span class="comment"># 记录不选当前节点时的最大价值</span></span><br><span class="line">    <span class="comment"># 遍历当前节点的邻居节点</span></span><br><span class="line">    <span class="keyword">for</span> nx, w <span class="keyword">in</span> nxt[cur]:</span><br><span class="line">        <span class="keyword">if</span> nx != pre:  <span class="comment"># 如果邻居节点不是当前节点的父节点</span></span><br><span class="line">            <span class="comment"># 递归计算不选当前邻居节点时的最大价值，并累加到 notch 中</span></span><br><span class="line">            notch += solve(nx, cur, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 如果当前节点的状态为不选，则直接返回 notch</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> notch</span><br><span class="line">    ch = <span class="number">0</span>  <span class="comment"># 记录当前节点选择时的最大价值</span></span><br><span class="line">    <span class="comment"># 遍历当前节点的邻居节点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nxt[cur])):</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nxt[cur])):</span><br><span class="line">            nx, w = nxt[cur][j]</span><br><span class="line">            <span class="keyword">if</span> nx != pre:  <span class="comment"># 如果邻居节点不是当前节点的父节点</span></span><br><span class="line">                <span class="keyword">if</span> j == i:  <span class="comment"># 如果当前邻居节点是第 i 个</span></span><br><span class="line">                    <span class="comment"># 选择当前邻居节点，并递归计算其不选时的最大价值，累加到 tmp 中，并加上权值 w</span></span><br><span class="line">                    tmp += solve(nx, cur, <span class="number">0</span>) + w</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 不选择当前邻居节点，并递归计算其最大价值，累加到 tmp 中</span></span><br><span class="line">                    tmp += solve(nx, cur, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 更新当前节点选择时的最大价值</span></span><br><span class="line">        ch = <span class="built_in">max</span>(ch,tmp)</span><br><span class="line">    <span class="comment"># 更新动态规划数组中当前节点的状态值为当前节点选择和不选择的最大价值</span></span><br><span class="line">    dp[cur][s] = <span class="built_in">max</span>(ch, notch)</span><br><span class="line">    <span class="keyword">return</span> dp[cur][s]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())  <span class="comment"># 输入节点数量 n</span></span><br><span class="line">    nxt = &#123;i:[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>)&#125;  <span class="comment"># 初始化邻接表，键值从1开始</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">        u, v, w = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())  <span class="comment"># 输入每条边的起点、终点和权值</span></span><br><span class="line">        nxt[u].append((v,w))  <span class="comment"># 将边加入邻接表</span></span><br><span class="line">        nxt[v].append((u,w))  <span class="comment"># 因为是无向图，所以边需要双向加入</span></span><br><span class="line">    dp = [[-<span class="number">1</span>,-<span class="number">1</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]  <span class="comment"># 初始化动态规划数组</span></span><br><span class="line">    <span class="comment"># 调用 solve 函数计算根节点选择时的最大价值，并打印结果</span></span><br><span class="line">    res = solve(<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></li>
<li>数组题<br><img src="/2024/04/22/2024-04-22-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/58c6a4c2653b8ba5ed7475ab966f6bc.png" alt="alt text"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取测试用例数量 t</span></span><br><span class="line">t = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># 遍历每个测试用例</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(t):</span><br><span class="line">    <span class="comment"># 读取整数 a 和字符串 b</span></span><br><span class="line">    a, b = <span class="built_in">input</span>().split()</span><br><span class="line">    a = <span class="built_in">int</span>(a)  <span class="comment"># 将字符串转换为整数</span></span><br><span class="line">    bb = <span class="built_in">int</span>(b)  <span class="comment"># 将字符串转换为整数（这里存在错误，应该是 int(b) 而非 bb）</span></span><br><span class="line">    res = <span class="number">0</span>  <span class="comment"># 初始化结果变量为 0</span></span><br><span class="line">    <span class="comment"># 遍历字符串 b 中的每个字符</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b)):</span><br><span class="line">        res += <span class="built_in">int</span>(b[i]) * a  <span class="comment"># 将每个字符转换为整数并与 a 相乘，然后累加到结果中</span></span><br><span class="line">    <span class="comment"># 输出结果</span></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></li>
<li>算法题<br><img src="/2024/04/22/2024-04-22-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/25913109ac5b8234c35185b0ad4ee15.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取输入的两个字符串 s 和 t</span></span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">t = <span class="built_in">input</span>()</span><br><span class="line"><span class="comment"># 获取字符串 s 和 t 的长度</span></span><br><span class="line">n = <span class="built_in">len</span>(s)</span><br><span class="line">m = <span class="built_in">len</span>(t)</span><br><span class="line"><span class="comment"># 将字符串 s 扩展一倍，以便处理循环匹配的情况</span></span><br><span class="line">s += s[<span class="number">0</span>:n-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 初始化计数器 res 为 0</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="comment"># 遍历字符串 s 中的每个字符</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="comment"># 如果当前字符与 t 的首字符不匹配，跳过当前循环</span></span><br><span class="line">    <span class="keyword">if</span> s[i] != t[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># 如果 s 中从当前位置开始长度为 m 的子串与 t 完全匹配，计数器 res 加 1</span></span><br><span class="line">    <span class="keyword">if</span> s[i:i+m] == t:</span><br><span class="line">        res += <span class="number">1</span></span><br><span class="line"><span class="comment"># 输出匹配次数</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></li>
<li>动态规划<br><img src="/2024/04/22/2024-04-22-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9d9c29fecbcd01f03e58b1d62327873.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())  <span class="comment"># 输入操作次数</span></span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))  <span class="comment"># 输入每个数字的得分</span></span><br><span class="line">s = <span class="built_in">input</span>()  <span class="comment"># 输入数字的颜色标记</span></span><br><span class="line">f = [<span class="number">0</span>] * (n)  <span class="comment"># 创建长度为 n 的数组 f，用于记录每个位置的最大得分</span></span><br><span class="line"><span class="comment"># 开始遍历数字标记 s，从第二个数字开始（下标为 1），直到最后一个数字</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">    f[i] = f[i - <span class="number">1</span>]  <span class="comment"># 将当前位置的得分设置为上一个位置的得分</span></span><br><span class="line">    <span class="comment"># 检查当前数字的颜色标记与前一个数字的颜色标记是否相同</span></span><br><span class="line">    <span class="keyword">if</span> s[i] != s[i - <span class="number">1</span>]:</span><br><span class="line">        <span class="comment"># 如果不同，则可以进行标记操作，更新当前位置的得分</span></span><br><span class="line">        f[i] = <span class="built_in">max</span>(f[i], f[i - <span class="number">2</span>] + a[i] + a[i - <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 输出数组 f 的最后一个元素，即小红最多能获得的分数</span></span><br><span class="line"><span class="built_in">print</span>(f[n - <span class="number">1</span>])</span><br></pre></td></tr></table></figure></li>
<li>算法题<br><img src="/2024/04/22/2024-04-22-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c1419eb188c1866ae853769b51343d1.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取操作次数</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># 初始化得分数组，长度为9，下标0-7对应位置得分，下标8保留</span></span><br><span class="line">res = [<span class="number">0</span>] * <span class="number">9</span></span><br><span class="line"><span class="comment"># 循环处理每次操作</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="comment"># 读取操作的角度和位置</span></span><br><span class="line">    a, b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="comment"># 获取当前位置及相邻位置的得分</span></span><br><span class="line">    c, d, e = res[b-<span class="number">1</span>:b+<span class="number">2</span>]</span><br><span class="line">    <span class="comment"># 根据操作角度和位置更新得分数组</span></span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">0</span>:  <span class="comment"># 操作角度为0度</span></span><br><span class="line">        x = <span class="built_in">max</span>(c, d)</span><br><span class="line">        res[b-<span class="number">1</span>] = x + <span class="number">3</span></span><br><span class="line">        res[b] = x + <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> a == <span class="number">90</span>:  <span class="comment"># 操作角度为90度</span></span><br><span class="line">        x = <span class="built_in">max</span>(c+<span class="number">1</span>, d, e)</span><br><span class="line">        res[b-<span class="number">1</span>] = res[b] = res[b+<span class="number">1</span>] = x + <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> a == <span class="number">180</span>:  <span class="comment"># 操作角度为180度</span></span><br><span class="line">        x = <span class="built_in">max</span>(c+<span class="number">1</span>, d+<span class="number">3</span>)</span><br><span class="line">        res[b-<span class="number">1</span>] = res[b] = x</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 其他角度</span></span><br><span class="line">        x = <span class="built_in">max</span>(c, d, e)</span><br><span class="line">        res[b-<span class="number">1</span>] = res[b] = x + <span class="number">1</span></span><br><span class="line">        res[b+<span class="number">1</span>] = x + <span class="number">2</span></span><br><span class="line"><span class="comment"># 输出前8个位置的得分</span></span><br><span class="line"><span class="built_in">print</span>(*res[<span class="number">0</span>:<span class="number">8</span>])</span><br></pre></td></tr></table></figure></li>
<li>双指针<br><img src="/2024/04/22/2024-04-22-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/31ced9654c90e1da1465ae9867e0906.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个函数，计算字符种类在 [1, x] 之间的子串数量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span>:  <span class="comment"># 如果 x 为 0，则直接返回 0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    left = <span class="number">0</span>  <span class="comment"># 左指针初始化为 0</span></span><br><span class="line">    right = <span class="number">0</span>  <span class="comment"># 右指针初始化为 0</span></span><br><span class="line">    hash_set = [<span class="number">0</span>] * <span class="number">26</span>  <span class="comment"># 哈希集合用于记录每个字符出现的次数，初始全为 0</span></span><br><span class="line">    kinds = <span class="number">0</span>  <span class="comment"># 字符种类数初始化为 0</span></span><br><span class="line">    ans = <span class="number">0</span>  <span class="comment"># 结果初始化为 0</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; n:  <span class="comment"># 右指针小于字符串长度时循环</span></span><br><span class="line">        <span class="keyword">if</span> hash_set[<span class="built_in">ord</span>(s[right]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] == <span class="number">0</span>:  <span class="comment"># 如果当前字符之前未出现过</span></span><br><span class="line">            kinds += <span class="number">1</span>  <span class="comment"># 字符种类数加 1</span></span><br><span class="line">        hash_set[<span class="built_in">ord</span>(s[right]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span>  <span class="comment"># 记录当前字符出现的次数</span></span><br><span class="line">        <span class="keyword">while</span> kinds &gt; x:  <span class="comment"># 当字符种类数大于 x 时</span></span><br><span class="line">            <span class="keyword">if</span> hash_set[<span class="built_in">ord</span>(s[left]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] == <span class="number">1</span>:  <span class="comment"># 如果左指针所指字符只出现过一次</span></span><br><span class="line">                kinds -= <span class="number">1</span>  <span class="comment"># 字符种类数减 1</span></span><br><span class="line">            hash_set[<span class="built_in">ord</span>(s[left]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span>  <span class="comment"># 左指针右移，更新字符出现次数</span></span><br><span class="line">            left += <span class="number">1</span>  <span class="comment"># 左指针右移</span></span><br><span class="line">        ans += right - left + <span class="number">1</span>  <span class="comment"># 更新结果</span></span><br><span class="line">        right += <span class="number">1</span>  <span class="comment"># 右指针右移</span></span><br><span class="line">    <span class="keyword">return</span> ans  <span class="comment"># 返回结果</span></span><br><span class="line"><span class="comment"># 主函数</span></span><br><span class="line">n, l, r = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())  <span class="comment"># 读取输入，n 为字符串长度，l 和 r 为字符种类数范围</span></span><br><span class="line">s = <span class="built_in">input</span>()  <span class="comment"># 读取字符串</span></span><br><span class="line"><span class="comment"># 调用函数计算结果并输出</span></span><br><span class="line"><span class="built_in">print</span>(find(r) - find(l - <span class="number">1</span>))  <span class="comment"># 计算字符种类在 [l, r] 之间的子串数量并输出</span></span><br></pre></td></tr></table></figure></li>
<li>算法题<br><img src="/2024/04/22/2024-04-22-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/94a1af2a416d59d2756186c976450b0.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取操作数 n</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># 分别用于存储不同类型的操作数的列表</span></span><br><span class="line">a, b, c = [], [], []</span><br><span class="line"><span class="comment"># 循环读取每个操作</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    op, num = <span class="built_in">input</span>().strip().split()</span><br><span class="line">    num = <span class="built_in">int</span>(num)</span><br><span class="line">    <span class="comment"># 根据操作类型将操作数添加到相应的列表中</span></span><br><span class="line">    <span class="keyword">if</span> op[<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">        a.append(num)</span><br><span class="line">    <span class="keyword">elif</span> op[<span class="number">0</span>] == <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">        b.append(num)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        c.append(num)   </span><br><span class="line"><span class="comment"># 将三个列表组成的列表按照列表长度进行排序，从小到大</span></span><br><span class="line">arr = [a, b, c]</span><br><span class="line">arr.sort(key=<span class="keyword">lambda</span> x: <span class="built_in">len</span>(x))</span><br><span class="line"><span class="comment"># 初始化结果变量 res</span></span><br><span class="line">res = <span class="number">0</span>   </span><br><span class="line"><span class="comment"># 分别获取排序后的列表中的三个子列表 a, b, c</span></span><br><span class="line">a, b, c = arr</span><br><span class="line"><span class="comment"># 判断条件：如果 a 和 b 的长度之和小于等于 c 的长度</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(a) + <span class="built_in">len</span>(b) &lt;= <span class="built_in">len</span>(c):</span><br><span class="line">    <span class="comment"># 计算需要剔除的 c 中的部分，并加到结果 res 中</span></span><br><span class="line">    k = <span class="built_in">len</span>(c) - (<span class="built_in">len</span>(a) + <span class="built_in">len</span>(b))</span><br><span class="line">    c.sort()</span><br><span class="line">    res += <span class="built_in">sum</span>(c[:k])</span><br><span class="line">    <span class="comment"># 将 a, b, 剩余的 c 合并并排序</span></span><br><span class="line">    tmp = a + b + c[k:]</span><br><span class="line">    tmp.sort()</span><br><span class="line">    <span class="comment"># 将列表 tmp 分成两半，并将前半部分加到结果 res 中</span></span><br><span class="line">    k = (<span class="built_in">len</span>(tmp)+<span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    res += <span class="built_in">sum</span>(tmp[:k]) + <span class="built_in">sum</span>(tmp[k:]) * <span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 如果 a 和 b 的长度之和大于 c 的长度</span></span><br><span class="line">    <span class="comment"># 合并三个列表并排序</span></span><br><span class="line">    tmp = a + b + c</span><br><span class="line">    tmp.sort()</span><br><span class="line">    <span class="comment"># 计算分割位置 k</span></span><br><span class="line">    k = (n + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 将列表 tmp 分成两部分，并将前半部分加到结果 res 中</span></span><br><span class="line">    res += <span class="built_in">sum</span>(tmp[:k]) + <span class="built_in">sum</span>(tmp[k:]) * <span class="number">2</span></span><br><span class="line"><span class="comment"># 输出结果 res</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>双指针</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.04.23_学习日记</title>
    <url>/2024/04/23/2024-04-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：图书馆<br>学习时长：10h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>双指针<br><img src="/2024/04/23/2024-04-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/9d2e7ba60054027d1f26bf97fb4092b.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 初始化左指针 l、右指针 r 和结果列表索引 i</span></span><br><span class="line">        l, r, i = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="comment"># 初始化结果列表，全部填充为 0</span></span><br><span class="line">        res = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 循环直到左指针大于右指针</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            <span class="comment"># 如果左指针指向的元素的平方值小于右指针指向的元素的平方值</span></span><br><span class="line">            <span class="keyword">if</span> nums[l] * nums[l] &lt; nums[r] * nums[r]:</span><br><span class="line">                <span class="comment"># 将右指针指向的元素的平方值放入结果列表的末尾</span></span><br><span class="line">                res[i] = nums[r] * nums[r]</span><br><span class="line">                <span class="comment"># 右指针向左移动</span></span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 将左指针指向的元素的平方值放入结果列表的末尾</span></span><br><span class="line">                res[i] = nums[l] * nums[l]</span><br><span class="line">                <span class="comment"># 左指针向右移动</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 结果列表索引向前移动</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 返回排序后的平方值列表</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
<li>螺旋矩阵<br><img src="/2024/04/23/2024-04-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/b79496d6f62c2e9e3611371989e11b9.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 如果 n 小于等于 0，返回空列表</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 初始化结果矩阵，全部填充为 0</span></span><br><span class="line">        res = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># 初始化左边界 l、右边界 r、上边界 t、下边界 b，以及填充的数字 num</span></span><br><span class="line">        l, r, t, b = <span class="number">0</span>, n-<span class="number">1</span>, <span class="number">0</span>, n-<span class="number">1</span></span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 开始填充数字循环</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 从左到右填充数字</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, r+<span class="number">1</span>):</span><br><span class="line">                res[t][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            t += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果上边界大于下边界，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> t &gt; b:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 从上到下填充数字</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(t, b+<span class="number">1</span>):</span><br><span class="line">                res[j][r] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果右边界小于左边界，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> r &lt; l:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 从右到左填充数字</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(r, l-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res[b][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            b -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 从下到上填充数字</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(b, t-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res[j][l] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 返回填充完成的矩阵</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
<li>算法题<br><img src="/2024/04/23/2024-04-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/117a30901567ee16ea98d06f0aaadde.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 输入一个整数 n</span></span><br><span class="line">        n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        <span class="comment"># 如果 n 为 0，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 输入 n 个整数，并将它们存储在列表 nums 中</span></span><br><span class="line">        nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">        <span class="comment"># 计算 nums 列表的平均值</span></span><br><span class="line">        target = <span class="built_in">sum</span>(nums) // <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 初始化结果变量为 0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历 nums 列表的索引范围</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 计算每个元素与平均值的绝对差，并累加到结果变量中</span></span><br><span class="line">            res += <span class="built_in">abs</span>(nums[i] - target)</span><br><span class="line">        <span class="comment"># 输出结果的一半（因为每次计算都是成对的）</span></span><br><span class="line">        <span class="built_in">print</span>(res // <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 输出空行</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># 捕获异常并跳出循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>算法题<br><img src="/2024/04/23/2024-04-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/2b1532f6f764a09fdfcf0b80663cc2e.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 无限循环，直到遇到 break 语句</span></span><br><span class="line">    <span class="keyword">try</span>:  <span class="comment"># 尝试执行以下代码块</span></span><br><span class="line">        m, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())  <span class="comment"># 输入两个整数 m 和 k，以空格分隔</span></span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span> <span class="keyword">and</span> k == <span class="number">0</span>:  <span class="comment"># 如果输入的 m 和 k 都为 0，结束循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        res = m // k * k  <span class="comment"># 初始化结果为 m 除以 k 的商乘以 k</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 无限循环，直到遇到 break 语句</span></span><br><span class="line">            add, rest = m // k, m % k  <span class="comment"># 计算 m 除以 k 的商和余数</span></span><br><span class="line">            m = add + rest  <span class="comment"># 新的 m 为商和余数的和</span></span><br><span class="line">            <span class="keyword">if</span> m &lt; k:  <span class="comment"># 如果余数小于 k，跳出循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            res += m // k * k  <span class="comment"># 将商乘以 k 加入结果</span></span><br><span class="line">        res += m  <span class="comment"># 将剩余的 m 加入结果</span></span><br><span class="line">        <span class="built_in">print</span>(res)  <span class="comment"># 输出结果</span></span><br><span class="line">    <span class="keyword">except</span>:  <span class="comment"># 如果遇到异常，则结束循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></li>
<li>算法题<br><img src="/2024/04/23/2024-04-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/38570f1e0f335ba7ff687d9818bb357.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 无限循环，直到遇到 break 语句</span></span><br><span class="line">    <span class="keyword">try</span>:  <span class="comment"># 尝试执行以下代码块</span></span><br><span class="line">        n = <span class="built_in">int</span>(<span class="built_in">input</span>())  <span class="comment"># 输入家族成员的数量</span></span><br><span class="line">        fatherlist = [<span class="number">0</span>] * <span class="number">21</span>  <span class="comment"># 初始化父子关系列表，下标范围为 0 到 20</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 循环读取每个家族成员的父子关系</span></span><br><span class="line">            son, father = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())  <span class="comment"># 输入儿子和父亲的编号</span></span><br><span class="line">            fatherlist[son] = father  <span class="comment"># 将父子关系记录到列表中</span></span><br><span class="line">        count1 = <span class="number">0</span>  <span class="comment"># 初始化计数器 count1 为 0</span></span><br><span class="line">        x = <span class="number">1</span>  <span class="comment"># 从编号为 1 的人开始向上查找祖先</span></span><br><span class="line">        <span class="keyword">while</span> fatherlist[x] != <span class="number">0</span>:  <span class="comment"># 当 x 的父亲不为 0 时，继续向上查找祖先</span></span><br><span class="line">            x = fatherlist[x]  <span class="comment"># x 更新为其父亲的编号</span></span><br><span class="line">            count1 += <span class="number">1</span>  <span class="comment"># 计数器 count1 自增</span></span><br><span class="line">        count2 = <span class="number">0</span>  <span class="comment"># 初始化计数器 count2 为 0</span></span><br><span class="line">        y = <span class="number">2</span>  <span class="comment"># 从编号为 2 的人开始向上查找祖先</span></span><br><span class="line">        <span class="keyword">while</span> fatherlist[y] != <span class="number">0</span>:  <span class="comment"># 当 y 的父亲不为 0 时，继续向上查找祖先</span></span><br><span class="line">            y = fatherlist[y]  <span class="comment"># y 更新为其父亲的编号</span></span><br><span class="line">            count2 += <span class="number">1</span>  <span class="comment"># 计数器 count2 自增</span></span><br><span class="line">        <span class="keyword">if</span> count1 &lt; count2:  <span class="comment"># 如果 count1 小于 count2，则输出 &quot;You are my younger&quot;</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;You are my younger&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> count1 == count2:  <span class="comment"># 如果 count1 等于 count2，则输出 &quot;You are my brother&quot;</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;You are my brother&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 否则输出 &quot;You are my elder&quot;</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;You are my elder&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span>:  <span class="comment"># 如果遇到异常，则结束循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>算法题<br><img src="/2024/04/23/2024-04-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/d3dd4a8408c05cc45d16494da1d1b74.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 无限循环，直到遇到 break 语句</span></span><br><span class="line">    <span class="keyword">try</span>:  <span class="comment"># 尝试执行以下代码块</span></span><br><span class="line">        n = <span class="built_in">int</span>(<span class="built_in">input</span>())  <span class="comment"># 输入一个整数 n</span></span><br><span class="line">        alllist = []  <span class="comment"># 初始化存储数字三角形的列表</span></span><br><span class="line">        <span class="comment"># 生成数字三角形</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):  <span class="comment"># 循环控制行数</span></span><br><span class="line">            list1 = []  <span class="comment"># 初始化当前行的列表</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):  <span class="comment"># 循环生成当前行的数字</span></span><br><span class="line">                list1.append(<span class="built_in">str</span>(j))  <span class="comment"># 将数字转换为字符串并添加到列表中</span></span><br><span class="line">            relist1 = list1[::-<span class="number">1</span>]  <span class="comment"># 将当前行的列表反转</span></span><br><span class="line">            list1.extend(relist1[<span class="number">1</span>:])  <span class="comment"># 将反转后的列表除去首个元素后添加到当前行的列表中</span></span><br><span class="line">            alllist.append(list1)  <span class="comment"># 将当前行的列表添加到数字三角形列表中</span></span><br><span class="line">        <span class="comment"># 正序打印数字三角形</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):  <span class="comment"># 控制打印的行数</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> * (n - i), end=<span class="string">&#x27;&#x27;</span>)  <span class="comment"># 输出前导空格</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(alllist[i - <span class="number">1</span>]))  <span class="comment"># 将当前行的列表中的数字用空格连接成字符串并打印</span></span><br><span class="line">        <span class="comment"># 倒序打印数字三角形</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):  <span class="comment"># 倒序循环控制打印的行数</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> * (n - i - <span class="number">1</span>), end=<span class="string">&#x27;&#x27;</span>)  <span class="comment"># 输出前导空格</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(alllist[i]))  <span class="comment"># 将当前行的列表中的数字用空格连接成字符串并打印</span></span><br><span class="line">    <span class="keyword">except</span>:  <span class="comment"># 如果遇到异常，则结束循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></li>
<li>注意upper和lower函数<br><img src="/2024/04/23/2024-04-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/823a9ddc94fe9b3506a75455060bcee.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())  <span class="comment"># 输入一个整数 n，表示接下来有 n 个单词需要处理</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 循环 n 次，处理每个单词</span></span><br><span class="line">    nums = []  <span class="comment"># 初始化一个空列表 nums，用于存储当前单词的每个字符</span></span><br><span class="line">    nums.extend(<span class="built_in">input</span>().split())  <span class="comment"># 输入一个单词，并将其按空格分割后添加到列表 nums 中</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> nums:  <span class="comment"># 遍历列表 nums 中的每个字符</span></span><br><span class="line">        <span class="built_in">print</span>(c[<span class="number">0</span>].upper(), end=<span class="string">&#x27;&#x27;</span>)  <span class="comment"># 将当前字符的首字母转换为大写并打印，end=&#x27;&#x27; 表示不换行</span></span><br><span class="line">    <span class="built_in">print</span>()  <span class="comment"># 打印一个换行，用于分隔每个处理的单词</span></span><br></pre></td></tr></table></figure></li>
<li>栈<br><img src="/2024/04/23/2024-04-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/6eaa7b63b31ec4e46dbce68fc2246ee.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 无限循环，直到遇到 break 语句</span></span><br><span class="line">    <span class="keyword">try</span>:  <span class="comment"># 尝试执行以下代码块</span></span><br><span class="line">        n = <span class="built_in">int</span>(<span class="built_in">input</span>())  <span class="comment"># 输入一个整数 n，表示序列的长度</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:  <span class="comment"># 如果输入的 n 为 0，结束循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))  <span class="comment"># 输入一个由空格分隔的整数序列，将其转换为列表</span></span><br><span class="line">        stack = []  <span class="comment"># 初始化一个空栈</span></span><br><span class="line">        i = <span class="number">1</span>  <span class="comment"># 初始化一个变量 i 为 1，表示当前待入栈的元素</span></span><br><span class="line">        j = <span class="number">0</span>  <span class="comment"># 初始化一个变量 j 为 0，表示当前待匹配的元素在序列 nums 中的索引</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= n:  <span class="comment"># 当待入栈元素小于等于序列长度时，继续循环</span></span><br><span class="line">            stack.append(i)  <span class="comment"># 将当前待入栈元素入栈</span></span><br><span class="line">            i += <span class="number">1</span>  <span class="comment"># 待入栈元素自增</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] == nums[j]:  <span class="comment"># 当栈非空且栈顶元素等于当前待匹配元素时，执行以下循环</span></span><br><span class="line">                stack.pop()  <span class="comment"># 弹出栈顶元素</span></span><br><span class="line">                j += <span class="number">1</span>  <span class="comment"># 待匹配元素索引自增</span></span><br><span class="line">        <span class="keyword">if</span> stack:  <span class="comment"># 如果栈非空，说明匹配失败，打印 &#x27;No&#x27;</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;No&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 否则，匹配成功，打印 &#x27;Yes&#x27;</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Yes&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span>:  <span class="comment"># 如果遇到异常，则结束循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></li>
<li>反转链表<br>这个题注意构造链表的操作<br><img src="/2024/04/23/2024-04-23-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/46f33657b3f0589ac7bc0a779f47f25.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reversnode</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="comment"># 初始化指针</span></span><br><span class="line">    temp = <span class="literal">None</span>  <span class="comment"># 临时节点，用于保存当前节点的下一个节点</span></span><br><span class="line">    cur = head  <span class="comment"># 当前节点</span></span><br><span class="line">    pre = <span class="literal">None</span>  <span class="comment"># 前一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历链表进行反转</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        temp = cur.<span class="built_in">next</span>  <span class="comment"># 保存当前节点的下一个节点</span></span><br><span class="line">        cur.<span class="built_in">next</span> = pre   <span class="comment"># 将当前节点的指针指向前一个节点</span></span><br><span class="line">        pre = cur        <span class="comment"># 更新前一个节点为当前节点</span></span><br><span class="line">        cur = temp       <span class="comment"># 更新当前节点为临时节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre  <span class="comment"># 返回反转后的链表头节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printnode</span>(<span class="params">head</span>):</span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="built_in">print</span>(cur.val, end=<span class="string">&#x27; &#x27;</span>)  <span class="comment"># 打印当前节点的值</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span>           <span class="comment"># 移动到下一个节点</span></span><br><span class="line">    <span class="built_in">print</span>()  <span class="comment"># 打印换行，用于分隔不同的链表输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))  <span class="comment"># 从用户输入获取一串数字，转换为整数列表</span></span><br><span class="line">        n = nums[<span class="number">0</span>]  <span class="comment"># 第一个数字表示链表的长度</span></span><br><span class="line">        nums = nums[<span class="number">1</span>:]  <span class="comment"># 去掉第一个数字，得到链表的元素列表</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;list is empty&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建一个虚拟头节点</span></span><br><span class="line">        dummyhead = ListNode()</span><br><span class="line">        cur = dummyhead</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据用户输入构建链表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            cur.<span class="built_in">next</span> = ListNode(nums[i])  <span class="comment"># 创建一个新节点并将其链接到当前节点</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span>  <span class="comment"># 移动到新节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打印原始链表和反转后的链表</span></span><br><span class="line">        printnode(dummyhead.<span class="built_in">next</span>)</span><br><span class="line">        printnode(reversnode(dummyhead.<span class="built_in">next</span>))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 当出现异常时退出循环</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.04.24_学习日记</title>
    <url>/2024/04/24/2024-04-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：宿舍<br>学习时长：4h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>链表<br><img src="/2024/04/24/2024-04-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c44981d068d490e3ece7f90fd78ad64.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">creatlist</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:  <span class="comment"># 如果输入的列表为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 返回空链表</span></span><br><span class="line">    head = Node(nums[<span class="number">0</span>])  <span class="comment"># 创建链表头节点</span></span><br><span class="line">    cur = head  <span class="comment"># 设置当前节点为头节点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:]:  <span class="comment"># 遍历列表中除头节点外的元素</span></span><br><span class="line">        cur.<span class="built_in">next</span> = Node(i)  <span class="comment"># 创建新节点并连接到当前节点</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span>  <span class="comment"># 移动到新节点</span></span><br><span class="line">    <span class="keyword">return</span> head  <span class="comment"># 返回链表头节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printlist</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:  <span class="comment"># 如果链表为空</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;list is empty&#x27;</span>)  <span class="comment"># 打印提示信息</span></span><br><span class="line">    cur = head  <span class="comment"># 设置当前节点为链表头节点</span></span><br><span class="line">    <span class="keyword">while</span> cur:  <span class="comment"># 遍历链表</span></span><br><span class="line">        <span class="built_in">print</span>(cur.val, end=<span class="string">&#x27; &#x27;</span>)  <span class="comment"># 打印当前节点的值</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span>  <span class="comment"># 移动到下一个节点</span></span><br><span class="line">    <span class="built_in">print</span>()  <span class="comment"># 换行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deletenode</span>(<span class="params">head</span>):</span><br><span class="line">    cur = head  <span class="comment"># 设置当前节点为链表头节点</span></span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">and</span> cur.<span class="built_in">next</span>:  <span class="comment"># 遍历链表直到当前节点为空或者下一个节点为空</span></span><br><span class="line">        <span class="keyword">if</span> cur.val == cur.<span class="built_in">next</span>.val:  <span class="comment"># 如果当前节点的值等于下一个节点的值</span></span><br><span class="line">            cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span>  <span class="comment"># 删除下一个节点</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 如果当前节点的值不等于下一个节点的值</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span>  <span class="comment"># 移动到下一个节点</span></span><br><span class="line">    <span class="keyword">return</span> head  <span class="comment"># 返回链表头节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 循环输入</span></span><br><span class="line">    <span class="keyword">try</span>:  <span class="comment"># 尝试读取输入</span></span><br><span class="line">        nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))  <span class="comment"># 读取整数列表</span></span><br><span class="line">        n = nums[<span class="number">0</span>]  <span class="comment"># 第一个元素表示链表长度</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:  <span class="comment"># 如果链表长度为0</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;list is empty&#x27;</span>)  <span class="comment"># 打印链表为空的信息</span></span><br><span class="line">            <span class="keyword">continue</span>  <span class="comment"># 继续下一次循环</span></span><br><span class="line">        nums = nums[<span class="number">1</span>:]  <span class="comment"># 去除第一个元素，得到链表值列表</span></span><br><span class="line">        head = creatlist(nums)  <span class="comment"># 创建链表</span></span><br><span class="line">        printlist(head)  <span class="comment"># 打印原始链表</span></span><br><span class="line">        head = deletenode(head)  <span class="comment"># 删除重复节点</span></span><br><span class="line">        printlist(head)  <span class="comment"># 打印删除重复节点后的链表</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span>:  <span class="comment"># 处理异常（例如输入结束）</span></span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 结束循环</span></span><br></pre></td></tr></table></figure></li>
<li>构造二叉树<br><img src="/2024/04/24/2024-04-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/22e8e79f07d730483651ac5ce9ee336.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="literal">None</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val  <span class="comment"># 节点的值</span></span><br><span class="line">        self.left = left  <span class="comment"># 左子树节点</span></span><br><span class="line">        self.right = right  <span class="comment"># 右子树节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">buildtree</span>(<span class="params">preorder, inorder</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">or</span> <span class="keyword">not</span> inorder:  <span class="comment"># 如果先序或中序列表为空，返回 None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    rootval = preorder[<span class="number">0</span>]  <span class="comment"># 先序遍历的第一个节点为根节点</span></span><br><span class="line">    idx = inorder.index(rootval)  <span class="comment"># 根据根节点的值在中序列表中找到左右子树的分界点</span></span><br><span class="line">    inorder_left = inorder[:idx]  <span class="comment"># 中序列表中根节点左边的部分为左子树的中序遍历结果</span></span><br><span class="line">    inorder_right = inorder[idx + <span class="number">1</span>:]  <span class="comment"># 中序列表中根节点右边的部分为右子树的中序遍历结果</span></span><br><span class="line">    preorder_left = preorder[<span class="number">1</span>:idx + <span class="number">1</span>]  <span class="comment"># 根据中序遍历结果确定左右子树的先序遍历结果</span></span><br><span class="line">    preorder_right = preorder[idx + <span class="number">1</span>:]</span><br><span class="line">    root = Tree(val=rootval)  <span class="comment"># 创建当前根节点</span></span><br><span class="line">    root.left = buildtree(preorder_left, inorder_left)  <span class="comment"># 递归构建左子树</span></span><br><span class="line">    root.right = buildtree(preorder_right, inorder_right)  <span class="comment"># 递归构建右子树</span></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">postorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:  <span class="comment"># 如果当前节点为空，返回空列表</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    left = postorder(root.left)  <span class="comment"># 递归遍历左子树</span></span><br><span class="line">    right = postorder(root.right)  <span class="comment"># 递归遍历右子树</span></span><br><span class="line">    <span class="keyword">return</span> left + right + [root.val]  <span class="comment"># 左子树结果 + 右子树结果 + 当前节点值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        preorder, inorder = <span class="built_in">input</span>().split()  <span class="comment"># 输入先序遍历和中序遍历结果</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">or</span> <span class="keyword">not</span> inorder:  <span class="comment"># 如果输入为空，退出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        root = buildtree(preorder, inorder)  <span class="comment"># 构建二叉树</span></span><br><span class="line">        res = postorder(root)  <span class="comment"># 后序遍历二叉树</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, res)))  <span class="comment"># 打印结果，以空格分隔</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></li>
<li>二叉树遍历<br><img src="/2024/04/24/2024-04-24-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/8ccece4af31b83d017ec6963294d2f5.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val  <span class="comment"># 节点的值</span></span><br><span class="line">        self.left = <span class="literal">None</span>  <span class="comment"># 左子节点</span></span><br><span class="line">        self.right = <span class="literal">None</span>  <span class="comment"># 右子节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []  <span class="comment"># 如果根节点为空，返回空列表</span></span><br><span class="line">    left = preorder(root.left)  <span class="comment"># 先序遍历左子树</span></span><br><span class="line">    right = preorder(root.right)  <span class="comment"># 先序遍历右子树</span></span><br><span class="line">    <span class="keyword">return</span> [root.val] + left + right  <span class="comment"># 根节点值 + 左子树结果 + 右子树结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []  <span class="comment"># 如果根节点为空，返回空列表</span></span><br><span class="line">    left = inorder(root.left)  <span class="comment"># 中序遍历左子树</span></span><br><span class="line">    right = inorder(root.right)  <span class="comment"># 中序遍历右子树</span></span><br><span class="line">    <span class="keyword">return</span> left + [root.val] + right  <span class="comment"># 左子树结果 + 根节点值 + 右子树结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">postorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []  <span class="comment"># 如果根节点为空，返回空列表</span></span><br><span class="line">    left = postorder(root.left)  <span class="comment"># 后序遍历左子树</span></span><br><span class="line">    right = postorder(root.right)  <span class="comment"># 后序遍历右子树</span></span><br><span class="line">    <span class="keyword">return</span> left + right + [root.val]  <span class="comment"># 左子树结果 + 右子树结果 + 根节点值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n = <span class="built_in">int</span>(<span class="built_in">input</span>())  <span class="comment"># 输入节点数量</span></span><br><span class="line">        nodes = [<span class="number">0</span>] * (<span class="number">1</span> + n)  <span class="comment"># 初始化节点列表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 遍历节点输入</span></span><br><span class="line">            val, left, right = <span class="built_in">input</span>().split()  <span class="comment"># 输入节点值、左子节点索引、右子节点索引</span></span><br><span class="line">            left, right = <span class="built_in">int</span>(left), <span class="built_in">int</span>(right)  <span class="comment"># 将字符串索引转换为整数</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nodes[i + <span class="number">1</span>]:  <span class="comment"># 如果节点列表中当前位置为空</span></span><br><span class="line">                nodes[i + <span class="number">1</span>] = Node(val)  <span class="comment"># 创建新节点并赋值</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nodes[i + <span class="number">1</span>].val = val  <span class="comment"># 否则更新节点的值</span></span><br><span class="line">            <span class="keyword">if</span> left != <span class="number">0</span>:  <span class="comment"># 如果左子节点索引不为0</span></span><br><span class="line">                nodes[left] = Node(<span class="string">&#x27;x&#x27;</span>)  <span class="comment"># 创建新节点作为左子节点</span></span><br><span class="line">                nodes[i + <span class="number">1</span>].left = nodes[left]  <span class="comment"># 将左子节点连接到当前节点</span></span><br><span class="line">            <span class="keyword">if</span> right != <span class="number">0</span>:  <span class="comment"># 如果右子节点索引不为0</span></span><br><span class="line">                nodes[right] = Node(<span class="string">&#x27;x&#x27;</span>)  <span class="comment"># 创建新节点作为右子节点</span></span><br><span class="line">                nodes[i + <span class="number">1</span>].right = nodes[right]  <span class="comment"># 将右子节点连接到当前节点</span></span><br><span class="line">        root = nodes[<span class="number">1</span>]  <span class="comment"># 根节点为节点列表的第一个节点</span></span><br><span class="line">        pre = preorder(root)  <span class="comment"># 先序遍历结果</span></span><br><span class="line">        ino = inorder(root)  <span class="comment"># 中序遍历结果</span></span><br><span class="line">        post = postorder(root)  <span class="comment"># 后序遍历结果</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, pre)))  <span class="comment"># 打印先序遍历结果，以空格分隔节点的值</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, ino)))  <span class="comment"># 打印中序遍历结果，以空格分隔节点的值</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, post)))  <span class="comment"># 打印后序遍历结果，以空格分隔节点的值</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 结束循环</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.04.25_学习日记</title>
    <url>/2024/04/25/2024-04-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：图书馆<br>学习时长：10h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>二叉树高度<br><img src="/2024/04/25/2024-04-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/bf2a762dcefcb34739c34522f8cea0b.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:  <span class="comment"># 定义树节点的类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val  <span class="comment"># 节点的值</span></span><br><span class="line">        self.left = <span class="literal">None</span>  <span class="comment"># 指向左子节点的指针</span></span><br><span class="line">        self.right = <span class="literal">None</span>  <span class="comment"># 指向右子节点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">buildtree</span>(<span class="params">preorder, inorder</span>):  <span class="comment"># 构建树的函数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">or</span> <span class="keyword">not</span> inorder:  <span class="comment"># 如果先序或中序列表为空，返回None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    root_val = preorder[<span class="number">0</span>]  <span class="comment"># 根节点的值是先序列表的第一个元素</span></span><br><span class="line">    index = inorder.index(root_val)  <span class="comment"># 找到根节点在中序列表中的索引</span></span><br><span class="line">    inorder_left = inorder[:index]  <span class="comment"># 左子树的中序列表</span></span><br><span class="line">    inorder_right = inorder[index+<span class="number">1</span>:]  <span class="comment"># 右子树的中序列表</span></span><br><span class="line">    preorder_left = preorder[<span class="number">1</span>:index+<span class="number">1</span>]  <span class="comment"># 左子树的先序列表</span></span><br><span class="line">    preorder_right = preorder[index+<span class="number">1</span>:]  <span class="comment"># 右子树的先序列表</span></span><br><span class="line">    root = Node(root_val)  <span class="comment"># 创建一个以根节点值为值的节点</span></span><br><span class="line">    root.left = buildtree(preorder_left, inorder_left)  <span class="comment"># 递归构建左子树</span></span><br><span class="line">    root.right = buildtree(preorder_right, inorder_right)  <span class="comment"># 递归构建右子树</span></span><br><span class="line">    <span class="keyword">return</span> root  <span class="comment"># 返回子树的根节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getheight</span>(<span class="params">root</span>):  <span class="comment"># 计算树的高度的函数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:  <span class="comment"># 如果根节点为空，返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    left = getheight(root.left)  <span class="comment"># 计算左子树的高度</span></span><br><span class="line">    right = getheight(root.right)  <span class="comment"># 计算右子树的高度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>  <span class="comment"># 返回左右子树高度的最大值加1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n = <span class="built_in">int</span>(<span class="built_in">input</span>())  <span class="comment"># 输入n，表示节点数</span></span><br><span class="line">        preorder = <span class="built_in">input</span>()  <span class="comment"># 输入先序遍历结果</span></span><br><span class="line">        inorder = <span class="built_in">input</span>()  <span class="comment"># 输入中序遍历结果</span></span><br><span class="line">        root = buildtree(preorder, inorder)  <span class="comment"># 构建树</span></span><br><span class="line">        <span class="built_in">print</span>(getheight(root))  <span class="comment"># 打印树的高度</span></span><br><span class="line">    <span class="keyword">except</span>:  <span class="comment"># 捕获异常</span></span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 退出循环</span></span><br></pre></td></tr></table></figure></li>
<li>图<br><img src="/2024/04/25/2024-04-25-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/a9917664b297435f802e404d210904e.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">visited, x, y, graph, curres</span>):</span><br><span class="line">    <span class="keyword">if</span> x == y:  <span class="comment"># 如果当前节点为目标节点 y，则返回当前累积距离</span></span><br><span class="line">        <span class="keyword">return</span> curres</span><br><span class="line">    visited[x] = <span class="literal">True</span>  <span class="comment"># 将当前节点标记为已访问</span></span><br><span class="line">    minres = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)  <span class="comment"># 初始化最小距离为无穷大</span></span><br><span class="line">    <span class="keyword">for</span> nxt, distance <span class="keyword">in</span> graph[x]:  <span class="comment"># 遍历当前节点的邻居节点及其距离</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> visited[nxt]:  <span class="comment"># 如果邻居节点未被访问过</span></span><br><span class="line">            <span class="comment"># 递归调用 DFS，并更新最小距离</span></span><br><span class="line">            minres = <span class="built_in">min</span>(minres, dfs(visited, nxt, y, graph, curres + distance))</span><br><span class="line">    visited[x] = <span class="literal">False</span>  <span class="comment"># 恢复当前节点的访问状态</span></span><br><span class="line">    <span class="keyword">return</span> minres  <span class="comment"># 返回最小距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())  <span class="comment"># 输入节点数和边数</span></span><br><span class="line">        graph = &#123;i: [] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>)&#125;  <span class="comment"># 创建图的邻接表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):  <span class="comment"># 读取每条边的起点、终点和距离</span></span><br><span class="line">            a, b, l = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">            graph[a].append((b, l))  <span class="comment"># 将边加入图的邻接表中</span></span><br><span class="line">            graph[b].append((a, l))  <span class="comment"># 无向图需双向添加</span></span><br><span class="line">        x, y = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())  <span class="comment"># 输入起点和终点</span></span><br><span class="line">        visited = [<span class="literal">False</span>] * (<span class="number">1</span> + n)  <span class="comment"># 初始化节点访问状态</span></span><br><span class="line">        res = dfs(visited, x, y, graph, <span class="number">0</span>)  <span class="comment"># 调用 DFS 查找最短路径长度</span></span><br><span class="line">        <span class="keyword">if</span> res == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>):  <span class="comment"># 如果最短路径长度为无穷大</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;No path&#x27;</span>)  <span class="comment"># 输出无法到达的提示</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(res)  <span class="comment"># 输出最短路径长度</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 捕获异常并退出循环</span></span><br></pre></td></tr></table></figure></li>
<li>不知道第几次的KMP(lc28)<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 定义一个函数用于生成 needle 的 next 数组</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getnext</span>():</span><br><span class="line">            nlen = <span class="built_in">len</span>(needle)</span><br><span class="line">            <span class="keyword">if</span> nlen == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> [-<span class="number">1</span>]  <span class="comment"># 特殊情况：needle 长度为 1</span></span><br><span class="line">            nextlist = [<span class="number">0</span>] * nlen  <span class="comment"># 初始化 next 数组</span></span><br><span class="line">            nextlist[<span class="number">0</span>] = -<span class="number">1</span>  <span class="comment"># 初始值设为 -1</span></span><br><span class="line">            nextlist[<span class="number">1</span>] = <span class="number">0</span>  <span class="comment"># next 数组的第二个元素设为 0</span></span><br><span class="line">            cn = <span class="number">0</span>  <span class="comment"># cn 表示当前 next 数组的索引</span></span><br><span class="line">            i = <span class="number">2</span>  <span class="comment"># 从第三个元素开始计算 next 数组</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; nlen:</span><br><span class="line">                <span class="keyword">if</span> needle[i-<span class="number">1</span>] == needle[cn]:</span><br><span class="line">                    nextlist[i] = cn + <span class="number">1</span>  <span class="comment"># 如果当前字符与前缀相等，更新 next 数组的值</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    cn += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> cn &gt; <span class="number">0</span>:</span><br><span class="line">                    cn = nextlist[cn]  <span class="comment"># 回溯到前一个可能的相等前缀</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nextlist[i] = <span class="number">0</span>  <span class="comment"># 如果没有相等前缀，将当前 next 数组值设为 0</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> nextlist</span><br><span class="line">        </span><br><span class="line">        list1 = getnext()  <span class="comment"># 调用函数生成 needle 的 next 数组</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        mlen = <span class="built_in">len</span>(haystack)  <span class="comment"># haystack 的长度</span></span><br><span class="line">        nlen = <span class="built_in">len</span>(needle)  <span class="comment"># needle 的长度</span></span><br><span class="line">        <span class="keyword">if</span> mlen &lt; nlen:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># 如果 haystack 的长度小于 needle 的长度，直接返回 -1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; mlen <span class="keyword">and</span> j &lt; nlen:</span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> list1[j] == -<span class="number">1</span>:  <span class="comment"># 如果匹配失败且 next 数组的值为 -1，表示 needle 的第一个字符就不匹配</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = list1[j]  <span class="comment"># 回溯到可能的相等前缀的下一个位置</span></span><br><span class="line">        <span class="keyword">return</span> i - j <span class="keyword">if</span> j == nlen <span class="keyword">else</span> -<span class="number">1</span>  <span class="comment"># 返回最终匹配的位置，或者 -1 表示未找到</span></span><br></pre></td></tr></table></figure></li>
<li>重复子串(KMP lc459)<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">repeatedSubstringPattern</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)  <span class="comment"># 获取字符串 s 的长度</span></span><br><span class="line">        s1 = s + <span class="string">&#x27; &#x27;</span>  <span class="comment"># 将字符串 s 后面添加一个空格，方便后续处理</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:  <span class="comment"># 如果字符串长度为 1，直接返回 False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        kmplist = [<span class="number">0</span>] * (n + <span class="number">1</span>)  <span class="comment"># 初始化一个长度为 n+1 的列表，用于存储 KMP 算法中的 next 数组</span></span><br><span class="line">        kmplist[<span class="number">0</span>] = -<span class="number">1</span>  <span class="comment"># 初始化第一个元素为 -1</span></span><br><span class="line">        kmplist[<span class="number">1</span>] = <span class="number">0</span>  <span class="comment"># 初始化第二个元素为 0</span></span><br><span class="line">        i = <span class="number">2</span>  <span class="comment"># 从第三个元素开始计算 next 数组</span></span><br><span class="line">        cn = <span class="number">0</span>  <span class="comment"># 初始化当前 next 数组索引为 0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n + <span class="number">1</span>:  <span class="comment"># 循环计算 next 数组的值</span></span><br><span class="line">            <span class="keyword">if</span> s[i - <span class="number">1</span>] == s[cn]:  <span class="comment"># 如果当前字符与前缀相等</span></span><br><span class="line">                kmplist[i] = cn + <span class="number">1</span>  <span class="comment"># 更新 next 数组的值</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cn += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cn &gt; <span class="number">0</span>:  <span class="comment"># 如果当前字符不等于前缀的最后一个字符，但是 cn 大于 0</span></span><br><span class="line">                cn = kmplist[cn]  <span class="comment"># 回溯到前一个可能的相等前缀</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 如果以上两个条件都不满足</span></span><br><span class="line">                kmplist[i] = <span class="number">0</span>  <span class="comment"># 将当前 next 数组值设为 0</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 判断重复子字符串的条件：最后一个元素的值不为 0，并且字符串长度能整除 (长度 - 最后一个元素的值)</span></span><br><span class="line">        <span class="keyword">if</span> kmplist[-<span class="number">1</span>] != <span class="number">0</span> <span class="keyword">and</span> (n % (n - kmplist[-<span class="number">1</span>]) == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 满足条件则返回 True，表示存在重复子字符串</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 否则返回 False，表示不存在重复子字符串</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.04.26_学习日记</title>
    <url>/2024/04/26/2024-04-26-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：晴<br>学习地点：图书馆<br>学习时长：10h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>今天没有笔记，在复习之前的题</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.04.28_学习日记</title>
    <url>/2024/04/28/2024-04-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：中雨<br>学习地点：宿舍<br>学习时长：10h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>动态规划完全背包<br><img src="/2024/04/28/2024-04-28-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/8c5e98642b677c7d0b11f50ff3406d9.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        dp = [<span class="number">0</span>] * (<span class="number">1</span>+n)  <span class="comment"># 创建一个长度为 n+1 的数组，用于存储硬币组合数量，初始值全部为0</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>  <span class="comment"># 当目标金额为0时，只有一种组合方式，即一个硬币都不选，因此令 dp[0] = 1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1</span>+n):  <span class="comment"># 遍历硬币的面额</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):  <span class="comment"># 遍历目标金额</span></span><br><span class="line">                <span class="keyword">if</span> j &gt;= i:  <span class="comment"># 如果当前硬币面额大于等于目标金额</span></span><br><span class="line">                    dp[j] += dp[j-i]  <span class="comment"># 更新当前金额下的组合数量，累加之前的组合数量</span></span><br><span class="line">        <span class="built_in">print</span>(dp[-<span class="number">1</span>])  <span class="comment"># 输出最终结果，即目标金额下的组合数量</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 如果输入异常，退出循环</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.04.30_学习日记</title>
    <url>/2024/04/30/2024-04-30-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：中雨<br>学习地点：宿舍<br>学习时长：10h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>算法题<br><img src="/2024/04/30/2024-04-30-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/6821f2a012717c3b899a90ce0f50618.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict  <span class="comment"># 导入defaultdict模块</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n = <span class="built_in">int</span>(<span class="built_in">input</span>())  <span class="comment"># 接收输入，表示接下来有几组测试数据</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 对每组测试数据进行处理</span></span><br><span class="line">            strs = <span class="built_in">input</span>()  <span class="comment"># 接收输入的字符串</span></span><br><span class="line">            hashmap = defaultdict(<span class="built_in">int</span>)  <span class="comment"># 创建一个默认值为0的字典</span></span><br><span class="line">            cnt = <span class="number">0</span>  <span class="comment"># 记录字符串中重复字符的数量</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> strs:  <span class="comment"># 遍历字符串中的每个字符</span></span><br><span class="line">                <span class="keyword">if</span> hashmap[c] == <span class="number">1</span>:  <span class="comment"># 如果当前字符已经出现过一次</span></span><br><span class="line">                    cnt += <span class="number">1</span>  <span class="comment"># 则重复字符数量加1</span></span><br><span class="line">                    hashmap[c] = <span class="number">0</span>  <span class="comment"># 并将该字符的计数归零，表示不再重复</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    hashmap[c] += <span class="number">1</span>  <span class="comment"># 否则，将该字符的计数加1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(strs) - cnt &lt;= <span class="number">26</span>:  <span class="comment"># 如果去除重复字符后的长度不超过26</span></span><br><span class="line">                <span class="built_in">print</span>(cnt)  <span class="comment"># 则输出重复字符数量</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">len</span>(strs) - <span class="number">26</span>)  <span class="comment"># 否则，输出超过26个字符的部分</span></span><br><span class="line">    <span class="keyword">except</span>:  <span class="comment"># 捕获所有异常</span></span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 如果出现异常，则结束循环</span></span><br></pre></td></tr></table></figure></li>
<li>动态规划<br><img src="/2024/04/30/2024-04-30-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/61064db9ca3d8a9cdc16c9962a5e4f5.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n = <span class="built_in">int</span>(<span class="built_in">input</span>())  <span class="comment"># 接收输入，表示接下来有几组测试数据</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 对每组测试数据进行处理</span></span><br><span class="line">            nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().strip()[<span class="number">1</span>:-<span class="number">1</span>].split(<span class="string">&#x27;,&#x27;</span>)))  <span class="comment"># 输入一个列表，去除首尾的方括号，然后按逗号分割成数字列表</span></span><br><span class="line">            dp = [<span class="number">1</span>]*(<span class="built_in">len</span>(nums)+<span class="number">1</span>)  <span class="comment"># 初始化动态规划数组，长度比nums多1，初始值都为1</span></span><br><span class="line">            <span class="comment"># dp[i]表示前i个数的最长递增子序列的长度</span></span><br><span class="line">            res = <span class="number">1</span>  <span class="comment"># 初始化结果为1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):  <span class="comment"># 遍历nums中的每个数字，从第2个数字开始</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):  <span class="comment"># 遍历nums中当前数字之前的每个数字</span></span><br><span class="line">                    <span class="keyword">if</span> nums[i] &gt; nums[j]:  <span class="comment"># 如果当前数字大于前面的数字</span></span><br><span class="line">                        dp[i] = <span class="built_in">max</span>(dp[i], dp[j]+<span class="number">1</span>)  <span class="comment"># 更新dp[i]，取当前dp[i]和dp[j]+1的较大值</span></span><br><span class="line">                res = <span class="built_in">max</span>(res, dp[i])  <span class="comment"># 更新结果为当前res和dp[i]的较大值</span></span><br><span class="line">            <span class="built_in">print</span>(res)  <span class="comment"># 输出结果</span></span><br><span class="line">    <span class="keyword">except</span>:  <span class="comment"># 捕获所有异常</span></span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 如果出现异常，则结束循环</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.05.07_学习日记</title>
    <url>/2024/05/07/2024-05-07-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>天气：中雨<br>学习地点：宿舍<br>学习时长：10h</p>
<span id="more"></span>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol>
<li>算法题<br><img src="/2024/05/07/2024-05-07-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/1a36864aeb39d0ab9114cfce77ceb71.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 如果字符串为空，返回0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建一个哈希表来存储字符及其索引</span></span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="comment"># 初始化哈希表，将字符串的第一个字符加入其中</span></span><br><span class="line">        hashmap[s[<span class="number">0</span>]] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取输入字符串的长度</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 将答案初始化为1，因为至少有一个字符</span></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 初始化变量 &#x27;pre&#x27;，用于跟踪到当前字符为止的子字符串长度</span></span><br><span class="line">        pre = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从第二个字符开始遍历字符串中的字符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 如果当前字符已经在哈希表中</span></span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> hashmap:</span><br><span class="line">                <span class="comment"># 计算当前索引 &#x27;i&#x27; 与该字符上次出现的索引之间的距离</span></span><br><span class="line">                p1 = i - hashmap[s[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果当前字符不在哈希表中，距离就是当前索引加1（表示当前字符与前面的字符都不相同）</span></span><br><span class="line">                p1 = i + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算当前字符与前一个字符不重复的子字符串的长度</span></span><br><span class="line">            p2 = pre + <span class="number">1</span></span><br><span class="line">            cur = <span class="built_in">min</span>(p1, p2)</span><br><span class="line">            <span class="comment"># 更新答案为当前子字符串长度与之前的答案中的较大值</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cur)</span><br><span class="line">            <span class="comment"># 更新变量 &#x27;pre&#x27; 为当前子字符串的长度，以备下一轮迭代使用</span></span><br><span class="line">            pre = cur</span><br><span class="line">            <span class="comment"># 更新哈希表中当前字符的索引</span></span><br><span class="line">            hashmap[s[i]] = i</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 返回最终答案</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></li>
<li>lc困难题<br><img src="/2024/05/07/2024-05-07-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/c3b6189f89272eaac771f14ca30117d.png" alt="alt text"><br>这个题最后一定要把head&#x3D;cur并且返回head，而不能省略这一步返回cur，因为这才能让最后没有k长度的结点的部分连上去。<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], k: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 初始化当前节点为头结点</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="comment"># 计数器，用于记录当前已经遍历的节点个数</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历链表，直到当前节点为空或已经遍历了k个节点</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cnt != k:</span><br><span class="line">            <span class="comment"># 移动到下一个节点</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 增加计数器</span></span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果已经遍历了k个节点</span></span><br><span class="line">        <span class="keyword">if</span> cnt == k:</span><br><span class="line">            <span class="comment"># 递归调用reverseKGroup函数，对剩余节点进行分组翻转</span></span><br><span class="line">            cur = self.reverseKGroup(cur, k)</span><br><span class="line">            <span class="comment"># 当前组翻转完成后，将当前组的节点进行翻转</span></span><br><span class="line">            <span class="keyword">while</span> cnt:</span><br><span class="line">                <span class="comment"># 减少计数器</span></span><br><span class="line">                cnt -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 临时保存头结点的下一个节点</span></span><br><span class="line">                tmp = head.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 将头结点的next指针指向已经翻转好的剩余节点</span></span><br><span class="line">                head.<span class="built_in">next</span> = cur</span><br><span class="line">                <span class="comment"># 更新cur为头结点，以便下一轮循环</span></span><br><span class="line">                cur = head</span><br><span class="line">                <span class="comment"># 更新头结点为下一个节点，继续遍历</span></span><br><span class="line">                head = tmp</span><br><span class="line">            <span class="comment"># 更新头结点为翻转后的头结点</span></span><br><span class="line">            head = cur</span><br><span class="line">        <span class="comment"># 返回翻转后的头结点</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></li>
<li>算法题<br><img src="/2024/05/07/2024-05-07-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/506abac65d64534a90e693fc7ec71ca.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">nums, k</span>):</span><br><span class="line">            <span class="comment"># 随机选择一个元素作为枢轴</span></span><br><span class="line">            pivot = nums[random.randint(<span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)]</span><br><span class="line">            <span class="comment"># 初始化三个列表，用于存放比枢轴大、小和相等的元素</span></span><br><span class="line">            big, small, equal = [], [], []</span><br><span class="line">            <span class="comment"># 遍历数组，根据与枢轴的大小关系将元素放入对应的列表中</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> num &lt; pivot:</span><br><span class="line">                    small.append(num)</span><br><span class="line">                <span class="keyword">elif</span> num &gt; pivot:</span><br><span class="line">                    big.append(num)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    equal.append(num)</span><br><span class="line">            <span class="comment"># 如果要找的第 k 大的元素在大于枢轴的列表中</span></span><br><span class="line">            <span class="keyword">if</span> k &lt;= <span class="built_in">len</span>(big):</span><br><span class="line">                <span class="comment"># 递归处理大于枢轴的列表</span></span><br><span class="line">                <span class="keyword">return</span> process(big, k)</span><br><span class="line">            <span class="comment"># 如果要找的第 k 大的元素在小于枢轴的列表中</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nums) - <span class="built_in">len</span>(small) &lt; k:</span><br><span class="line">                <span class="comment"># 递归处理小于枢轴的列表，并调整第 k 的值</span></span><br><span class="line">                <span class="keyword">return</span> process(small, k-(<span class="built_in">len</span>(nums)-<span class="built_in">len</span>(small)))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果第 k 大的元素正好等于枢轴，则返回枢轴</span></span><br><span class="line">                <span class="keyword">return</span> pivot</span><br><span class="line">        <span class="comment"># 调用递归函数，并返回结果</span></span><br><span class="line">        <span class="keyword">return</span> process(nums, k)</span><br></pre></td></tr></table></figure></li>
<li>二分<br><img src="/2024/05/07/2024-05-07-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/3d6505d22f05fd6b944be7005dd92b8.png" alt="alt text"><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化左右边界</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="comment"># 开始二分查找</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            <span class="comment"># 计算中间位置</span></span><br><span class="line">            mid = (l+r) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 如果中间位置的元素就是目标值，返回该位置</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="comment"># 如果中间位置的元素大于等于左边界的元素，说明左半部分是有序的</span></span><br><span class="line">            <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= nums[mid]:</span><br><span class="line">                <span class="comment"># 如果目标值在左半部分且不大于中间位置的元素，将搜索范围缩小为左半部分</span></span><br><span class="line">                <span class="keyword">if</span> nums[l] &lt;= target &lt; nums[mid]:</span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 否则，将搜索范围缩小为右半部分</span></span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果中间位置的元素小于左边界的元素，说明左半部分不是有序的，右半部分是有序的</span></span><br><span class="line">                <span class="comment"># 如果目标值在右半部分且不小于中间位置的元素，将搜索范围缩小为右半部分</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[r]:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 否则，将搜索范围缩小为左半部分</span></span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果没有找到目标值，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
